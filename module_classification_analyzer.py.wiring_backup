#!/usr/bin/env python3
"""
üîç GENESIS MODULE CLASSIFICATION ANALYZER
Provides comprehensive breakdown of module categories, roles, and status
"""

import json
import os
from pathlib import Path
from collections import defaultdict, Counter

def analyze_module_classification():
    """Analyze and report comprehensive module classification"""
    
    # Load module registry
    registry_path = Path("module_registry.json")
    if not registry_path.exists():
        print("‚ùå module_registry.json not found")
        return
    
    with open(registry_path, 'r', encoding='utf-8') as f:
        registry = json.load(f)
    
    modules = registry.get('modules', {})
    
    # Initialize counters
    category_stats = defaultdict(lambda: {'total': 0, 'complete': 0, 'needs_enhancement': 0})
    role_stats = Counter()
    status_stats = Counter()
    
    # Analyze each module
    for module_name, module_data in modules.items():
        category = module_data.get('category', 'UNCLASSIFIED')
        status = module_data.get('status', 'UNKNOWN')
        roles = module_data.get('roles', [])
        eventbus_integrated = module_data.get('eventbus_integrated', False)
        telemetry_enabled = module_data.get('telemetry_enabled', False)
        
        # Count by category
        category_stats[category]['total'] += 1
        
        # Determine if complete or needs enhancement
        if eventbus_integrated and telemetry_enabled and status == 'ACTIVE':
            category_stats[category]['complete'] += 1
        else:
            category_stats[category]['needs_enhancement'] += 1
        
        # Count roles
        for role in roles:
            role_stats[role] += 1
        
        # Count status
        status_stats[status] += 1
    
    # Generate report
    print("üèóÔ∏è GENESIS MODULE CLASSIFICATION ANALYSIS")
    print("=" * 60)
    print()
    
    print("üìä MODULE CATEGORIES OVERVIEW:")
    print()
    
    total_modules = 0
    total_complete = 0
    total_needs_enhancement = 0
    
    category_order = [
        'CORE.SYSTEM',
        'MODULES.EXECUTION', 
        'MODULES.ML_OPTIMIZATION',
        'MODULES.RISK_MANAGEMENT',
        'MODULES.SIGNAL_PROCESSING',
        'MODULES.UNCLASSIFIED',
        'COMPLIANCE.SYSTEM',
        'UI.COMPONENTS'
    ]
    
    for category in category_order:
        if category in category_stats:
            stats = category_stats[category]
            total_modules += stats['total']
            total_complete += stats['complete']
            total_needs_enhancement += stats['needs_enhancement']
            
            status_icon = "‚úÖ" if stats['needs_enhancement'] == 0 else "üîß"
            print(f"{category} ‚Üí {stats['total']} ‚Üí {stats['complete']} complete / {stats['needs_enhancement']} patch required {status_icon}")
    
    # Add any remaining categories not in the order
    for category, stats in category_stats.items():
        if category not in category_order:
            total_modules += stats['total']
            total_complete += stats['complete']
            total_needs_enhancement += stats['needs_enhancement']
            
            status_icon = "‚úÖ" if stats['needs_enhancement'] == 0 else "üîß"
            print(f"{category} ‚Üí {stats['total']} ‚Üí {stats['complete']} complete / {stats['needs_enhancement']} patch required {status_icon}")
    
    print()
    print("=" * 60)
    print(f"TOTAL MODULES: {total_modules}")
    print(f"COMPLETE: {total_complete}")
    print(f"NEEDS ENHANCEMENT: {total_needs_enhancement}")
    print(f"COMPLETION RATE: {(total_complete/total_modules*100):.1f}%")
    print("=" * 60)
    print()
    
    print("üéØ MODULE ROLES DISTRIBUTION:")
    for role, count in role_stats.most_common():
        print(f"  {role}: {count} modules")
    print()
    
    print("üìà MODULE STATUS BREAKDOWN:")
    for status, count in status_stats.most_common():
        print(f"  {status}: {count} modules")
    print()
    
    # Check EventBus and Telemetry integration
    eventbus_count = sum(1 for m in modules.values() if m.get('eventbus_integrated', False))
    telemetry_count = sum(1 for m in modules.values() if m.get('telemetry_enabled', False))
    compliance_count = sum(1 for m in modules.values() if m.get('compliance_status') == 'COMPLIANT')
    
    print("üîó SYSTEM INTEGRATION STATUS:")
    print(f"  EventBus Integration: {eventbus_count}/{total_modules} modules ({eventbus_count/total_modules*100:.1f}%)")
    print(f"  Telemetry Enabled: {telemetry_count}/{total_modules} modules ({telemetry_count/total_modules*100:.1f}%)")
    print(f"  Compliance Status: {compliance_count}/{total_modules} modules ({compliance_count/total_modules*100:.1f}%)")
    print()
    
    print("üü¢ SYSTEM STATUS:")
    if total_needs_enhancement == 0:
        print("  ‚úÖ ALL MODULES ENHANCED AND READY FOR LIVE OPERATION")
    else:
        print(f"  üîß {total_needs_enhancement} modules still need enhancement")
        print(f"  üìä System is {(total_complete/total_modules*100):.1f}% ready for live operation")
    
    return {
        'total_modules': total_modules,
        'complete': total_complete,
        'needs_enhancement': total_needs_enhancement,
        'completion_rate': total_complete/total_modules*100,
        'eventbus_integration': eventbus_count/total_modules*100,
        'telemetry_integration': telemetry_count/total_modules*100,
        'compliance_rate': compliance_count/total_modules*100
    }

if __name__ == "__main__":
    analyze_module_classification()
