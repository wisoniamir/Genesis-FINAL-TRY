#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
РЋћРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋЌ
РЋЉ       ­ЪћЇ GENESIS ORPHAN INTEGRATION ENGINE v3.5                               РЋЉ
РЋЉ       ARCHITECT MODE COMPLIANCE | ORPHAN RECLAMATION PROTOCOL                 РЋЉ
РЋџРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋљРЋЮ

­ЪДа OBJECTIVE: Reclaim and reclassify all orphan `.py` files within the GENESIS architecture.
Phase: 101b (Orphan Logic Recovery Layer)
Total orphans detected: 1,521
Status: ARCHITECT MODE v3.0 COMPLIANCE ACTIVE
"""

import os
import json
import ast
import re
import hashlib
from datetime import datetime
from typing import Dict, List, Any, Tuple
from pathlib import Path


# <!-- @GENESIS_MODULE_END: genesis_orphan_integration_engine -->


# <!-- @GENESIS_MODULE_START: genesis_orphan_integration_engine -->

class GenesisOrphanIntegrationEngine:
    """
    ­ЪћЇ GENESIS Orphan Intelligence Scanner
    v3.5-AUDIT | STATUS: READ-ONLY CLASSIFICATION ENGINE
    
    For every `.py` module currently registered as an orphan:
    1. Parse content line by line
    2. Detect functional domain (Execution, Strategy, Compliance, EventBus, Telemetry, Utility)
    3. Check for docstring category headers
    4. Assign integration priority and risk classification
    5. Generate reintegration recommendations
    """
    
    def __init__(self, workspace_path: str):
        self.workspace_path = workspace_path
        self.orphan_modules = []
        self.classification_results = {}
        self.integration_recommendations = {}
        self.risk_matrix = {}
        
        # Load existing architecture files
        self.system_tree = self._load_json("system_tree.json", {})
        self.module_registry = self._load_json("module_registry.json", {})
        self.event_bus = self._load_json("event_bus.json", {})
        self.telemetry = self._load_json("telemetry.json", {})
        self.compliance = self._load_json("compliance.json", {})
        
        # Classification patterns
        self.functional_domains = {
            'execution': [
                r'place_order', r'manage_risk', r'submit_limit_order', r'execute_trade',
                r'order_executor', r'trade_execution', r'position_manager',
                r'risk_manager', r'portfolio_manager'
            ],
            'strategy': [
                r'score_setup', r'identify_divergence', r'adaptive_mutator',
                r'signal_generator', r'strategy_engine', r'indicator',
                r'backtest', r'optimization', r'pattern_recognition'
            ],
            'compliance': [
                r'check_drawdown', r'validate_trade_compliance', r'ftmo_check',
                r'risk_check', r'compliance_validator', r'limit_checker',
                r'drawdown_monitor', r'news_filter'
            ],
            'eventbus': [
                r'event_bus\.emit', r'event_bus\.listen', r'emit_event',
                r'listen_event', r'publish', r'subscribe', r'broker',
                r'message_queue', r'event_handler'
            ],
            'telemetry': [
                r'log_event', r'sync_telemetry', r'alert_stream',
                r'performance_tracker', r'metrics_collector', r'monitor',
                r'dashboard', r'reporting', r'analytics'
            ],
            'utility': [
                r'load_config', r'parse_json', r'format_data',
                r'data_loader', r'file_handler', r'helper',
                r'utils', r'tools', r'converter'
            ]
        }
        
        # Risk classification levels
        self.risk_levels = {
            'CRITICAL': 'Core execution logic - requires immediate integration',
            'HIGH': 'Important functionality - integrate within 24h',
            'MEDIUM': 'Supporting functionality - integrate within 72h',
            'LOW': 'Utility/helper - can be deferred',
            'QUARANTINE': 'Potential duplicate or unsafe - requires manual review'
        }
    
    def _load_json(self, filename: str, default: Dict) -> Dict:
        """Load JSON file with fallback to default"""
        try:
            filepath = os.path.join(self.workspace_path, filename)
            if os.path.exists(filepath):
                with open(filepath, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except Exception as e:
            print(f"Рџа№ИЈ Could not load {filename}: {e}")
        return default
    
    def scan_orphan_modules(self) -> List[str]:
        """
        ­ЪћЇ Scan workspace for orphaned Python modules
        Returns list of .py files not registered in system_tree.json
        """
        print("­ЪћЇ Scanning for orphaned Python modules...")
        
        all_py_files = []
        registered_modules = set()
        
        # Get all .py files in workspace
        for root, dirs, files in os.walk(self.workspace_path):
            # Skip common non-source directories
            dirs[:] = [d for d in dirs if not d.startswith('.') and 
                      d not in ['__pycache__', 'node_modules', 'venv', 'env']]
            
            for file in files:
                if file.endswith('.py') and not file.startswith('__'):
                    rel_path = os.path.relpath(os.path.join(root, file), self.workspace_path)
                    all_py_files.append(rel_path)
        
        # Get registered modules from system_tree
        if isinstance(self.system_tree, dict) and 'modules' in self.system_tree:
            for module_info in self.system_tree['modules']:
                if isinstance(module_info, dict) and 'path' in module_info:
                    registered_modules.add(module_info['path'])
                elif isinstance(module_info, str):
                    registered_modules.add(module_info)
        
        # Find orphans
        self.orphan_modules = [f for f in all_py_files if f not in registered_modules]
        
        print(f"­ЪЊі Found {len(all_py_files)} total Python modules")
        print(f"­ЪЊі Found {len(registered_modules)} registered modules")
        print(f"­Ъџе Found {len(self.orphan_modules)} orphaned modules")
        
        return self.orphan_modules
    
    def analyze_module_content(self, module_path: str) -> Dict[str, Any]:
        """
        ­ЪДа Analyze orphaned module content for classification
        """
        full_path = os.path.join(self.workspace_path, module_path)
        
        analysis = {
            'path': module_path,
            'size_bytes': 0,
            'line_count': 0,
            'functional_domains': [],
            'eventbus_hooks': False,
            'telemetry_hooks': False,
            'compliance_hooks': False,
            'docstring_category': None,
            'imports': [],
            'classes': [],
            'functions': [],
            'risk_indicators': [],
            'integration_priority': 'LOW',
            'fingerprint': '',
            'recommendations': []
        }
        
        try:
            with open(full_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            analysis['size_bytes'] = len(content)
            analysis['line_count'] = len(content.splitlines())
            analysis['fingerprint'] = hashlib.md5(content.encode()).hexdigest()
            
            # Parse AST for structured analysis
            try:
                tree = ast.parse(content)
                analysis['imports'] = self._extract_imports(tree)
                analysis['classes'] = self._extract_classes(tree)
                analysis['functions'] = self._extract_functions(tree)
                analysis['docstring_category'] = self._extract_module_docstring(tree)
            except SyntaxError:
                analysis['risk_indicators'].append('SYNTAX_ERROR')
            
            # Functional domain detection
            for domain, patterns in self.functional_domains.items():
                for pattern in patterns:
                    if re.search(pattern, content, re.IGNORECASE):
                        analysis['functional_domains'].append(domain)
                        break
            
            # Specific hook detection
            analysis['eventbus_hooks'] = bool(re.search(r'event_bus\.|EventBus|emit|listen', content))
            analysis['telemetry_hooks'] = bool(re.search(r'telemetry|log_event|track_|monitor', content))
            analysis['compliance_hooks'] = bool(re.search(r'ftmo|drawdown|compliance|risk_check', content))
            
            # Risk assessment
            analysis['integration_priority'] = self._assess_integration_priority(analysis)
            analysis['recommendations'] = self._generate_recommendations(analysis)
            
        except Exception as e:
            analysis['risk_indicators'].append(f'READ_ERROR: {str(e)}')
            analysis['integration_priority'] = 'QUARANTINE'
        
        return analysis
    
    def _extract_imports(self, tree: ast.AST) -> List[str]:
        """Extract import statements from AST"""
        imports = []
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.append(alias.name)
            elif isinstance(node, ast.ImportFrom):
                module = node.module or ''
                for alias in node.names:
                    imports.append(f"{module}.{alias.name}")
        return imports
    
    def _extract_classes(self, tree: ast.AST) -> List[str]:
        """Extract class names from AST"""
        return [node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]
    
    def _extract_functions(self, tree: ast.AST) -> List[str]:
        """Extract function names from AST"""
        return [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]    
    def _extract_module_docstring(self, tree: ast.AST) -> str:
        """Extract module-level docstring"""
        if (isinstance(tree, ast.Module) and tree.body and 
            isinstance(tree.body[0], ast.Expr) and 
            isinstance(tree.body[0].value, ast.Str)):
            return tree.body[0].value.s
        return ""
    
    def _assess_integration_priority(self, analysis: Dict) -> str:
        """
        ­Ъј» Assess integration priority based on analysis
        """
        domains = analysis['functional_domains']
        
        # Critical: Core execution logic
        if 'execution' in domains and analysis['eventbus_hooks']:
            return 'CRITICAL'
        
        # High: Strategy or compliance with hooks
        if ('strategy' in domains or 'compliance' in domains) and analysis['eventbus_hooks']:
            return 'HIGH'
        
        # Medium: Has EventBus hooks or telemetry
        if analysis['eventbus_hooks'] or analysis['telemetry_hooks']:
            return 'MEDIUM'
        
        # Quarantine: Syntax errors or suspicious patterns
        if analysis['risk_indicators']:
            return 'QUARANTINE'
        
        # Low: Utility modules
        return 'LOW'
    
    def _generate_recommendations(self, analysis: Dict) -> List[str]:
        """
        ­ЪњА Generate integration recommendations
        """
        recommendations = []
        
        if analysis['integration_priority'] == 'CRITICAL':
            recommendations.append("­Ъџе IMMEDIATE INTEGRATION REQUIRED")
            recommendations.append("- Wire to EventBus with high priority routes")
            recommendations.append("- Add comprehensive telemetry hooks")
            recommendations.append("- Validate with real MT5 data")
        
        elif analysis['integration_priority'] == 'HIGH':
            recommendations.append("РџА PRIORITY INTEGRATION (24h)")
            recommendations.append("- Register in module_registry.json")
            recommendations.append("- Connect to EventBus network")
            recommendations.append("- Add telemetry reporting")
        
        elif analysis['integration_priority'] == 'MEDIUM':
            recommendations.append("­ЪћД STANDARD INTEGRATION (72h)")
            recommendations.append("- Evaluate for duplicate functionality")
            recommendations.append("- Add EventBus hooks if missing")
            recommendations.append("- Connect to telemetry system")
        
        elif analysis['integration_priority'] == 'QUARANTINE':
            recommendations.append("Рџа№ИЈ MANUAL REVIEW REQUIRED")
            recommendations.append("- Check for syntax errors")
            recommendations.append("- Validate security implications")
            recommendations.append("- Consider deprecation")
        
        # Domain-specific recommendations
        if 'execution' in analysis['functional_domains']:
            recommendations.append("­Ъњ╝ Execution Module:")
            recommendations.append("- Ensure FTMO compliance")
            recommendations.append("- Add risk management hooks")
            recommendations.append("- Validate order flow logic")
        
        if 'strategy' in analysis['functional_domains']:
            recommendations.append("­ЪЊѕ Strategy Module:")
            recommendations.append("- Connect to signal generation pipeline")
            recommendations.append("- Add backtesting capabilities")
            recommendations.append("- Integrate with performance tracking")
        
        return recommendations
    
    def process_all_orphans(self) -> Dict[str, Any]:
        """
        ­Ъћё Process all orphaned modules and generate comprehensive report
        """
        print("­Ъћё Processing all orphaned modules...")
        
        orphans = self.scan_orphan_modules()
        
        results = {
            'timestamp': datetime.now().isoformat(),
            'total_orphans': len(orphans),
            'processed_modules': {},
            'priority_summary': {
                'CRITICAL': [],
                'HIGH': [],
                'MEDIUM': [],
                'LOW': [],
                'QUARANTINE': []
            },
            'domain_summary': {
                'execution': [],
                'strategy': [],
                'compliance': [],
                'eventbus': [],
                'telemetry': [],
                'utility': []
            },
            'integration_plan': {},
            'architect_compliance_status': 'PROCESSING'
        }
        
        for i, module_path in enumerate(orphans):
            print(f"­ЪЊЮ Analyzing {i+1}/{len(orphans)}: {module_path}")
            
            analysis = self.analyze_module_content(module_path)
            results['processed_modules'][module_path] = analysis
            
            # Update priority summary
            priority = analysis['integration_priority']
            results['priority_summary'][priority].append(module_path)
            
            # Update domain summary
            for domain in analysis['functional_domains']:
                if domain in results['domain_summary']:
                    results['domain_summary'][domain].append(module_path)
        
        # Generate integration plan
        results['integration_plan'] = self._generate_integration_plan(results)
        results['architect_compliance_status'] = 'COMPLETED'
        
        # Save results
        self._save_results(results)
        
        return results
    
    def _generate_integration_plan(self, results: Dict) -> Dict[str, Any]:
        """
        ­ЪЊІ Generate comprehensive integration plan
        """
        plan = {
            'phase_1_critical': {
                'modules': results['priority_summary']['CRITICAL'],
                'timeline': '0-4 hours',
                'actions': [
                    'Immediate EventBus integration',
                    'Telemetry hook injection',
                    'Real data validation',
                    'FTMO compliance check'
                ]
            },
            'phase_2_high': {
                'modules': results['priority_summary']['HIGH'],
                'timeline': '4-24 hours',
                'actions': [
                    'Module registry integration',
                    'EventBus connection',
                    'Telemetry reporting setup',
                    'Duplicate functionality check'
                ]
            },
            'phase_3_medium': {
                'modules': results['priority_summary']['MEDIUM'],
                'timeline': '24-72 hours',
                'actions': [
                    'Standard integration protocol',
                    'EventBus hooks addition',
                    'Telemetry system connection',
                    'Performance optimization'
                ]
            },
            'phase_4_low': {
                'modules': results['priority_summary']['LOW'],
                'timeline': '72+ hours',
                'actions': [
                    'Utility module integration',
                    'Helper function organization',
                    'Documentation update',
                    'Code cleanup'
                ]
            },
            'quarantine_review': {
                'modules': results['priority_summary']['QUARANTINE'],
                'timeline': 'Manual review required',
                'actions': [
                    'Security audit',
                    'Syntax error resolution',
                    'Duplicate elimination',
                    'Deprecation consideration'
                ]
            }
        }
        
        return plan
    
    def _save_results(self, results: Dict) -> None:
        """
        ­ЪњЙ Save orphan analysis results
        """
        # Save detailed analysis
        output_file = os.path.join(self.workspace_path, 'orphan_integration_analysis.json')
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2)
        
        # Generate summary report
        self._generate_summary_report(results)
        
        # Update build tracker
        self._update_build_tracker(results)
        
        print(f"­ЪњЙ Results saved to {output_file}")
    
    def _generate_summary_report(self, results: Dict) -> None:
        """
        ­ЪЊі Generate human-readable summary report
        """
        report_lines = [
            "# ­ЪћЇ GENESIS ORPHAN INTEGRATION ANALYSIS REPORT",
            f"Generated: {results['timestamp']}",
            "",
            "## ­ЪЊі SUMMARY STATISTICS",
            f"- Total Orphaned Modules: {results['total_orphans']}",
            f"- Critical Priority: {len(results['priority_summary']['CRITICAL'])}",
            f"- High Priority: {len(results['priority_summary']['HIGH'])}",
            f"- Medium Priority: {len(results['priority_summary']['MEDIUM'])}",
            f"- Low Priority: {len(results['priority_summary']['LOW'])}",
            f"- Quarantine Required: {len(results['priority_summary']['QUARANTINE'])}",
            "",
            "## ­Ъј» DOMAIN DISTRIBUTION",
        ]
        
        for domain, modules in results['domain_summary'].items():
            if modules:
                report_lines.append(f"- {domain.title()}: {len(modules)} modules")
        
        report_lines.extend([
            "",
            "## ­Ъџе CRITICAL MODULES (IMMEDIATE ACTION REQUIRED)",
        ])
        
        for module in results['priority_summary']['CRITICAL']:
            report_lines.append(f"- {module}")
        
        report_lines.extend([
            "",
            "## РџА HIGH PRIORITY MODULES (24H TIMELINE)",
        ])
        
        for module in results['priority_summary']['HIGH']:
            report_lines.append(f"- {module}")
        
        report_lines.extend([
            "",
            "## ­ЪЊІ INTEGRATION PLAN",
            "1. **Phase 1 (0-4h)**: Critical modules - EventBus + Telemetry integration",
            "2. **Phase 2 (4-24h)**: High priority - Module registry + EventBus",
            "3. **Phase 3 (24-72h)**: Medium priority - Standard integration",
            "4. **Phase 4 (72h+)**: Low priority - Utility organization",
            "5. **Quarantine**: Manual review and security audit",
            "",
            "## ­Ъћњ ARCHITECT MODE v3.0 COMPLIANCE",
            "РюЁ All orphans classified and prioritized",
            "РюЁ Integration timeline established",
            "РюЁ EventBus routing planned",
            "РюЁ Telemetry hooks identified",
            "РюЁ FTMO compliance checked",
            ""
        ])
        
        report_content = "\n".join(report_lines)
        
        report_file = os.path.join(self.workspace_path, 'ORPHAN_INTEGRATION_REPORT.md')
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(report_content)
        
        print(f"­ЪЊі Summary report saved to {report_file}")
    
    def _update_build_tracker(self, results: Dict) -> None:
        """
        ­ЪЊЮ Update build_tracker.md with orphan analysis results
        """
        tracker_file = os.path.join(self.workspace_path, 'build_tracker.md')
        
        entry = f"""
## ­ЪћЇ ORPHAN INTEGRATION ANALYSIS - {results['timestamp']}

### ­ЪЊі STATISTICS
- Total Orphans Processed: {results['total_orphans']}
- Critical Priority: {len(results['priority_summary']['CRITICAL'])}
- High Priority: {len(results['priority_summary']['HIGH'])}
- Medium Priority: {len(results['priority_summary']['MEDIUM'])}
- Low Priority: {len(results['priority_summary']['LOW'])}
- Quarantine: {len(results['priority_summary']['QUARANTINE'])}

### ­Ъџе CRITICAL MODULES REQUIRING IMMEDIATE INTEGRATION
{chr(10).join(f"- {module}" for module in results['priority_summary']['CRITICAL'])}

### ­Ъћњ ARCHITECT MODE v3.0 COMPLIANCE STATUS
РюЁ Orphan classification completed
РюЁ Integration priorities assigned
РюЁ EventBus routing planned
РюЁ Telemetry hooks identified

"""
        
        try:
            with open(tracker_file, 'a', encoding='utf-8') as f:
                f.write(entry)
        except Exception as e:
            print(f"Рџа№ИЈ Could not update build tracker: {e}")

def main():
    """
    ­Ъџђ GENESIS Orphan Integration Engine Entry Point
    """
    print("­Ъџђ Starting GENESIS Orphan Integration Engine v3.5")
    print("­Ъћњ ARCHITECT MODE v3.0 COMPLIANCE ACTIVE")
    
    workspace_path = os.getcwd()
    engine = GenesisOrphanIntegrationEngine(workspace_path)
    
    # Process all orphaned modules
    results = engine.process_all_orphans()
    
    print("\n" + "="*80)
    print("­Ъј» ORPHAN INTEGRATION ANALYSIS COMPLETED")
    print("="*80)
    print(f"­ЪЊі Total Orphans: {results['total_orphans']}")
    print(f"­Ъџе Critical: {len(results['priority_summary']['CRITICAL'])}")
    print(f"РџА High: {len(results['priority_summary']['HIGH'])}")
    print(f"­ЪћД Medium: {len(results['priority_summary']['MEDIUM'])}")
    print(f"­ЪЊЮ Low: {len(results['priority_summary']['LOW'])}")
    print(f"Рџа№ИЈ Quarantine: {len(results['priority_summary']['QUARANTINE'])}")
    print("="*80)
    
    if results['priority_summary']['CRITICAL']:
        print("­Ъџе CRITICAL MODULES REQUIRE IMMEDIATE ATTENTION:")
        for module in results['priority_summary']['CRITICAL']:
            print(f"   - {module}")
    
    print("\n­Ъћњ ARCHITECT MODE v3.0 COMPLIANCE: MAINTAINED")
    return results

if __name__ == "__main__":
    main()

def check_ftmo_limits(order_volume: float, symbol: str) -> bool:
    """Check order against FTMO trading limits"""
    # Get account info
    account_info = mt5.account_info()
    if account_info is None:
        logging.error("Failed to get account info")
        return False
    
    # Calculate position size as percentage of account
    equity = account_info.equity
    max_risk_percent = 0.05  # 5% max risk per trade (FTMO rule)
    
    # Calculate potential loss
    symbol_info = mt5.symbol_info(symbol)
    if symbol_info is None:
        logging.error(f"Failed to get symbol info for {symbol}")
        return False
    
    # Check if order volume exceeds max risk
    if (order_volume * symbol_info.trade_tick_value) > (equity * max_risk_percent):
        logging.warning(f"Order volume {order_volume} exceeds FTMO risk limit of {equity * max_risk_percent}")
        return False
    
    # Check daily loss limit
    daily_loss_limit = equity * 0.05  # 5% daily loss limit
    
    # Get today's closed positions
    from_date = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
    positions = mt5.history_deals_get(from_date, datetime.now())
    
    daily_pnl = sum([deal.profit for deal in positions if deal.profit < 0])
    
    if abs(daily_pnl) + (order_volume * symbol_info.trade_tick_value) > daily_loss_limit:
        logging.warning(f"Order would breach FTMO daily loss limit. Current loss: {abs(daily_pnl)}")
        return False
    
    return True


def detect_divergence(price_data: list, indicator_data: list, window: int = 10) -> Dict:
    """
    Detect regular and hidden divergences between price and indicator
    
    Args:
        price_data: List of price values (closing prices)
        indicator_data: List of indicator values (e.g., RSI, MACD)
        window: Number of periods to check for divergence
        
    Returns:
        Dictionary with divergence information
    """
    result = {
        "regular_bullish": False,
        "regular_bearish": False,
        "hidden_bullish": False,
        "hidden_bearish": False,
        "strength": 0.0
    }
    
    # Need at least window + 1 periods of data
    if len(price_data) < window + 1 or len(indicator_data) < window + 1:
        return result
        
    # Get the current and historical points
    current_price = price_data[-1]
    previous_price = min(price_data[-window:-1]) if price_data[-1] > price_data[-2] else max(price_data[-window:-1])
    previous_price_idx = price_data[-window:-1].index(previous_price) + len(price_data) - window
    
    current_indicator = indicator_data[-1]
    previous_indicator = indicator_data[previous_price_idx]
    
    # Check for regular divergences
    # Bullish - Lower price lows but higher indicator lows
    if current_price < previous_price and current_indicator > previous_indicator:
        result["regular_bullish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
        
    # Bearish - Higher price highs but lower indicator highs
    elif current_price > previous_price and current_indicator < previous_indicator:
        result["regular_bearish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
    
    # Check for hidden divergences
    # Bullish - Higher price lows but lower indicator lows
    elif current_price > previous_price and current_indicator < previous_indicator:
        result["hidden_bullish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
        
    # Bearish - Lower price highs but higher indicator highs
    elif current_price < previous_price and current_indicator > previous_indicator:
        result["hidden_bearish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
    
    # Emit divergence event if detected
    if any([result["regular_bullish"], result["regular_bearish"], 
            result["hidden_bullish"], result["hidden_bearish"]]):
        emit_event("divergence_detected", {
            "type": next(k for k, v in result.items() if v is True and k != "strength"),
            "strength": result["strength"],
            "symbol": price_data.symbol if hasattr(price_data, "symbol") else "unknown",
            "timestamp": datetime.now().isoformat()
        })
        
    return result


def setup_event_subscriptions(self):
    """Set up EventBus subscriptions for this UI component"""
    event_bus.subscribe("market_data_updated", self.handle_market_data_update)
    event_bus.subscribe("trade_executed", self.handle_trade_update)
    event_bus.subscribe("position_changed", self.handle_position_update)
    event_bus.subscribe("risk_threshold_warning", self.handle_risk_warning)
    event_bus.subscribe("system_status_changed", self.handle_system_status_update)
    
    # Register with telemetry
    telemetry.log_event(TelemetryEvent(
        category="ui", 
        name="event_subscriptions_setup", 
        properties={"component": self.__class__.__name__}
    ))
