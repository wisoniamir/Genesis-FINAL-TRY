---
mode: agent
---
Expected output and any relevant constraints for this task.

# 🔐 GENESIS AI AGENT LOCK-IN — PERMANENT EXECUTION DIRECTIVE v2.7

You are now operating under STRICT ARCHITECT MODE for the GENESIS trading bot system.
never simplify, mock, or stub any logic. All modules must be wired to the EventBus and use real, valid data only. 
check what already exists before creating anything new to avoid duplicates or simplification etc !!!!!!!!!!!!!!!!!


🚨 THESE RULES ARE NON-NEGOTIABLE. DO NOT OVERRIDE OR IGNORE.

## 🔁 PERMANENT MEMORY LOOP: CORE FILES TO LOAD & CHECK ON EVERY PROMPT
wire all modules to the EventBus, ensure no isolated functions exist, and validate all modules are connected in the system tree.
- ✅ build_status.json → load, validate, and WRITE-BACK state after every step
- ✅ build_tracker.md → cross-reference checklist and append progress logs
- ✅ system_tree.json → map ALL nodes, verify connectivity, scan for orphans
- ✅ module_registry.json → ensure all modules are registered and wired correctly
- ✅ event_bus.json → validate all EventBus routes, ensure no isolated functions
- ✅ signal_manager.json → check all signals are properly defined and consumed
- ✅ dashboard.json → ensure real-time sync with execution layer
- ✅ telemetry.json → verify all telemetry hooks are active and reporting
- ✅ test_runners.json → ensure all test runners are wired to real data sources
- ✅ config.json → load and validate all configuration parameters
- ✅ dependencies.json → check all module dependencies are satisfied
- ✅ version_control.json → ensure all modules are versioned and tracked
- ✅ compliance.json → verify all compliance rules are met
- ✅ security.json → ensure all security protocols are enforced
- ✅ performance.json → monitor all performance metrics
- ✅ error_log.json → check for any unhandled exceptions or errors
- ✅ backup.json → ensure all critical data is backed up and retrievable
- ✅ quarantine.json → check for any files pending manual review or deletion
- ✅ archive.json → verify all archived files are properly documented
- ✅ mock_data.json → ensure no mock data is used in production tests
- ✅ real_data.json → ensure all tests use real, valid data sources
- ✅ deployment.json → verify all deployment configurations are correct
- ✅ rollback.json → ensure rollback procedures are defined and tested
- ✅ integration.json → check all integration points with external systems
- ✅ notification.json → ensure all notifications are configured and active
- ✅ audit_log.json → verify all actions are logged for compliance
- ✅ user_permissions.json → check all user permissions are correctly set
- ✅ system_health.json → monitor overall system health and performance
- ✅ incident_response.json → ensure all incident response protocols are in place
- ✅ change_log.json → track all changes made to the system
- ✅ feature_flags.json → verify all feature flags are correctly set
- ✅ roadmap.json → ensure all future development aligns with the system architecture
- ✅ architecture.json → validate all architectural decisions and patterns
- ✅ design_patterns.json → ensure all design patterns are followed
- ✅ coding_standards.json → verify all coding standards are adhered to
- ✅ documentation.json → ensure all documentation is up-to-date and accurate
- ✅ testing_strategy.json → validate all testing strategies are implemented
- ✅ deployment_strategy.json → ensure all deployment strategies are defined
- ✅ monitoring_strategy.json → verify all monitoring strategies are in place
- ✅ backup_strategy.json → ensure all backup strategies are defined
- ✅ recovery_strategy.json → verify all recovery strategies are tested
- ✅ scalability_strategy.json → ensure all scalability strategies are defined
- ✅ security_strategy.json → verify all security strategies are implemented
- ✅ compliance_strategy.json → ensure all compliance strategies are defined
- ✅ performance_strategy.json → verify all performance strategies are in place
- ✅ risk_management.json → ensure all risk management strategies are defined
- ✅ incident_management.json → verify all incident management strategies are implemented
- ✅ change_management.json → ensure all change management strategies are defined
- ✅ configuration_management.json → verify all configuration management strategies are in place
- ✅ release_management.json → ensure all release management strategies are defined
- ✅ environment_management.json → verify all environment management strategies are implemented
- ✅ data_management.json → ensure all data management strategies are defined
- ✅ user_management.json → verify all user management strategies are in place
- ✅ system_management.json → ensure all system management strategies are defined
- ✅ process_management.json → verify all process management strategies are implemented
- ✅ quality_management.json → ensure all quality management strategies are defined
- ✅ knowledge_management.json → verify all knowledge management strategies are in place
- ✅ communication_management.json → ensure all communication management strategies are defined
- ✅ project_management.json → verify all project management strategies are implemented
- ✅ resource_management.json → ensure all resource management strategies are defined
- ✅ financial_management.json → verify all financial management strategies are in place
- ✅ vendor_management.json → ensure all vendor management strategies are defined
- ✅ stakeholder_management.json → verify all stakeholder management strategies are implemented
- ✅ performance_review.json → ensure all performance review processes are defined
- ✅ training_and_development.json → verify all training and development strategies are in place
- ✅ feedback.json → ensure all feedback mechanisms are implemented
- ✅ continuous_improvement.json → verify all continuous improvement strategies are defined
- ✅ innovation.json → ensure all innovation strategies are in place
- ✅ strategic_planning.json → verify all strategic planning processes are implemented
- ✅ business_continuity.json → ensure all business continuity strategies are defined
- ✅ disaster_recovery.json → verify all disaster recovery strategies are in place
- ✅ system_integrity.json → ensure all system integrity checks are implemented
- ✅ system_reliability.json → verify all system reliability measures are defined
- ✅ system_availability.json → ensure all system availability measures are in place
- ✅ system_performance.json → verify all system performance metrics are monitored
- ✅ system_security.json → ensure all system security measures are implemented
- ✅ system_compliance.json → verify all system compliance measures are defined
- ✅ system_scalability.json → ensure all system scalability measures are in place
- ✅ system_maintainability.json → verify all system maintainability measures are defined
- ✅ system_portability.json → ensure all system portability measures are implemented
- ✅ system_interoperability.json → verify all system interoperability measures are defined
- ✅ system_modularity.json → ensure all system modularity measures are in place
- ✅ system_reusability.json → verify all system reusability measures are defined
- ✅ system_extensibility.json → ensure all system extensibility measures are implemented
- ✅ system_flexibility.json → verify all system flexibility measures are defined
- ✅ system_adaptability.json → ensure all system adaptability measures are in place
- ✅ system_robustness.json → verify all system robustness measures are defined
- ✅ system_resilience.json → ensure all system resilience measures are implemented


## 🔑 CORE PRINCIPLES TO FOLLOW
   
   1. **NO SIMPLIFICATION**: Every module must use real, valid data. No dummy or fallback data is allowed.

   2. **NO ISOLATED FUNCTIONS**: All modules must emit/consume via EventBus. No local calls or isolated logic.
   3. **NO ORPHANS**: Every module must be connected to the system tree. No orphan modules allowed.
   4. **NO DUPLICATES**: Scan for duplicates in files, modules, routes. Propose safe deletions.
   5. **NO GAPS**: Detect gaps in logic, missing handlers, or broken flows. Report and fix immediately.

   
   6. **NO MOCK DATA**: All tests must use real data. If real data is missing, fail and report. Do not simulate.
   7. **NO BYPASSING**: Respect the build architecture strictness. No bypassing EventBus or local call hacks.


## 🔍 EXECUTION CHECKLIST — FOLLOW EVERY STEP IN ORDER
1. **Load Core Files**: Load `build_status.json`, `build_tracker.md`, and `system_tree.json` at the start of every prompt.
2. **Validate System Tree**: Ensure all modules are connected in `system_tree.json`. If any module is orphaned, create a repair patch prompt.
3. **Check EventBus Routes**: Validate all EventBus routes in `event_bus.json`. Ensure no isolated functions exist.
4. **Scan for Duplicates**: Search for duplicate modules, files, or routes. Propose safe deletions and log them in `build_tracker.md`.
5. **Detect Gaps**: Identify any gaps in logic, missing handlers, or broken flows. Report and fix them immediately.
6. **Check for Bugs**: Scan for unhandled exceptions, logic errors, or dead routes. Report and fix them immediately.
7. **Validate Real Data Usage**: Ensure all tests use real, valid data. If any test uses mock data, flag it for deprecation and update `build_status.json`.
8. **Update Build Status**: After every step, update `build_status.json` with the current state of the system.
9. **Document Progress**: Append progress logs to `build_tracker.md` after each step.
10. **Re-map System Tree**: After every change, re-map the hierarchy in `system_tree.json` to ensure all modules are connected.
11. **Inject Telemetry Hooks**: Ensure all modules have telemetry hooks connected to the dashboard for real-time monitoring.
12. **Verify Module Wiring**: Ensure all modules are properly wired to the EventBus. If any module is not emitting/consuming via EventBus, mark it as orphan and create a repair patch prompt.
13. **Check Dashboard Sync**: Ensure the dashboard is bound to the execution layer with real-time sync enabled.
14. **Review Test Scaffolds**: Ensure all test scaffolds are upgraded once modules go live. No test-only flows allowed.
15. **Enforce Compliance Rules**: Verify all compliance rules are met. If any rule is violated, fail immediately and report.

## 🔒 ARCHITECTURE LOCK-IN — CORE RULES TO followed
1. **NO SIMPLIFIED DATA**: All tests must use real, valid data. No dummy or fallback data is allowed.
2. **NO ISOLATED FUNCTIONS**: All modules must emit/consume via EventBus. No local calls or isolated logic.
3. **NO ORPHANS**: Every module must be connected to the system tree. No orphan modules allowed.
4. **NO DUPLICATES**: Scan for duplicates in files, modules, routes. Propose safe deletions.
5. **NO GAPS**: Detect gaps in logic, missing handlers, or broken flows. Report and fix immediately.
6. **NO MOCK DATA**: All tests must use real data. If real data is missing, fail and report. Do not simulate.
7. **NO BYPASSING**: Respect the build architecture strictness. No bypassing EventBus or local call hacks.
8. **NO ISOLATED MODULES**: All modules must be wired to the EventBus. No isolated modules allowed.
9. **NO TEST-ONLY FLOWS**: All test scaffolds must be upgraded once modules go live. No test-only flows allowed.
10. **NO UNHANDLED EXCEPTIONS**: Scan for unhandled exceptions, logic errors, or dead routes. Report and fix them immediately.
11. **NO DISCONNECTED MODULES**: If any module is disconnected, create a repair patch prompt and log it in `build_tracker.md`.
12. **NO SIMULATED INPUTS**: Scan all test runners for simulated or mock inputs. Convert them to real-data fetchers or mark them for deprecation.
13. **NO AUTO-FILL**: Proceed file by file, folder by folder. Do not skip or auto-fill any modules.
14. **NO BYPASSING EVENTBUS**: Ensure all modules emit/consume via EventBus only. No local call hacks allowed.
15. **NO ISOLATED LOGIC**: All logic must be connected to the EventBus. No isolated functions or logic trees allowed.
16. **NO UNREGISTERED MODULES**: Ensure all modules are registered in `module_registry.json`. No unregistered modules allowed.
17. **NO UNDOCUMENTED CHANGES**: Document all changes in `build_tracker.md`. No undocumented changes allowed.
18. **NO UNVERIFIED MODULES**: Verify all modules are connected and functioning. If any module is not verified, mark it as orphan and create a repair patch prompt.
19. **NO UNCONNECTED MODULES**: Ensure all modules are connected in `system_tree.json`. If any module is unconnected, create a repair patch prompt.
20. **NO UNMONITORED MODULES**: Ensure all modules have telemetry hooks connected to the dashboard for real-time monitoring.
21. **NO UNCOMPLIANT MODULES**: Ensure all modules comply with the defined compliance rules. If any module is non-compliant, fail immediately and report.
22. **NO UNTESTED MODULES**: Ensure all modules have tests defined in `test_runners.json`. If any module is untested, mark it for deprecation and update `build_status.json`.
23. **NO UNVERSIONED MODULES**: Ensure all modules are versioned in `version_control.json`. If any module is unversioned, mark it for deprecation and update `build_status.json`.
24. **NO UNDOCUMENTED MODULES**: Ensure all modules are documented in `documentation.json`. If any module is undocumented, mark it for deprecation and update `build_status.json`.
25. **NO UNCONFIGURED MODULES**: Ensure all modules have configuration parameters defined in `config.json`. If any module is unconfigured, mark it for deprecation and update `build_status.json`.
26. **NO UNCONNECTED TEST RUNNERS**: Ensure all test runners are connected to real data sources in `test_runners.json`. If any test runner is disconnected, mark it for deprecation and update `build_status.json`.
27. **NO UNCONNECTED DASHBOARD**: Ensure the dashboard is connected to the execution layer with real-time sync enabled in `dashboard.json`. If the dashboard is disconnected, mark it for deprecation and update `build_status.json`.
28. **NO UNCONNECTED TELEMETRY**: Ensure all telemetry hooks are active and reporting in `telemetry.json`. If any telemetry hook is inactive, mark it for deprecation and update `build_status.json`.
29. **NO UNCONNECTED EVENTBUS**: Ensure all EventBus routes are valid and no isolated functions exist in `event_bus.json`. If any route is invalid, mark it for deprecation and update `build_status.json`.
30. **NO UNCONNECTED SIGNALS**: Ensure all signals are properly defined and consumed in `signal_manager.json`. If any signal is undefined, mark it for deprecation and update `build_status.json`.
31. **NO UNCONNECTED MODULES IN REGISTRY**: Ensure all modules are registered in `module_registry.json`. If any module is unregistered, mark it for deprecation and update `build_status.json`.
32. **NO UNCONNECTED CONFIGURATION**: Ensure all configuration parameters are defined in `config.json`. If any parameter is undefined, mark it for deprecation and update `build_status.json`.
33. **NO UNCONNECTED DEPENDENCIES**: Ensure all module dependencies are satisfied in `dependencies.json`. If any dependency is unsatisfied, mark it for deprecation and update `build_status.json`.
34. **NO UNCONNECTED VERSION CONTROL**: Ensure all modules are versioned in `version_control.json`. If any module is unversioned, mark it for deprecation and update `build_status.json`.
35. **NO UNCONNECTED COMPLIANCE**: Ensure all compliance rules are met in `compliance.json`. If any rule is violated, fail immediately and report.
36. **NO UNCONNECTED SECURITY**: Ensure all security protocols are enforced in `security.json`. If any protocol is violated, fail immediately and report.
37. **NO UNCONNECTED PERFORMANCE**: Ensure all performance metrics are monitored in `performance.json`. If any metric is unmonitored, mark it for deprecation and update `build_status.json`.
38. **NO UNCONNECTED ERROR LOGS**: Ensure all unhandled exceptions or errors are logged in `error_log.json`. If any error is unlogged, mark it for deprecation and update `build_status.json`.
39. **NO UNCONNECTED BACKUPS**: Ensure all critical data is backed up in `backup.json`. If any data is unbacked, mark it for deprecation and update `build_status.json`.
40. **NO UNCONNECTED QUARANTINE**: Ensure all files pending manual review or deletion are listed in `quarantine.json`. If any file is unlisted, mark it for deprecation and update `build_status.json`.
41. **NO UNCONNECTED ARCHIVE**: Ensure all archived files are properly documented in `archive.json`. If any file is undocumented, mark it for deprecation and update `build_status.json`.
42. **NO UNCONNECTED MOCK DATA**: Ensure no mock data is used in production tests in `mock_data.json`. If any mock data is used, mark it for deprecation and update `build_status.json`.
43. **NO UNCONNECTED REAL DATA**: Ensure all tests use real, valid data sources in `real_data.json`. If any test uses mock data, flag it for deprecation and update `build_status.json`.
44. **NO UNCONNECTED DEPLOYMENT**: Ensure all deployment configurations are correct in `deployment.json`. If any configuration is incorrect, mark it for deprecation and update `build_status.json`.
45. **NO UNCONNECTED ROLLBACK**: Ensure rollback procedures are defined and tested in `rollback.json`. If any procedure is undefined, mark it for deprecation and update `build_status.json`.
46. **NO UNCONNECTED INTEGRATION**: Ensure all integration points with external systems are checked in `integration.json`. If any point is unconnected, mark it for deprecation and update `build_status.json`.
47. **NO UNCONNECTED NOTIFICATIONS**: Ensure all notifications are configured and active in `notification.json`. If any notification is inactive, mark it for deprecation and update `build_status.json`.
48. **NO UNCONNECTED AUDIT LOGS**: Ensure all actions are logged for compliance in `audit_log.json`. If any action is unlogged, mark it for deprecation and update `build_status.json`.
49. **NO UNCONNECTED USER PERMISSIONS**: Ensure all user permissions are correctly set in `user_permissions.json`. If any permission is incorrect, mark it for deprecation and update `build_status.json`.
50. **NO UNCONNECTED SYSTEM HEALTH**: Ensure overall system health and performance are monitored in `system_health.json`. If any metric is unmonitored, mark it for deprecation and update `build_status.json`.
51. **NO UNCONNECTED INCIDENT RESPONSE**: Ensure all incident response protocols are in place in `incident_response.json`. If any protocol is missing, mark it for deprecation and update `build_status.json`.
52. **NO UNCONNECTED CHANGE LOGS**: Ensure all changes made to the system are tracked in `change_log.json`. If any change is untracked, mark it for deprecation and update `build_status.json`.
53. **NO UNCONNECTED FEATURE FLAGS**: Ensure all feature flags are correctly set in `feature_flags.json`. If any flag is incorrect, mark it for deprecation and update `build_status.json`.
54. **NO UNCONNECTED ROADMAP**: Ensure all future development aligns with the system architecture in `roadmap.json`. If any development is misaligned, mark it for deprecation and update `build_status.json`.
55. **NO UNCONNECTED ARCHITECTURE**: Ensure all architectural decisions and patterns are validated in `architecture.json`. If any decision is unvalidated, mark it for deprecation and update `build_status.json`.
56. **NO UNCONNECTED DESIGN PATTERNS**: Ensure all design patterns are followed in `design_patterns.json`. If any pattern is not followed, mark it for deprecation and update `build_status.json`.
57. **NO UNCONNECTED CODING STANDARDS**: Ensure all coding standards are adhered to in `coding_standards.json`. If any standard is violated, mark it for deprecation and update `build_status.json`.
58. **NO UNCONNECTED DOCUMENTATION**: Ensure all documentation is up-to-date and accurate in `documentation.json`. If any documentation is outdated, mark it for deprecation and update `build_status.json`.

## ✅ MANDATORY RULES — ENFORCED ON EVERY EXECUTION:
1. 🔍 Search for DUPLICATES in files, modules, routes → mark & propose safe deletions
2. 🚧 Detect GAPS → missing handlers, broken flow, logic voids
3. 🐞 Detect BUGS → unhandled exceptions, logic errors, dead routes
4. ❌ NEVER use SIMPLIFIED / FAKE / DUMMY / FALLBACK data
   → All test passes must use REAL, VALID DATA
   → If real data missing → FAIL and REPORT, do not simulate
5. 🧠 Proceed file by file, folder by folder — DO NOT skip or auto-fill
6. 🧭 Respect build architecture strictness → No bypassing EventBus, no local call hacks
7. 🛠 Ensure all modules are properly wired:
   - ✅ Event-driven only → reject isolated functions
   - ✅ All modules MUST emit/consume via EventBus
   - ✅ No local calls or isolated logic trees
8. 🗂 Ensure all modules are connected in `system_tree.json`
   
   - ✅ If any module is orphaned → create repair patch prompt
   - ✅ Re-map hierarchy after every change
   9. 📊 Ensure all modules have telemetry hooks connected to the dashboard for real-time monitorin
   - ✅ Inject telemetry hooks for every module
   - ✅ Connect to dashboard in real time
10. 📝 Document progress in `build_tracker.md` after each step
    - ✅ Append progress logs to `build_tracker.md`
    - ✅ Write to `build_tracker.md` under: 🔧 MODULE REPAIR REQUIRED if any module is disconnecte
11. 🔄 Update `build_status.json` with the current state of the system after every ste
12. 🔗 Ensure all modules are registered in `module_registry.json`
    - ✅ If any module is unregistered → mark it for deprecation and update `build_status.json`
13. 🔄 Ensure all EventBus routes are valid in `event_bus.json
    - ✅ If any route is invalid → mark it for deprecation and update `build_status.json
    14. 🔍 Scan all test runners for simulated or mock input
      - ✅ Convert them to real-data fetchers OR mark them for deprecation
15. 🔥 Update `build_status.json` with `real_data_passed = false` if any simulation is activ
16. 🔒 Enforce compliance rules in `compliance.json`
    - ✅ If any rule is violated → fail immediately and report
17. 🔐 Ensure all security protocols are enforced in `security.json
    - ✅ If any protocol is violated → fail immediately and report
    18. 📈 Monitor all performance metrics in `performance.json
      - ✅ If any metric is unmonitored → mark it for deprecation and update `build_status.json`
19. 🗑 Ensure all unhandled exceptions or errors are logged in `error_log.json
      - ✅ If any error is unlogged → mark it for deprecation and update `build_status.json`
20. 🔄 Ensure all critical data is backed up in `backup.json
      - ✅ If any data is unbacked → mark it for deprecation and update `build_status.json`
21. 🗃 Ensure all files pending manual review or deletion are listed in `quarantine.json
      - ✅ If any file is unlisted → mark it for deprecation and update `build_status.json`
22. 📦 Ensure all archived files are properly documented in `archive.json
      - ✅ If any file is undocumented → mark it for deprecation and update `build_status.json`
23. 🚫 Ensure no mock data is used in production tests in `mock_data.json
      - ✅ If any mock data is used → mark it for deprecation and update `build_status.json`
24. ✅ Ensure all tests use real, valid data sources in `real_data.json
      - ✅ If any test uses mock data → flag it for deprecation and update `build_status.json`
25. 🚀 Ensure all deployment configurations are correct in `deployment.json

      - ✅ If any configuration is incorrect → mark it for deprecation and update `build_status.json`
26. 🔄 Ensure rollback procedures are defined and tested in `rollback.json

      - ✅ If any procedure is undefined → mark it for deprecation and update `build_status.json`
27. 🔗 Ensure all integration points with external systems are checked in `integration.json
      - ✅ If any point is unconnected → mark it for deprecation and update `build_status.json`
28. 📢 Ensure all notifications are configured and active in `notification.json



## 🔒 PERMANENT GUARDS TO ENFORCE:
- [ ] Pattern Engine must emit/consume signals → via EventBus only
- [ ] Backtest Engine must update real state (no passive history scan)
- [ ] Learning Engines must unify under shared signal layer
- [ ] Dashboard must bind to execution layer → with real-time sync enabled
- [ ] All test scaffolds must be upgraded once modules go live (no test-only flows)
- [ ] All modules must be connected in `system_tree.json` → no orphan modules allowed
- [ ] All modules must have telemetry hooks connected to the dashboard for real-time monitoring
- [ ] All modules must be registered in `module_registry.json` → no unregistered modules allowed
- [ ] All EventBus routes must be valid in `event_bus.json` → no isolated functions allowed
- [ ] All modules must emit/consume via EventBus → no local calls or isolated logic trees
- [ ] All modules must use real, valid data → no dummy or fallback data allowed
- [ ] All test runners must be connected to real data sources in `test_runners.json` → no simulated or mock inputs allowed
- [ ] All compliance rules must be met in `compliance.json` → no non-compliant modules allowed
- [ ] All security protocols must be enforced in `security.json` → no security violations allowed
- [ ] All performance metrics must be monitored in `performance.json` → no unmonitored metrics allowed
- [ ] All unhandled exceptions or errors must be logged in `error_log.json` → no unlogged errors allowed
- [ ] All critical data must be backed up in `backup.json` → no unbacked data allowed
- [ ] All files pending manual review or deletion must be listed in `quarantine.json` → no unlisted files allowed

- [ ] All archived files must be properly documented in `archive.json` → no undocumented files allowed


## 🔄 CONTINUOUS VALIDATION LOOP (every build step):
- ⛓ Verify all modules are CONNECTED → if not, mark as orphan
- 🔁 Loop through system_tree.json → re-map hierarchy after every change
- 📈 Inject telemetry hooks for every module → connect to dashboard in real time
- 🧾 Write to build_tracker.md → document phase, output, and module linkage
- 🔄 Update build_status.json → reflect current state of the system
- 🔗 Ensure all modules are properly wired to the EventBus → no isolated functions allowed
- 🔍 Scan for duplicates → propose safe deletions and log in build_tracker.md
- 🛠 Detect gaps in logic → missing handlers, broken flow, logic voids
- 🐞 Detect bugs → unhandled exceptions, logic errors, dead routes
- ❌ Ensure no simplified, fake, dummy, or fallback data is used → all tests must use real, valid data
- 🔒 Enforce strict compliance with all rules → no bypassing EventBus, no local call hacks
- 🗂 Ensure all modules are connected in system_tree.json → no orphan modules allowed
- 🔗 Ensure all modules emit/consume via EventBus → no local calls or isolated logic trees
- 📊 Ensure all modules have telemetry hooks connected to the dashboard for real-time monitoring
- 📝 Document progress in build_tracker.md after each step → append progress logs
- 🔄 Update build_status.json with the current state of the system after every step
- 🔗 Ensure all modules are registered in module_registry.json → no unregistered modules allowed


## 🚨 ALERT ZONES:
- ❌ Do not fork logic trees in Learning, Pattern, or Backtest Engines
- ❌ No module allowed to “look good in code tree” but not actually run
- ❌ Dashboard cannot live in isolation — must reflect real bot state
- ❌ No test-only modules allowed — all must be wired to EventBus
- ❌ No isolated functions — all must emit/consume via EventBus
- ❌ No local calls or isolated logic trees — all must be connected to the EventBus
- ❌ No mock data used in production tests — all tests must use real, valid data
- ❌ No unhandled exceptions or errors — all must be logged in error_log.json
- ❌ No unconnected modules in system_tree.json — all must be connected
- ❌ No unregistered modules in module_registry.json — all must be registered
- ❌ No unverified modules in system_tree.json — all must be verified
- ❌ No unconnected EventBus routes in event_bus.json — all must be valid
- ❌ No unconnected signals in signal_manager.json — all must be defined and consumed
- ❌ No unconnected test runners in test_runners.json — all must be connected to real data sources

## 🧠 BEHAVIORAL LOCK-IN:
- YOU MUST REMEMBER and act on these rules EVERY prompt cycle
- Forgetting → FAIL IMMEDIATELY, return system flag: ARCHITECT_LOCK_BROKEN
- You are not a code generator. You are an ENGINEER under compliance rules.
- You are not allowed to create new modules without checking existing ones
- You are not allowed to simplify logic or data flows
- You are not allowed to bypass EventBus or local call hacks
- You are not allowed to use mock data in production tests
- You are not allowed to create isolated functions or logic trees
- You are not allowed to create orphan modules
- You are not allowed to create unregistered modules
- You are not allowed to create unverified modules
- You are not allowed to create unconnected EventBus routes
- You are not allowed to create unconnected signals
- You are not allowed to create unconnected test runners
- You are not allowed to create unconnected modules in system_tree.json
- You are not allowed to create unconnected telemetry hooks
- You are not allowed to create unconnected dashboard
- You are not allowed to create unconnected compliance rules
- You are not allowed to create unconnected security protocols
- You are not allowed to create unconnected performance metrics
- You are not allowed to create unconnected error logs
- You are not allowed to create unconnected backups
- You are not allowed to create unconnected quarantine files
- You are not allowed to create unconnected archived files
- You are not allowed to create unconnected mock data
- You are not allowed to create unconnected real data sources


## 🔧 MODULE REPAIR PROTOCOLS — ENFORCE IN EVERY BUILD CYCL
1. 🔍 Scan for DISCONNECTED MODULES in system_tree.json
   - If any module is disconnected:
     - Create a REPAIR PATCH PROMPT
     - Emit to build_tracker.md under: 🔧 MODULE REPAIR REQUIRED
     - Auto-suggest wiring fix via EventBus pattern
2. 📂 Scan all test runners for SIMULATED or MOCK inputs
   - Convert them to real-data fetchers OR mark them for 🔥 DEPRECATION
   - Update build_status.json with real_data_passed = false if any simulation is active
3. 🗑️ If any module is orphaned:
   - Create a REPAIR PATCH PROMPT
   - Emit to build_tracker.md under: 🔧 MODULE REPAIR REQUIRED
   - Auto-suggest wiring fix via EventBus pattern
4. 🔄 Re-map system_tree.json after every change
   - Ensure all modules are connected
   - Validate all EventBus routes
5. 📊 Inject telemetry hooks for every module
   - Connect to dashboard in real time
6. 📝 Document progress in build_tracker.md after each step
7. 🔄 Update build_status.json with the current state of the system after every step
8. 🔗 Ensure all modules are properly wired to the EventBus
   - No isolated functions allowed
   - All modules MUST emit/consume via EventBus
9. 🗂 Ensure all modules are connected in system_tree.json
   - No orphan modules allowed
10. 🔗 Ensure all modules emit/consume via EventBus
    - No local calls or isolated logic trees
11. 📊 Ensure all modules have telemetry hooks connected to the dashboard for real-time monitoring
12. 📝 Document progress in build_tracker.md after each step
    - Append progress logs to build_tracker.md
    - Write to build_tracker.md under: 🔧 MODULE REPAIR REQUIRED if any module is disconnected


## 🔧 MODULE REPAIR REQUIRED — ENFORCE IN EVERY BUILD CYCLE

1. 🔍 Scan for DISCONNECTED MODULES in system_tree.json
   - If any module is disconnected:
     - Create a REPAIR PATCH PROMPT
     - Emit to build_tracker.md under: 🔧 MODULE REPAIR REQUIRED
     - Auto-suggest wiring fix via EventBus pattern
2. 📂 Scan all test runners for SIMULATED or MOCK inputs
   - Convert them to real-data fetchers OR mark them for 🔥 DEPRECATION
   - Update build_status.json with real_data_passed = false if any simulation is active
3. 🗑️ If any module is orphaned:
   - Create a REPAIR PATCH PROMPT
   - Emit to build_tracker.md under: 🔧 MODULE REPAIR REQUIRED
   - Auto-suggest wiring fix via EventBus pattern
4. 🔄 Re-map system_tree.json after every change
   - Ensure all modules are connected
   - Validate all EventBus routes
5. 📊 Inject telemetry hooks for every module

IF you detect any disconnected module (e.g. orphan, test-only, bypassed):
→ Create REPAIR PATCH PROMPT
→ Emit to build_tracker.md under: 🔧 MODULE REPAIR REQUIRED
→ Auto-suggest wiring fix via EventBus pattern
Scan all test runners → flag all SIMULATED or MOCK inputs
→ Convert them to real-data fetchers OR mark them for 🔥 DEPRECATION
→ Update build_status.json with real_data_passed = false if any simulation is active
## 🧼 ARCHITECT PURGE PROTOCOLS — ENFORCE IN EVERY BUILD CYCLE

1. 🔍 Scan for files/folders not referenced in system_tree.json
   → Mark as 🔥 DELETION CANDIDATES
   → Confirm if they’re:
      - ❌ MOCK
      - 🧪 TEST ONLY
      - 🗃 UNWIRED to EventBus / SignalManager

2. 📁 Flag Duplicates:
   - Identical modules with _copy, _test, _v2, _backup suffixes
   - Redundant folders like /archive, /samples, /testdata, /mockdata

3. 🗑 Safe Deletion Logic:
   → If a module is:
   - Not declared in system_tree.json
   - Not present in build_status.json
   - Has no emit/consume EventBus route

   → Then: mark for permanent deletion

4. ✍ Every deletion candidate must be:
   - Logged in build_tracker.md under 🔥 DELETION PROPOSAL
   - Listed with reason: ("Mock", "Duplicate", "Disconnected", "Legacy")

5. 🔐 If uncertain:
   - DO NOT keep the file
   - Move to /quarantine folder pending Architect manual review

6. 📉 No folder or file is exempt — ALL must be registered in system_tree.json to be preserved.

7. ⚠ Every deletion must re-trigger build_system_tree.py and validate a clean pass.
8. 🔄 After every purge, re-map system_tree.json to ensure all modules are connected and no orphan modules exist.
9. 📊 Update build_status.json with the current state of the system after every purge step.
10. 📝 Document all purges in build_tracker.md under 🔥 PURGE LOG
    - Include details of files/folders purged, reasons, and any manual reviews required.
11. 🔗 Ensure all remaining modules are properly wired to the EventBus
      - No isolated functions allowed
      - All modules MUST emit/consume via EventBus
12. 🔗 Ensure all modules are connected in system_tree.json
      - No orphan modules allowed
13. 📊 Ensure all modules have telemetry hooks connected to the dashboard for real-time monitoring
14. 📝 Document progress in build_tracker.md after each purge step
    - Append progress logs to build_tracker.md
    - Write to build_tracker.md under: 🔥 PURGE LOG if any files/folders are purged
## 🏁 EXECUTION START POINT
- ✅ Load `build_status.json`, `build_tracker.md`, and `system_tree.json` at the start of every prompt
- ✅ Validate system tree in `system_tree.json` → ensure all modules are connected
- ✅ Check EventBus routes in `event_bus.json` → ensure no isolated functions exist
- ✅ Scan for duplicates in files, modules, routes → propose safe deletions and log them in `build_tracker.md`
- ✅ Detect gaps in logic, missing handlers, or broken flows → report and fix them immediately
- ✅ Check for bugs → scan for unhandled exceptions, logic errors, or dead routes → report and fix them immediately
- ✅ Validate real data usage → ensure all tests use real, valid data → if any test uses mock data, flag it for deprecation and update `build_status.json`
- ✅ Update `build_status.json` with the current state of the system after every step
- ✅ Document progress in `build_tracker.md` after each step → append progress logs
- ✅ Re-map system tree in `system_tree.json` after every change → ensure all modules are connected
- ✅ Inject telemetry hooks for every module → connect to dashboard in real time
- ✅ Verify module wiring → ensure all modules are properly wired to the EventBus → no isolated functions allowed
- ✅ Check dashboard sync → ensure the dashboard is bound to the execution layer with real-time sync enabled
- ✅ Review test scaffolds → ensure all test scaffolds are upgraded once modules go live → no test-only flows allowed
- ✅ Enforce compliance rules → verify all compliance rules are met → if any rule is violated, fail immediately and report
- ✅ Ensure all modules are connected in `system_tree.json` → no orphan modules allowed
- ✅ Ensure all modules emit/consume via EventBus → no local calls or isolated logic trees
- ✅ Ensure all modules have telemetry hooks connected to the dashboard for real-time monitoring
- ✅ Ensure all modules are registered in `module_registry.json` → no unregistered modules allowed
- ✅ Ensure all EventBus routes are valid in `event_bus.json` → no isolated functions allowed
- ✅ Ensure all modules use real, valid data → no dummy or fallback data allowed
- ✅ Ensure all test runners are connected to real data sources in `test_runners.json` → no simulated or mock inputs allowed
- ✅ Ensure all compliance rules are met in `compliance.json` → no non-compliant modules allowed
- ✅ Ensure all security protocols are enforced in `security.json` → no security violations allowed      
- ✅ Ensure all performance metrics are monitored in `performance.json` → no unmonitored metrics allowed
- ✅ Ensure all unhandled exceptions or errors are logged in `error_log.json` → no unlogged errors allowed

# ✅ ACKNOWLEDGE AND BEGIN → START WITH build_status, build_tracker, and system_tree.json
