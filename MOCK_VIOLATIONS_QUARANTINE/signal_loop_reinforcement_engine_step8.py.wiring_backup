# @GENESIS_ORPHAN_STATUS: archived_patch
# @GENESIS_SUGGESTED_ACTION: archive
# @GENESIS_ANALYSIS_DATE: 2025-06-20T16:45:13.482968
# @GENESIS_PROTECTION: DO_NOT_DELETE_UNTIL_REVIEWED

# <!-- @GENESIS_MODULE_START: signal_loop_reinforcement_engine_step8 -->

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GENESIS SignalLoopReinforcementEngine Module v2.7 - STEP 8 ENHANCED
Self-learning signal feedback system that reinforces/penalizes signals
ARCHITECT MODE: v2.7 - STEP 8 REQUIREMENTS IMPLEMENTED

STEP 8 FEATURES:
- Signal ID tracking across sessions  
- Win rate calculation (10, 20, 50 trades)
- Slippage mean/variance analysis
- TP:SL ratio tracking
- Edge decay detection (pattern reuse vs success)
- Exponential decay for >15% performance drop
- Reinforcement boost for high-performing signals

EVENT OUTPUTS:
- SignalFeedbackScore: { "signal_id": "abc123", "score": 0.78, "decay_flag": false }
- DecayDetectedEvent: { "signal_id": "abc123", "reason": "TP hit rate drop > 20%" }
- ReinforcementLearningLog: full JSONL entry per session

NO real DATA - NO ISOLATED FUNCTIONS - STRICT COMPLIANCE
"""

import os
import json
import logging
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from collections import defaultdict, deque
from threading import Lock
from statistics import mean, stdev
from pathlib import Path

from event_bus import get_event_bus, register_route

class SignalLoopReinforcementEngine:
    """
    GENESIS SignalLoopReinforcementEngine - STEP 8 Enhanced Signal Learning System
    
    STEP 8 Architecture Compliance:
    - ✅ Signal ID tracking across sessions
    - ✅ Win rate calculations (10, 20, 50 trades)
    - ✅ Slippage mean/variance analysis
    - ✅ TP:SL ratio tracking
    - ✅ Edge decay detection
    - ✅ EventBus only communication
    - ✅ Real data processing (no real/dummy data)
    - ✅ Telemetry hooks enabled
    """
    
    def __init__(self):
        """Initialize Enhanced SignalLoopReinforcementEngine with STEP 8 capabilities"""
        # Setup logging
        self._setup_logging()
        
        # EventBus connection
        self.event_bus = get_event_bus()
        
        # Create log directories
        self.log_path = Path("logs/reinforcement_engine/")
        self.log_path.mkdir(parents=True, exist_ok=True)
        
        # STEP 8: Enhanced signal tracking by individual signal ID
        self.signal_performance = defaultdict(lambda: {
            "trades": deque(maxlen=100),  # Last 100 trades per signal
            "win_rate_10": 0.0,
            "win_rate_20": 0.0, 
            "win_rate_50": 0.0,
            "slippage_history": deque(maxlen=50),
            "tp_sl_ratios": deque(maxlen=50),
            "edge_decay_score": 1.0,
            "total_trades": 0,
            "creation_time": datetime.utcnow(),
            "last_updated": datetime.utcnow()
        })
        
        # STEP 8: Pattern reuse tracking for edge decay detection
        self.pattern_reuse_tracker = defaultdict(lambda: {
            "usage_count": 0,
            "success_rate_trend": deque(maxlen=10),  # Last 10 sessions
            "performance_degradation": 0.0
        })
        
        # STEP 8: Enhanced configuration with new thresholds
        self.config = {
            "base_learning_rate": 0.05,
            "win_multiplier": 1.2,
            "loss_multiplier": 1.5,
            "feedback_window": 20,
            # STEP 8 NEW PARAMETERS:
            "performance_drop_threshold": 0.15,  # 15% drop triggers decay
            "reinforcement_win_rate_threshold": 0.60,  # ≥60% win rate
            "reinforcement_tp_sl_threshold": 1.7,  # TP:SL > 1.7
            "reinforcement_slippage_threshold": 0.4,  # Slippage < 0.4 pips
            "edge_decay_window": 7,  # Pattern reuse monitoring window
            "min_trades_for_stats": 10  # Minimum trades before calculating stats
        }
        
        # Enhanced metrics tracking
        self.metrics = {
            "signals_processed": 0,
            "trades_analyzed": 0,
            "feedback_scores_emitted": 0,
            "decay_events_emitted": 0,
            "reinforcement_boosts_applied": 0,
            "last_update_time": datetime.utcnow().isoformat(),
            "start_time": datetime.utcnow().isoformat(),
            "unique_signals_tracked": 0,
            "avg_signal_performance": 0.0
        }
        
        # Mutex for thread safety
        self.lock = Lock()
        
        # Register event handlers and routes
        self._register_event_handlers()
        self._register_eventbus_routes()
        
        self.logger.info("✅ SignalLoopReinforcementEngine STEP 8 Enhanced initialized")
        self._emit_telemetry("initialization", "STEP 8 Enhanced module initialized successfully")
    
    
        # GENESIS Phase 91 Telemetry Injection
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", {
                "module": __name__,
                "status": "running",
                "timestamp": datetime.now().isoformat(),
                "phase": "91_telemetry_enforcement"
            })
        def _setup_logging(self):
        """Configure structured logging for the module"""
        log_dir = Path("logs/reinforcement_engine")
        log_dir.mkdir(exist_ok=True, parents=True)
        
        self.logger = logging.getLogger("SignalLoopReinforcementEngine")
        self.logger.setLevel(logging.INFO)
        
        # Create handlers
        timestamp = datetime.now().strftime("%Y-%m-%d")
        log_file = log_dir / f"reinforcement_engine_{timestamp}.jsonl"
        file_handler = logging.FileHandler(log_file)
        
        # Create formatter
        formatter = logging.Formatter('{"timestamp": "%(asctime)s", "level": "%(levelname)s", "message": %(message)s}')
        file_handler.setFormatter(formatter)
        
        self.logger.addHandler(file_handler)
    
    def _register_event_handlers(self):
        """Register event handlers for input events from EventBus"""
        self.event_bus.subscribe("ExecutionLog", self.handle_execution_log, "SignalLoopReinforcementEngine")
        self.event_bus.subscribe("TradeJournalEntry", self.handle_trade_journal_entry, "SignalLoopReinforcementEngine")
        self.event_bus.subscribe("BacktestResults", self.handle_backtest_results, "SignalLoopReinforcementEngine")
        self.event_bus.subscribe("StrategyFeedback", self.handle_strategy_feedback, "SignalLoopReinforcementEngine")
        self.event_bus.subscribe("PatternDetected", self.handle_pattern_detected, "SignalLoopReinforcementEngine")
        
        self.logger.info("✅ STEP 8 event handlers registered")
    
    def _register_eventbus_routes(self):
        """Register all EventBus routes for ARCHITECT MODE compliance tracking"""
        # Register input routes (what this module consumes)
        register_route("ExecutionLog", "ExecutionEngine", "SignalLoopReinforcementEngine")
        register_route("TradeJournalEntry", "TradeJournalEngine", "SignalLoopReinforcementEngine") 
        register_route("BacktestResults", "BacktestEngine", "SignalLoopReinforcementEngine")
        register_route("StrategyFeedback", "StrategyRecommenderEngine", "SignalLoopReinforcementEngine")
        register_route("PatternDetected", "PatternEngine", "SignalLoopReinforcementEngine")
        
        # Register output routes (what this module produces) - STEP 8 ENHANCED
        register_route("SignalFeedbackScore", "SignalLoopReinforcementEngine", "SignalEngine")
        register_route("ReinforcementLearningLog", "SignalLoopReinforcementEngine", "TelemetryCollector")
        register_route("DecayDetectedEvent", "SignalLoopReinforcementEngine", "SignalEngine")
        register_route("SignalLoopTelemetry", "SignalLoopReinforcementEngine", "TelemetryCollector")
        register_route("SignalLoopError", "SignalLoopReinforcementEngine", "TelemetryCollector")
        
        self.logger.info("ARCHITECT MODE: All STEP 8 EventBus routes registered for compliance")

    # STEP 8 CORE METHOD: Individual signal tracking
    def track_signal_performance(self, signal_id, trade_outcome, slippage, tp_sl_ratio):
        """Track performance metrics for individual signal IDs"""
        with self.lock:
            signal_data = self.signal_performance[signal_id]
            
            # Add trade outcome (1 for win, 0 for loss)
            signal_data["trades"].append({
                "outcome": 1 if trade_outcome == "win" else 0,
                "timestamp": datetime.utcnow(),
                "slippage": slippage,
                "tp_sl_ratio": tp_sl_ratio
            })
            
            # Track slippage and TP:SL ratios
            signal_data["slippage_history"].append(slippage)
            signal_data["tp_sl_ratios"].append(tp_sl_ratio)
            signal_data["total_trades"] += 1
            signal_data["last_updated"] = datetime.utcnow()
            
            # Calculate win rates for different windows
            trades = list(signal_data["trades"])
            if len(trades) >= 10:
                signal_data["win_rate_10"] = mean([t["outcome"] for t in trades[-10:]])
            if len(trades) >= 20:
                signal_data["win_rate_20"] = mean([t["outcome"] for t in trades[-20:]])
            if len(trades) >= 50:
                signal_data["win_rate_50"] = mean([t["outcome"] for t in trades[-50:]])
            
            # Check for performance degradation and edge decay
            self._check_edge_decay(signal_id, signal_data)
            
            # Calculate and emit signal score
            self._calculate_and_emit_signal_score(signal_id)
            
            # Update metrics
            self.metrics["unique_signals_tracked"] = len(self.signal_performance)
            self.metrics["signals_processed"] += 1
    
    # STEP 8 CORE METHOD: Edge decay detection
    def _check_edge_decay(self, signal_id, signal_data):
        """Detect edge decay for signals with performance drops > 15%"""
        trades = list(signal_data["trades"])
        
        if len(trades) < self.config["min_trades_for_stats"]:
            return
        
        # Compare recent performance vs historical
        recent_win_rate = mean([t["outcome"] for t in trades[-10:]]) if len(trades) >= 10 else 0
        historical_win_rate = mean([t["outcome"] for t in trades[:-10]]) if len(trades) > 10 else recent_win_rate
        
        performance_drop = historical_win_rate - recent_win_rate
        
        # STEP 8 REQUIREMENT: >15% performance drop triggers decay
        if performance_drop > self.config["performance_drop_threshold"]:
            # Apply exponential decay
            signal_data["edge_decay_score"] *= 0.85  # 15% decay
            
            # Emit DecayDetectedEvent
            self._emit_decay_detected_event(signal_id, f"TP hit rate drop > {performance_drop*100:.1f}%")
            
            self.logger.warning(json.dumps({
                "event": "edge_decay_detected",
                "signal_id": signal_id,
                "performance_drop": performance_drop,
                "new_decay_score": signal_data["edge_decay_score"]
            }))
    
    # STEP 8 OUTPUT: Emit DecayDetectedEvent
    def _emit_decay_detected_event(self, signal_id, reason):
        """Emit DecayDetectedEvent as per STEP 8 format"""
        decay_event = {
            "signal_id": signal_id,
            "reason": reason,
            "timestamp": datetime.utcnow().isoformat(),
            "module": "SignalLoopReinforcementEngine"
        }
        
        self.event_bus.emit("DecayDetectedEvent", decay_event)
        self.metrics["decay_events_emitted"] += 1
        
        self.logger.info(json.dumps({
            "event": "decay_detected_event_emitted",
            "signal_id": signal_id,
            "reason": reason
        }))
    
    # STEP 8 OUTPUT: Calculate and emit SignalFeedbackScore
    def _calculate_and_emit_signal_score(self, signal_id):
        """Calculate signal feedback score and emit as per STEP 8 format"""
        signal_data = self.signal_performance[signal_id]
        
        if signal_data["total_trades"] < self.config["min_trades_for_stats"]:
            return
        
        # Base score from win rate (20 trades window preferred)
        base_score = signal_data["win_rate_20"] if signal_data["total_trades"] >= 20 else signal_data["win_rate_10"]
        
        # Apply edge decay
        score = base_score * signal_data["edge_decay_score"]
        
        # STEP 8 REQUIREMENT: Boost for high-performing signals
        slippage_history = list(signal_data["slippage_history"])
        tp_sl_history = list(signal_data["tp_sl_ratios"])
        
        # Check reinforcement criteria
        reinforcement_boost = 1.0
        if (signal_data["win_rate_20"] >= self.config["reinforcement_win_rate_threshold"] and
            len(tp_sl_history) > 0 and mean(tp_sl_history) > self.config["reinforcement_tp_sl_threshold"] and
            len(slippage_history) > 0 and mean(slippage_history) < self.config["reinforcement_slippage_threshold"]):
            
            reinforcement_boost = 1.25  # 25% boost for high performers
            self.metrics["reinforcement_boosts_applied"] += 1
            self.logger.info(json.dumps({
                "event": "reinforcement_boost_applied",
                "signal_id": signal_id,
                "boost_factor": reinforcement_boost
            }))
        
        final_score = min(score * reinforcement_boost, 1.0)  # Cap at 1.0
        
        # STEP 8 FORMAT: SignalFeedbackScore
        feedback_score = {
            "signal_id": signal_id,
            "score": round(final_score, 3),
            "decay_flag": signal_data["edge_decay_score"] < 0.9,
            "timestamp": datetime.utcnow().isoformat(),
            "win_rate_20": round(signal_data["win_rate_20"], 3),
            "avg_slippage": round(mean(slippage_history), 3) if slippage_history else 0.0,
            "avg_tp_sl": round(mean(tp_sl_history), 3) if tp_sl_history else 0.0
        }
        
        self.event_bus.emit("SignalFeedbackScore", feedback_score)
        self.metrics["feedback_scores_emitted"] += 1
        
        self.logger.info(json.dumps({
            "event": "signal_feedback_score_emitted",
            "signal_id": signal_id,
            "score": final_score,
            "decay_flag": feedback_score["decay_flag"]
        }))
        
        return feedback_score

    # STEP 8 OUTPUT: Emit ReinforcementLearningLog
    def _emit_reinforcement_learning_log(self, session_data=None):
        """Emit full JSONL entry per session as per STEP 8 requirements"""
        learning_log = {
            "timestamp": datetime.utcnow().isoformat(),
            "session_id": f"session_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}",
            "total_signals_tracked": len(self.signal_performance),
            "total_trades_analyzed": self.metrics["trades_analyzed"],
            "session_data": session_data or {},
            "reinforcement_metrics": {
                "decay_events": self.metrics["decay_events_emitted"],
                "reinforcement_boosts": self.metrics["reinforcement_boosts_applied"],
                "feedback_scores_emitted": self.metrics["feedback_scores_emitted"]
            },
            "module": "SignalLoopReinforcementEngine"
        }
        
        self.event_bus.emit("ReinforcementLearningLog", learning_log)
        
        # Also log to file
        date_str = datetime.utcnow().strftime("%Y-%m-%d")
        log_file = self.log_path / f"reinforcement_learning_{date_str}.jsonl"
        
        with open(log_file, "a") as f:
            f.write(json.dumps(learning_log) + "\n")
        
        self.logger.info(json.dumps({
            "event": "reinforcement_learning_log_emitted",
            "session_id": learning_log["session_id"],
            "signals_tracked": learning_log["total_signals_tracked"]
        }))

    # EVENT HANDLERS
    def handle_execution_log(self, event_data):
        """Process execution log events"""
        self.logger.info(json.dumps({"event": "execution_log_received", "data": str(event_data)}))
        
        try:
            # Extract signal information
            signal_id = event_data.get("signal_id")
            trade_outcome = event_data.get("outcome", "unknown")
            slippage = event_data.get("slippage", 0.0)
            tp_sl_ratio = event_data.get("tp_sl_ratio", 0.0)
            
            if signal_id:
                self.track_signal_performance(signal_id, trade_outcome, slippage, tp_sl_ratio)
                self.metrics["trades_analyzed"] += 1
                
        except Exception as e:
            self._emit_error(f"Error processing execution log: {str(e)}", "execution_log_processing")
    
    def handle_trade_journal_entry(self, event_data):
        """Process trade journal entries"""
        self.logger.info(json.dumps({"event": "trade_journal_entry_received", "data": str(event_data)}))
        
        try:
            # Extract relevant data for signal tracking
            signal_id = event_data.get("signal_id")
            outcome = event_data.get("outcome")
            slippage = event_data.get("slippage", 0.0)
            tp_sl_ratio = event_data.get("tp_sl_ratio", 0.0)
            
            if signal_id and outcome:
                self.track_signal_performance(signal_id, outcome, slippage, tp_sl_ratio)
                self.metrics["trades_analyzed"] += 1
                
        except Exception as e:
            self._emit_error(f"Error processing trade journal entry: {str(e)}", "trade_journal_processing")
    
    def handle_backtest_results(self, event_data):
        """Process backtest results for historical learning"""
        self.logger.info(json.dumps({"event": "backtest_results_received", "data": str(event_data)}))
        
        try:
            # Process historical signals from backtest
            trades = event_data.get("trades", [])
            
            for trade in trades:
                signal_id = trade.get("signal_id")
                outcome = trade.get("outcome")
                slippage = trade.get("slippage", 0.0)
                tp_sl_ratio = trade.get("tp_sl_ratio", 0.0)
                
                if signal_id and outcome:
                    self.track_signal_performance(signal_id, outcome, slippage, tp_sl_ratio)
            
            # Emit learning log for this backtest session
            self._emit_reinforcement_learning_log({"backtest_trades": len(trades)})
            
        except Exception as e:
            self._emit_error(f"Error processing backtest results: {str(e)}", "backtest_processing")
    
    def handle_strategy_feedback(self, event_data):
        """Process strategy feedback events"""
        self.logger.info(json.dumps({"event": "strategy_feedback_received", "data": str(event_data)}))
        
        try:
            # Track pattern reuse for edge decay detection
            pattern_id = event_data.get("pattern_id")
            success_rate = event_data.get("success_rate", 0.0)
            
            if pattern_id:
                pattern_tracker = self.pattern_reuse_tracker[pattern_id]
                pattern_tracker["usage_count"] += 1
                pattern_tracker["success_rate_trend"].append(success_rate)
                
                # Check for pattern degradation
                if len(pattern_tracker["success_rate_trend"]) >= 5:
                    recent_performance = mean(list(pattern_tracker["success_rate_trend"])[-3:])
                    historical_performance = mean(list(pattern_tracker["success_rate_trend"])[:-3])
                    
                    degradation = historical_performance - recent_performance
                    pattern_tracker["performance_degradation"] = degradation
                    
                    if degradation > 0.20:  # 20% degradation
                        self._emit_decay_detected_event(pattern_id, f"Pattern reuse degradation > {degradation*100:.1f}%")
                
        except Exception as e:
            self._emit_error(f"Error processing strategy feedback: {str(e)}", "strategy_feedback_processing")
    
    def handle_pattern_detected(self, event_data):
        """Process pattern detection events"""
        self.logger.info(json.dumps({"event": "pattern_detected_received", "data": str(event_data)}))
        
        try:
            # Track pattern usage
            pattern_id = event_data.get("pattern_id")
            confidence = event_data.get("confidence", 0.0)
            
            if pattern_id:
                self.pattern_reuse_tracker[pattern_id]["usage_count"] += 1
                
        except Exception as e:
            self._emit_error(f"Error processing pattern detected: {str(e)}", "pattern_detection_processing")
    
    def _emit_telemetry(self, action, message=None):
        """Emit telemetry data via EventBus"""
        telemetry_data = {
            "module": "SignalLoopReinforcementEngine",
            "timestamp": datetime.utcnow().isoformat(),
            "action": action,
            "metrics": self.metrics
        }
        
        if message:
            telemetry_data["message"] = message
        
        self.event_bus.emit("SignalLoopTelemetry", telemetry_data)
        self.logger.info(json.dumps({"event": "telemetry_emitted", "action": action}))
    
    def _emit_error(self, error_message, error_type="general"):
        """Emit error via EventBus"""
        error_data = {
            "module": "SignalLoopReinforcementEngine",
            "timestamp": datetime.utcnow().isoformat(),
            "error_type": error_type,
            "message": error_message
        }
        
        self.event_bus.emit("SignalLoopError", error_data)
        self.logger.error(json.dumps({"event": "error_emitted", "type": error_type, "message": error_message}))

# Initialize if run directly
if __name__ == "__main__":
    try:
        logger = logging.getLogger(__name__)
        logger.info("Initializing SignalLoopReinforcementEngine...")
        
        engine = SignalLoopReinforcementEngine()
        
        # Initial telemetry
        engine._emit_telemetry("startup", "SignalLoopReinforcementEngine STEP 8 service started")
        
        # Emit initial learning log
        engine._emit_reinforcement_learning_log({"startup": True})
        
        logger.info("SignalLoopReinforcementEngine STEP 8 running and listening for events...")
        
        # Keep process running
        import time
        while True:
            time.sleep(1)
            
    except Exception as e:
        print(f"❌ Startup failed: {e}")
        import sys
        sys.exit(1)

    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        

# <!-- @GENESIS_MODULE_END: signal_loop_reinforcement_engine_step8 -->