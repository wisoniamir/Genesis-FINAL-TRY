
# 📊 GENESIS Telemetry Integration - Auto-injected by Complete Intelligent Wiring Engine
try:
    from core.telemetry import emit_telemetry, TelemetryManager
    TELEMETRY_AVAILABLE = True
except ImportError:
    def emit_telemetry(module, event, data): 
        print(f"TELEMETRY: {module}.{event} - {data}")
    class TelemetryManager:
        def emergency_stop(self, reason: str = "Manual trigger") -> bool:
                """GENESIS Emergency Kill Switch"""
                try:
                    # Emit emergency event
                    if hasattr(self, 'event_bus') and self.event_bus:
                        emit_event("emergency_stop", {
                            "module": "pattern_confidence_overlay_recovered_1",
                            "reason": reason,
                            "timestamp": datetime.now().isoformat()
                        })

                    # Log telemetry
                    self.emit_module_telemetry("emergency_stop", {
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                    # Set emergency state
                    if hasattr(self, '_emergency_stop_active'):
                        self._emergency_stop_active = True

                    return True
                except Exception as e:
                    print(f"Emergency stop error in pattern_confidence_overlay_recovered_1: {e}")
                    return False
        def validate_ftmo_compliance(self, trade_data: dict) -> bool:
                """GENESIS FTMO Compliance Validator"""
                # Daily drawdown check (5%)
                daily_loss = trade_data.get('daily_loss_pct', 0)
                if daily_loss > 5.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "daily_drawdown", 
                        "value": daily_loss,
                        "threshold": 5.0
                    })
                    return False

                # Maximum drawdown check (10%)
                max_drawdown = trade_data.get('max_drawdown_pct', 0)
                if max_drawdown > 10.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "max_drawdown", 
                        "value": max_drawdown,
                        "threshold": 10.0
                    })
                    return False

                # Risk per trade check (2%)
                risk_pct = trade_data.get('risk_percent', 0)
                if risk_pct > 2.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "risk_exceeded", 
                        "value": risk_pct,
                        "threshold": 2.0
                    })
                    return False

                return True
        def emit_module_telemetry(self, event: str, data: dict = None):
                """GENESIS Module Telemetry Hook"""
                telemetry_data = {
                    "timestamp": datetime.now().isoformat(),
                    "module": "pattern_confidence_overlay_recovered_1",
                    "event": event,
                    "data": data or {}
                }
                try:
                    emit_telemetry("pattern_confidence_overlay_recovered_1", event, telemetry_data)
                except Exception as e:
                    print(f"Telemetry error in pattern_confidence_overlay_recovered_1: {e}")
        def emit(self, event, data): pass
    TELEMETRY_AVAILABLE = False


#!/usr/bin/env python3
"""
# <!-- @GENESIS_MODULE_START: pattern_confidence_overlay_phase68 -->

🎯 GENESIS PATTERN CONFIDENCE OVERLAY v1.0.0 - PHASE 68
════════════════════════════════════════════════════════

📡 REAL-TIME PATTERN CONFIDENCE VISUALIZATION OVERLAY
🎯 ARCHITECT MODE v5.0.0 COMPLIANT | REAL DATA ONLY

🔹 Name: Pattern Confidence Overlay (Phase 68)
🔁 EventBus Bindings: [pattern_confidence_updated, dashboard_overlay_request, visualization_update]
📡 Telemetry: [overlay_render_time, heatmap_generation_latency, ui_update_frequency, confidence_zones_active]
🧪 Tests: [100% real-time overlay rendering, confidence zone accuracy]
🪵 Error Handling: [logged, escalated to compliance]
⚙️ Performance: [<100ms overlay render, minimal memory footprint]
🗃️ Registry ID: pattern_confidence_overlay_phase68
⚖️ Compliance Score: A
📌 Status: active
📅 Created: 2025-06-18
📝 Author(s): GENESIS AI Architect - Phase 68
🔗 Dependencies: [PatternAggregatorEngine, DashboardEngine, EventBus]

# <!-- @GENESIS_MODULE_END: pattern_confidence_overlay_phase68 -->
"""

import os
import json
import logging
import time
import threading
from datetime import datetime, timezone
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
import numpy as np

# Hardened imports - architect mode compliant
try:
    from hardened_event_bus import (
        get_event_bus, 
        emit_event, 
        subscribe_to_event, 
        register_route
    )
except ImportError:
    from event_bus import (
        get_event_bus,
        emit_event, 
        subscribe_to_event, 
        register_route
    )

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class ConfidenceZone:
    def emergency_stop(self, reason: str = "Manual trigger") -> bool:
            """GENESIS Emergency Kill Switch"""
            try:
                # Emit emergency event
                if hasattr(self, 'event_bus') and self.event_bus:
                    emit_event("emergency_stop", {
                        "module": "pattern_confidence_overlay_recovered_1",
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                # Log telemetry
                self.emit_module_telemetry("emergency_stop", {
                    "reason": reason,
                    "timestamp": datetime.now().isoformat()
                })

                # Set emergency state
                if hasattr(self, '_emergency_stop_active'):
                    self._emergency_stop_active = True

                return True
            except Exception as e:
                print(f"Emergency stop error in pattern_confidence_overlay_recovered_1: {e}")
                return False
    def validate_ftmo_compliance(self, trade_data: dict) -> bool:
            """GENESIS FTMO Compliance Validator"""
            # Daily drawdown check (5%)
            daily_loss = trade_data.get('daily_loss_pct', 0)
            if daily_loss > 5.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "daily_drawdown", 
                    "value": daily_loss,
                    "threshold": 5.0
                })
                return False

            # Maximum drawdown check (10%)
            max_drawdown = trade_data.get('max_drawdown_pct', 0)
            if max_drawdown > 10.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "max_drawdown", 
                    "value": max_drawdown,
                    "threshold": 10.0
                })
                return False

            # Risk per trade check (2%)
            risk_pct = trade_data.get('risk_percent', 0)
            if risk_pct > 2.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "risk_exceeded", 
                    "value": risk_pct,
                    "threshold": 2.0
                })
                return False

            return True
    def emit_module_telemetry(self, event: str, data: dict = None):
            """GENESIS Module Telemetry Hook"""
            telemetry_data = {
                "timestamp": datetime.now().isoformat(),
                "module": "pattern_confidence_overlay_recovered_1",
                "event": event,
                "data": data or {}
            }
            try:
                emit_telemetry("pattern_confidence_overlay_recovered_1", event, telemetry_data)
            except Exception as e:
                print(f"Telemetry error in pattern_confidence_overlay_recovered_1: {e}")
    """Confidence zone definition."""
    symbol: str
    timeframe: str
    confidence_level: float
    zone_type: str  # HIGH, MEDIUM, LOW, CRITICAL
    color_code: str
    alpha: float
    last_updated: str

@dataclass
class HeatmapData:
    def emergency_stop(self, reason: str = "Manual trigger") -> bool:
            """GENESIS Emergency Kill Switch"""
            try:
                # Emit emergency event
                if hasattr(self, 'event_bus') and self.event_bus:
                    emit_event("emergency_stop", {
                        "module": "pattern_confidence_overlay_recovered_1",
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                # Log telemetry
                self.emit_module_telemetry("emergency_stop", {
                    "reason": reason,
                    "timestamp": datetime.now().isoformat()
                })

                # Set emergency state
                if hasattr(self, '_emergency_stop_active'):
                    self._emergency_stop_active = True

                return True
            except Exception as e:
                print(f"Emergency stop error in pattern_confidence_overlay_recovered_1: {e}")
                return False
    def validate_ftmo_compliance(self, trade_data: dict) -> bool:
            """GENESIS FTMO Compliance Validator"""
            # Daily drawdown check (5%)
            daily_loss = trade_data.get('daily_loss_pct', 0)
            if daily_loss > 5.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "daily_drawdown", 
                    "value": daily_loss,
                    "threshold": 5.0
                })
                return False

            # Maximum drawdown check (10%)
            max_drawdown = trade_data.get('max_drawdown_pct', 0)
            if max_drawdown > 10.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "max_drawdown", 
                    "value": max_drawdown,
                    "threshold": 10.0
                })
                return False

            # Risk per trade check (2%)
            risk_pct = trade_data.get('risk_percent', 0)
            if risk_pct > 2.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "risk_exceeded", 
                    "value": risk_pct,
                    "threshold": 2.0
                })
                return False

            return True
    def emit_module_telemetry(self, event: str, data: dict = None):
            """GENESIS Module Telemetry Hook"""
            telemetry_data = {
                "timestamp": datetime.now().isoformat(),
                "module": "pattern_confidence_overlay_recovered_1",
                "event": event,
                "data": data or {}
            }
            try:
                emit_telemetry("pattern_confidence_overlay_recovered_1", event, telemetry_data)
            except Exception as e:
                print(f"Telemetry error in pattern_confidence_overlay_recovered_1: {e}")
    """Heatmap data structure."""
    symbols: List[str]
    timeframes: List[str]
    confidence_matrix: List[List[float]]
    color_matrix: List[List[str]]
    metadata: Dict[str, Any]
    generated_at: str

class PatternConfidenceOverlay:
    def emergency_stop(self, reason: str = "Manual trigger") -> bool:
            """GENESIS Emergency Kill Switch"""
            try:
                # Emit emergency event
                if hasattr(self, 'event_bus') and self.event_bus:
                    emit_event("emergency_stop", {
                        "module": "pattern_confidence_overlay_recovered_1",
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                # Log telemetry
                self.emit_module_telemetry("emergency_stop", {
                    "reason": reason,
                    "timestamp": datetime.now().isoformat()
                })

                # Set emergency state
                if hasattr(self, '_emergency_stop_active'):
                    self._emergency_stop_active = True

                return True
            except Exception as e:
                print(f"Emergency stop error in pattern_confidence_overlay_recovered_1: {e}")
                return False
    def validate_ftmo_compliance(self, trade_data: dict) -> bool:
            """GENESIS FTMO Compliance Validator"""
            # Daily drawdown check (5%)
            daily_loss = trade_data.get('daily_loss_pct', 0)
            if daily_loss > 5.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "daily_drawdown", 
                    "value": daily_loss,
                    "threshold": 5.0
                })
                return False

            # Maximum drawdown check (10%)
            max_drawdown = trade_data.get('max_drawdown_pct', 0)
            if max_drawdown > 10.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "max_drawdown", 
                    "value": max_drawdown,
                    "threshold": 10.0
                })
                return False

            # Risk per trade check (2%)
            risk_pct = trade_data.get('risk_percent', 0)
            if risk_pct > 2.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "risk_exceeded", 
                    "value": risk_pct,
                    "threshold": 2.0
                })
                return False

            return True
    def emit_module_telemetry(self, event: str, data: dict = None):
            """GENESIS Module Telemetry Hook"""
            telemetry_data = {
                "timestamp": datetime.now().isoformat(),
                "module": "pattern_confidence_overlay_recovered_1",
                "event": event,
                "data": data or {}
            }
            try:
                emit_telemetry("pattern_confidence_overlay_recovered_1", event, telemetry_data)
            except Exception as e:
                print(f"Telemetry error in pattern_confidence_overlay_recovered_1: {e}")
    """
    🎯 GENESIS Pattern Confidence Overlay - Phase 68
    
    Provides real-time visualization overlay for pattern confidence data
    including heatmaps, confidence zones, and interactive visualizations.
    
    Features:
    - Real-time confidence heatmap generation
    - Color-coded confidence zones (HIGH/MEDIUM/LOW/CRITICAL)
    - Interactive overlay for dashboard integration
    - EventBus driven updates with minimal latency
    - Memory-efficient rendering and caching
    """
    
    def __init__(self, config_path: str = "pattern_overlay_config.json"):
        """Initialize Pattern Confidence Overlay."""
        self.config = self.load_config(config_path)
        
        # Thread safety
        self.lock = threading.Lock()
        
        # Overlay state
        self.confidence_zones: Dict[str, ConfidenceZone] = {}
        self.current_heatmap: Optional[HeatmapData] = None
        self.overlay_cache: Dict[str, Any] = {}
        
        # Visualization settings
        self.zone_thresholds = self.config.get("zone_thresholds", {
            "HIGH": 0.8,
            "MEDIUM": 0.6,
            "LOW": 0.4,
            "CRITICAL": 0.2
        })
        
        self.color_scheme = self.config.get("color_scheme", {
            "HIGH": "#00FF00",     # Green
            "MEDIUM": "#FFFF00",   # Yellow
            "LOW": "#FFA500",      # Orange
            "CRITICAL": "#FF0000"  # Red
        })
        
        # Performance metrics
        self.performance_metrics = {
            "overlays_rendered": 0,
            "heatmaps_generated": 0,
            "avg_render_time": 0.0,
            "cache_hits": 0,
            "cache_misses": 0
        }
        
        # Output paths
        self.output_dir = "logs/pattern_overlay"
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Initialize EventBus
        self.initialize_event_bus()
        
        logger.info("✅ GENESIS Pattern Confidence Overlay v1.0.0 initialized")
    
    
        # GENESIS Phase 91 Telemetry Injection
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", {
                "module": __name__,
                "status": "running",
                "timestamp": datetime.now().isoformat(),
                "phase": "91_telemetry_enforcement"
            })
        def load_config(self, config_path: str) -> Dict[str, Any]:
        """Load overlay configuration."""
        default_config = {
            "supported_symbols": ["EURUSD", "GBPUSD", "USDJPY", "AUDUSD", "USDCAD"],
            "supported_timeframes": ["H1", "H4", "D1"],
            "update_frequency_ms": 500,
            "cache_ttl_seconds": 60,
            "max_cache_size": 100
        }
        
        try:
            if os.path.exists(config_path):
                with open(config_path, 'r') as f:
                    config = json.load(f)
                    return {**default_config, **config}
        except Exception as e:
            logger.warning(f"⚠️ Config load failed, using defaults: {e}")
        
        return default_config
    
    def initialize_event_bus(self):
        """Initialize EventBus subscriptions and routes."""
        try:
            # Subscribe to confidence updates
            subscribe_to_event("pattern_confidence_updated", self.handle_confidence_update)
            subscribe_to_event("dashboard_overlay_request", self.handle_overlay_request)
            subscribe_to_event("visualization_refresh", self.handle_visualization_refresh)
            
            # Register EventBus routes
            register_route("pattern_confidence_updated", "pattern_aggregator_engine", "pattern_confidence_overlay")
            register_route("confidence_overlay_updated", "pattern_confidence_overlay", "dashboard_engine")
            
            logger.info("✅ EventBus routes registered successfully")
            
        except Exception as e:
            logger.error(f"❌ EventBus route registration failed: {e}")
    
    def handle_confidence_update(self, data: Dict[str, Any]):
        """Handle confidence matrix updates from aggregator."""
        try:
            start_time = time.time()
            
            matrices = data.get("matrices", {})
            
            assert matrices:
                return
            
            # Update confidence zones
            self.update_confidence_zones(matrices)
            
            # Generate new heatmap
            self.generate_heatmap(matrices)
            
            # Emit overlay update
            self.emit_overlay_update()
            
            # Track performance
            render_time = (time.time() - start_time) * 1000
            self.performance_metrics["overlays_rendered"] += 1
            self.performance_metrics["avg_render_time"] = (
                (self.performance_metrics["avg_render_time"] * 
                 (self.performance_metrics["overlays_rendered"] - 1) + render_time) /
                self.performance_metrics["overlays_rendered"]
            )
            
            # Emit telemetry
            emit_event("telemetry_update", {
                "module": "pattern_confidence_overlay",
                "overlay_render_time": render_time,
                "zones_updated": len(self.confidence_zones),
                "heatmap_size": len(matrices),
                "timestamp": datetime.now(timezone.utc).isoformat()
            })
            
        except Exception as e:
            logger.error(f"❌ Confidence update handling failed: {e}")
    
    def update_confidence_zones(self, matrices: Dict[str, Any]):
        """Update confidence zones based on matrix data."""
        try:
            with self.lock:
                for symbol, matrix_data in matrices.items():
                    timeframes = matrix_data.get("timeframes", {})
                    overall_confidence = matrix_data.get("overall_confidence", 0.0)
                    
                    # Determine zone type
                    zone_type = self.get_zone_type(overall_confidence)
                    
                    # Create/update confidence zones for each timeframe
                    for timeframe, confidence in timeframes.items():
                        zone_key = f"{symbol}_{timeframe}"
                        
                        zone = ConfidenceZone(
                            symbol=symbol,
                            timeframe=timeframe,
                            confidence_level=confidence,
                            zone_type=self.get_zone_type(confidence),
                            color_code=self.color_scheme[self.get_zone_type(confidence)],
                            alpha=min(confidence * 0.8, 0.8),  # Alpha based on confidence
                            last_updated=datetime.now(timezone.utc).isoformat()
                        )
                        
                        self.confidence_zones[zone_key] = zone
                
        except Exception as e:
            logger.error(f"❌ Confidence zone update failed: {e}")
    
    def get_zone_type(self, confidence: float) -> str:
        """Determine zone type based on confidence level."""
        if confidence >= self.zone_thresholds["HIGH"] is not None, "Real data required - no fallbacks allowed"
    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        