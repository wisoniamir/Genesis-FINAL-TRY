# <!-- @GENESIS_MODULE_START: genesis_institutional_risk_engine -->

"""
üß† GENESIS INSTITUTIONAL RISK ENGINE v7.0.0 - ARCHITECT MODE ULTIMATE ENFORCEMENT
================================================================================

üéØ PURPOSE: Professional-grade risk management with full trading ecosystem synergy
üèõÔ∏è INSTITUTIONAL: FTMO-compliant with advanced risk analytics
üì° EVENTBUS: Complete integration with all trading modules
üîê ARCHITECT MODE v7.0.0: Ultimate compliance with professional standards
üß† INTELLIGENCE: AI-driven risk assessment and adaptive controls
üö® PROTECTION: Multi-layered safety with predictive risk modeling

FTMO COMPLIANCE FRAMEWORK:
- Real-time drawdown monitoring and enforcement
- Dynamic position sizing with risk-adjusted scaling
- Advanced correlation analysis and position limits
- Institutional-grade kill-switch mechanisms
- Professional risk reporting and analytics
- Adaptive risk parameters based on market conditions

RISK MANAGEMENT LAYERS:
1. Account-level risk controls (FTMO compliance)
2. Strategy-level risk allocation and limits
3. Position-level sizing and correlation checks
4. Market-level volatility and liquidity analysis
5. Real-time monitoring and adaptive adjustments
6. Emergency protection and kill-switch activation
"""

import numpy as np
import pandas as pd
import threading
import time
import json
import logging
import asyncio
import statistics
from datetime import datetime, timedelta, timezone
from typing import Dict, List, Any, Optional, Tuple, Union
from collections import defaultdict, deque
from dataclasses import dataclass, field, asdict
from enum import Enum
from decimal import Decimal, ROUND_DOWN
import sys
import os

# Add parent directories to path
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))
from core.hardened_event_bus import get_event_bus, emit_event, register_route


# <!-- @GENESIS_MODULE_END: genesis_institutional_risk_engine_v7 -->

# Configure institutional-grade logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('InstitutionalRiskEngine_v7')


class RiskLevel(Enum):
    """Risk assessment levels"""
    MINIMAL = "minimal"
    LOW = "low"
    MODERATE = "moderate"
    HIGH = "high"
    CRITICAL = "critical"
    EMERGENCY = "emergency"


class FTMOStatus(Enum):
    """FTMO compliance status"""
    COMPLIANT = "compliant"
    WARNING = "warning"
    VIOLATION = "violation"
    SUSPENDED = "suspended"


class PositionAction(Enum):
    """Position management actions"""
    ALLOW = "allow"
    REDUCE = "reduce"
    CLOSE = "close"
    BLOCK = "block"


@dataclass
class RiskMetrics:
    """Comprehensive risk metrics"""
    account_balance: float
    equity: float
    margin_used: float
    margin_free: float
    margin_level: float
    daily_pnl: float
    max_drawdown: float
    current_drawdown: float
    risk_score: float
    ftmo_status: FTMOStatus
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


@dataclass
class PositionRisk:
    """Individual position risk assessment"""
    symbol: str
    position_size: float
    entry_price: float
    current_price: float
    unrealized_pnl: float
    position_value: float
    risk_percent: float
    correlation_risk: float
    liquidity_risk: float
    volatility_risk: float
    overall_risk: RiskLevel


@dataclass
class FTMOCompliance:
    """FTMO compliance tracking"""
    initial_balance: float
    current_balance: float
    equity: float
    daily_loss_limit: float
    max_drawdown_limit: float
    trailing_drawdown_limit: float
    daily_loss_current: float
    max_drawdown_current: float
    trailing_drawdown_current: float
    highest_balance: float
    profit_target: float
    current_profit: float
    trading_days: int
    compliance_status: FTMOStatus
    violations: List[str] = field(default_factory=list)


@dataclass
class RiskAlert:
    """Risk management alert"""
    alert_id: str
    severity: RiskLevel
    alert_type: str
    description: str
    affected_positions: List[str]
    recommended_action: PositionAction
    timestamp: datetime
    auto_action_taken: bool = False


class GenesisInstitutionalRiskEngine:
    """
    ARCHITECT MODE v7.0.0 COMPLIANT Institutional Risk Engine
    Professional risk management with full trading ecosystem integration
    """
    
    VERSION = "7.0.0"
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """Initialize institutional risk engine with professional compliance"""
        self.config = config or self._load_default_config()
        self._emit_startup_telemetry()
        
        # Thread-safe risk management
        self.risk_lock = threading.Lock()
        self.position_lock = threading.Lock()
        self.running = threading.Event()
        self.emergency_stop = threading.Event()
        
        # Professional risk tracking
        self.current_positions: Dict[str, PositionRisk] = {}
        self.risk_history: deque = deque(maxlen=10000)
        self.alert_history: deque = deque(maxlen=1000)
        self.correlation_matrix: Dict[str, Dict[str, float]] = {}
        
        # FTMO compliance
        self.ftmo_compliance = FTMOCompliance(
            initial_balance=self.config.get("initial_balance", 100000.0),
            current_balance=self.config.get("initial_balance", 100000.0),
            equity=self.config.get("initial_balance", 100000.0),
            daily_loss_limit=self.config.get("daily_loss_limit", 0.05),
            max_drawdown_limit=self.config.get("max_drawdown_limit", 0.10),
            trailing_drawdown_limit=self.config.get("trailing_drawdown_limit", 0.05),
            daily_loss_current=0.0,
            max_drawdown_current=0.0,
            trailing_drawdown_current=0.0,
            highest_balance=self.config.get("initial_balance", 100000.0),
            profit_target=self.config.get("profit_target", 0.10),
            current_profit=0.0,
            trading_days=0,
            compliance_status=FTMOStatus.COMPLIANT
        )
        
        # Dynamic risk parameters
        self.dynamic_params = {
            "base_risk_per_trade": 0.01,  # 1% base risk
            "max_risk_per_trade": 0.03,   # 3% maximum risk
            "correlation_limit": 0.70,     # 70% correlation limit
            "volatility_multiplier": 1.5,  # Volatility adjustment
            "liquidity_threshold": 0.80,   # Liquidity requirement
            "emergency_threshold": 0.95    # Emergency stop level
        }
        
        # EventBus integration for v7.0.0 compliance
        self.event_bus = get_event_bus()
        self._register_event_handlers()
        
        # Advanced analytics
        self.predictive_model = self._initialize_risk_model()
        self.scenario_engine = self._initialize_scenario_engine()
        
        # Professional monitoring
        self.monitoring_thread = None
        self.analysis_thread = None
        
        # Performance tracking
        self.performance_metrics = {
            "alerts_generated": 0,
            "violations_prevented": 0,
            "emergency_stops": 0,
            "risk_assessments": 0,
            "position_adjustments": 0,
            "uptime_start": datetime.now(timezone.utc),
            "last_health_check": datetime.now(timezone.utc)
        }
        
        # Machine learning components
        self.risk_prediction_buffer = deque(maxlen=1000)
        self.pattern_recognition = self._initialize_pattern_recognition()
        
        # Start professional monitoring
        self._start_monitoring_systems()
        
        logger.info(f"üèõÔ∏è Genesis Institutional Risk Engine v{self.VERSION} initialized")
        emit_event("risk.engine.initialized", {
            "version": self.VERSION,
            "config": self.config,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })

    def _load_default_config(self) -> Dict[str, Any]:
        """Load professional default configuration"""
        return {
            "initial_balance": 100000.0,
            "daily_loss_limit": 0.05,       # 5% daily loss limit
            "max_drawdown_limit": 0.10,     # 10% maximum drawdown
            "trailing_drawdown_limit": 0.05, # 5% trailing drawdown
            "profit_target": 0.10,          # 10% profit target
            "max_positions": 10,            # Maximum open positions
            "max_risk_per_trade": 0.02,     # 2% risk per trade
            "correlation_threshold": 0.70,   # 70% correlation limit
            "volatility_lookback": 20,      # 20-period volatility
            "risk_assessment_interval": 5,  # 5-second intervals
            "emergency_cooldown": 300,      # 5-minute emergency cooldown
            "enable_predictive_modeling": True,
            "enable_machine_learning": True,
            "enable_real_time_analytics": True
        }

    def _emit_startup_telemetry(self) -> None:
        """Emit comprehensive startup telemetry"""
        emit_event("telemetry.risk_engine", {
            "event": "startup",
            "version": self.VERSION,
            "compliance_mode": "ARCHITECT_v7.0.0",
            "features": [
                "ftmo_compliance",
                "real_time_monitoring", 
                "predictive_modeling",
                "correlation_analysis",
                "emergency_protection"
            ],
            "timestamp": datetime.now(timezone.utc).isoformat()
        })

    def _register_event_handlers(self) -> None:
        """Register comprehensive EventBus handlers for v7.0.0"""
        try:
            # Trading events
            register_route("trade.executed", "trading_engine", "risk_engine")
            register_route("position.opened", "execution_manager", "risk_engine")
            register_route("position.closed", "execution_manager", "risk_engine")
            register_route("order.filled", "mt5_adapter", "risk_engine")
            
            # Market data events
            register_route("market.price_update", "market_data", "risk_engine")
            register_route("market.volatility_update", "analytics", "risk_engine")
            
            # Risk management events
            register_route("risk.assessment_request", "strategy_engine", "risk_engine")
            register_route("risk.emergency_stop", "kill_switch", "risk_engine")
            
            # Subscribe to events
            self.event_bus.subscribe("trade.executed", self._handle_trade_executed)
            self.event_bus.subscribe("position.opened", self._handle_position_opened)
            self.event_bus.subscribe("position.closed", self._handle_position_closed)
            self.event_bus.subscribe("market.price_update", self._handle_price_update)
            self.event_bus.subscribe("risk.assessment_request", self._handle_risk_assessment_request)
            self.event_bus.subscribe("account.balance_update", self._handle_balance_update)
            
            logger.info("‚úÖ Event handlers registered successfully")
            
        except Exception as e:
            logger.error(f"‚ùå Event handler registration failed: {str(e)}")

    def _initialize_risk_model(self) -> Dict[str, Any]:
        """Initialize advanced predictive risk model"""
        return {
            "volatility_model": {
                "lookback_period": 20,
                "decay_factor": 0.94,
                "threshold_multiplier": 2.0
            },
            "correlation_model": {
                "calculation_period": 50,
                "update_frequency": 10,
                "significance_threshold": 0.6
            },
            "liquidity_model": {
                "depth_threshold": 1000000,
                "spread_tolerance": 0.0002,
                "time_weighted": True
            },
            "prediction_horizon": 300,  # 5-minute prediction
            "confidence_threshold": 0.85
        }

    def _initialize_scenario_engine(self) -> Dict[str, Any]:
        """Initialize scenario analysis engine"""
        return {
            "stress_scenarios": [
                {"name": "market_crash", "volatility_multiplier": 3.0, "correlation_spike": 0.9},
                {"name": "flash_crash", "price_drop": 0.05, "liquidity_dry_up": 0.3},
                {"name": "news_event", "volatility_spike": 2.5, "spread_widening": 3.0},
                {"name": "margin_call", "leverage_reduction": 0.5, "forced_liquidation": True}
            ],
            "monte_carlo_runs": 10000,
            "confidence_intervals": [0.95, 0.99],
            "scenario_update_frequency": 60
        }

    def _initialize_pattern_recognition(self) -> Dict[str, Any]:
        """Initialize ML pattern recognition for risk prediction"""
        return {
            "risk_patterns": {
                "drawdown_spiral": {"threshold": 0.03, "confidence": 0.8},
                "correlation_buildup": {"threshold": 0.75, "lookback": 10},
                "volatility_clustering": {"threshold": 2.0, "persistence": 5},
                "liquidity_deterioration": {"threshold": 0.6, "trend_periods": 3}
            },
            "prediction_accuracy": 0.0,
            "model_confidence": 0.0,
            "last_retrain": datetime.now(timezone.utc)
        }

    def _start_monitoring_systems(self) -> None:
        """Start professional monitoring systems"""
        try:
            self.running.set()
            
            # Risk monitoring thread
            self.monitoring_thread = threading.Thread(
                target=self._monitoring_loop, 
                daemon=True, 
                name="RiskMonitoring"
            )
            self.monitoring_thread.start()
            
            # Deep analysis thread
            self.analysis_thread = threading.Thread(
                target=self._analysis_loop, 
                daemon=True, 
                name="RiskAnalysis"
            )
            self.analysis_thread.start()
            
            logger.info("üîç Professional monitoring systems started")
            
        except Exception as e:
            logger.error(f"‚ùå Failed to start monitoring systems: {str(e)}")

    def _monitoring_loop(self) -> None:
        """Continuous real-time risk monitoring"""
        while self.running.is_set() and not self.emergency_stop.is_set():
            try:
                # Calculate current risk metrics
                current_metrics = self._calculate_current_risk_metrics()
                
                # Check FTMO compliance
                self._check_ftmo_compliance()
                
                # Assess position risks
                self._assess_all_positions()
                
                # Check correlation limits
                self._monitor_correlation_risk()
                
                # Generate alerts if needed
                self._generate_risk_alerts(current_metrics)
                
                # Update performance metrics
                self.performance_metrics["last_health_check"] = datetime.now(timezone.utc)
                self.performance_metrics["risk_assessments"] += 1
                
                # Emit monitoring telemetry
                emit_event("telemetry.risk_monitoring", {
                    "metrics": asdict(current_metrics),
                    "timestamp": datetime.now(timezone.utc).isoformat()
                })
                
                time.sleep(self.config.get("risk_assessment_interval", 5))
                
            except Exception as e:
                logger.error(f"‚ùå Risk monitoring error: {str(e)}")
                time.sleep(1)

    def _analysis_loop(self) -> None:
        """Deep risk analysis loop with predictive modeling"""
        while self.running.is_set() and not self.emergency_stop.is_set():
            try:
                # Predictive risk modeling
                if self.config.get("enable_predictive_modeling", True):
                    self._run_predictive_analysis()
                
                # Scenario analysis
                self._run_scenario_analysis()
                
                # Pattern recognition
                if self.config.get("enable_machine_learning", True):
                    self._run_pattern_recognition()
                
                # Correlation matrix updates
                self._update_correlation_matrix()
                
                # Model retraining if needed
                self._check_model_retraining()
                
                time.sleep(60)  # Deep analysis every minute
                
            except Exception as e:
                logger.error(f"‚ùå Risk analysis error: {str(e)}")
                time.sleep(5)

    def _handle_price_update(self, data: Dict[str, Any]) -> None:
        """Handle real-time price updates for risk assessment"""
        try:
            symbol = data.get('symbol', '')
            current_price = data.get('price', 0.0)
            
            if symbol in self.current_positions:
                # Update position risk
                self._update_position_risk(symbol, current_price)
                
                # Check for immediate risk alerts
                position_risk = self.current_positions[symbol]
                if position_risk.overall_risk in [RiskLevel.CRITICAL, RiskLevel.EMERGENCY]:
                    self._generate_immediate_alert(position_risk)
            
        except Exception as e:
            logger.error(f"‚ùå Price update handling error: {str(e)}")

    def _handle_trade_executed(self, data: Dict[str, Any]) -> None:
        """Handle trade execution events for risk tracking"""
        try:
            symbol = data.get('symbol', '')
            size = data.get('size', 0.0)
            price = data.get('price', 0.0)
            side = data.get('side', 'buy')
            
            # Update FTMO compliance
            self._update_ftmo_metrics(data)
            
            # Assess position risk
            position_risk = self._assess_position_risk(symbol, size, price, side)
            
            # Check correlation limits
            correlation_risk = self._check_correlation_limits(symbol, size)
            
            # Generate risk assessment
            risk_assessment = {
                "symbol": symbol,
                "position_risk": position_risk,
                "correlation_risk": correlation_risk,
                "ftmo_status": self.ftmo_compliance.compliance_status.value,
                "recommended_action": self._determine_position_action(position_risk, correlation_risk),
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
            
            emit_event("risk.assessment", risk_assessment)
            
        except Exception as e:
            logger.error(f"‚ùå Trade execution handling error: {str(e)}")

    def _handle_position_opened(self, data: Dict[str, Any]) -> None:
        """Handle position opening events"""
        try:
            symbol = data.get('symbol', '')
            size = data.get('size', 0.0)
            entry_price = data.get('entry_price', 0.0)
            
            # Create position risk object
            position_risk = PositionRisk(
                symbol=symbol,
                position_size=size,
                entry_price=entry_price,
                current_price=entry_price,
                unrealized_pnl=0.0,
                position_value=size * entry_price,
                risk_percent=self._calculate_position_risk_percent(size, entry_price),
                correlation_risk=self._calculate_correlation_risk(symbol),
                liquidity_risk=self._calculate_liquidity_risk(symbol),
                volatility_risk=self._calculate_volatility_risk(symbol),
                overall_risk=RiskLevel.LOW
            )
            
            with self.position_lock:
                self.current_positions[symbol] = position_risk
            
            # Emit position risk event
            emit_event("risk.position_opened", {
                "symbol": symbol,
                "risk_assessment": asdict(position_risk),
                "timestamp": datetime.now(timezone.utc).isoformat()
            })
            
        except Exception as e:
            logger.error(f"‚ùå Position opening handling error: {str(e)}")

    def _handle_position_closed(self, data: Dict[str, Any]) -> None:
        """Handle position closing events"""
        try:
            symbol = data.get('symbol', '')
            realized_pnl = data.get('realized_pnl', 0.0)
            
            # Remove from position tracking
            with self.position_lock:
                if symbol in self.current_positions:
                    del self.current_positions[symbol]
            
            # Update FTMO metrics
            self._update_ftmo_with_realized_pnl(realized_pnl)
            
            # Emit position closed event
            emit_event("risk.position_closed", {
                "symbol": symbol,
                "realized_pnl": realized_pnl,
                "ftmo_status": self.ftmo_compliance.compliance_status.value,
                "timestamp": datetime.now(timezone.utc).isoformat()
            })
            
        except Exception as e:
            logger.error(f"‚ùå Position closing handling error: {str(e)}")

    def _handle_balance_update(self, data: Dict[str, Any]) -> None:
        """Handle account balance updates"""
        try:
            balance = data.get('balance', 0.0)
            equity = data.get('equity', 0.0)
            
            # Update FTMO compliance
            self.ftmo_compliance.current_balance = balance
            self.ftmo_compliance.equity = equity
            
            # Update highest balance if applicable
            if equity > self.ftmo_compliance.highest_balance:
                self.ftmo_compliance.highest_balance = equity
            
            # Recalculate drawdowns
            self._recalculate_drawdowns()
            
            # Check compliance status
            self._check_ftmo_compliance()
            
        except Exception as e:
            logger.error(f"‚ùå Balance update handling error: {str(e)}")

    def _calculate_current_risk_metrics(self) -> RiskMetrics:
        """Calculate comprehensive current risk metrics"""
        try:
            # Calculate aggregate position risk
            total_risk = 0.0
            total_exposure = 0.0
            
            with self.position_lock:
                for position in self.current_positions.values():
                    total_risk += position.risk_percent
                    total_exposure += abs(position.position_value)
            
            # Calculate risk score
            risk_score = self._calculate_composite_risk_score(total_risk, total_exposure)
            
            return RiskMetrics(
                account_balance=self.ftmo_compliance.current_balance,
                equity=self.ftmo_compliance.equity,
                margin_used=0.0,  # To be updated with real data
                margin_free=0.0,  # To be updated with real data
                margin_level=0.0, # To be updated with real data
                daily_pnl=self.ftmo_compliance.daily_loss_current,
                max_drawdown=self.ftmo_compliance.max_drawdown_current,
                current_drawdown=self.ftmo_compliance.trailing_drawdown_current,
                risk_score=risk_score,
                ftmo_status=self.ftmo_compliance.compliance_status
            )
            
        except Exception as e:
            logger.error(f"‚ùå Risk metrics calculation error: {str(e)}")
            return RiskMetrics(
                account_balance=0.0,
                equity=0.0,
                margin_used=0.0,
                margin_free=0.0,
                margin_level=0.0,
                daily_pnl=0.0,
                max_drawdown=0.0,
                current_drawdown=0.0,
                risk_score=100.0,
                ftmo_status=FTMOStatus.VIOLATION
            )

    def _check_ftmo_compliance(self) -> None:
        """Check FTMO compliance with institutional standards"""
        try:
            violations = []
            
            # Daily loss check
            daily_loss_percent = abs(self.ftmo_compliance.daily_loss_current) / self.ftmo_compliance.initial_balance
            if daily_loss_percent > self.ftmo_compliance.daily_loss_limit:
                violations.append("Daily loss limit exceeded")
            
            # Maximum drawdown check
            max_dd_percent = self.ftmo_compliance.max_drawdown_current / self.ftmo_compliance.initial_balance
            if max_dd_percent > self.ftmo_compliance.max_drawdown_limit:
                violations.append("Maximum drawdown limit exceeded")
            
            # Trailing drawdown check
            trailing_dd_percent = self.ftmo_compliance.trailing_drawdown_current / self.ftmo_compliance.highest_balance
            if trailing_dd_percent > self.ftmo_compliance.trailing_drawdown_limit:
                violations.append("Trailing drawdown limit exceeded")
            
            # Update compliance status
            if violations:
                self.ftmo_compliance.compliance_status = FTMOStatus.VIOLATION
                self.ftmo_compliance.violations = violations
                
                # Trigger emergency stop if violations are critical
                self._trigger_emergency_stop("FTMO compliance violation", violations)
                
                # Emit compliance violation
                emit_event("compliance.violation", {
                    "type": "ftmo_violation",
                    "violations": violations,
                    "severity": "critical",
                    "timestamp": datetime.now(timezone.utc).isoformat()
                })
            else:
                # Check for warnings
                warning_threshold = 0.8  # 80% of limit
                
                if (daily_loss_percent > self.ftmo_compliance.daily_loss_limit * warning_threshold or
                    max_dd_percent > self.ftmo_compliance.max_drawdown_limit * warning_threshold or
                    trailing_dd_percent > self.ftmo_compliance.trailing_drawdown_limit * warning_threshold):
                    
                    self.ftmo_compliance.compliance_status = FTMOStatus.WARNING
                else:
                    self.ftmo_compliance.compliance_status = FTMOStatus.COMPLIANT
            
            # Emit FTMO status update
            emit_event("risk.ftmo_status", {
                "status": self.ftmo_compliance.compliance_status.value,
                "daily_loss_percent": daily_loss_percent * 100,
                "max_drawdown_percent": max_dd_percent * 100,
                "trailing_drawdown_percent": trailing_dd_percent * 100,
                "violations": violations,
                "timestamp": datetime.now(timezone.utc).isoformat()
            })
            
        except Exception as e:
            logger.error(f"‚ùå FTMO compliance check error: {str(e)}")

    def _trigger_emergency_stop(self, reason: str, details: List[str]) -> None:
        """Trigger emergency stop with institutional protocols"""
        try:
            logger.critical(f"üö® EMERGENCY STOP TRIGGERED: {reason}")
            
            self.emergency_stop.set()
            self.performance_metrics["emergency_stops"] += 1
            
            # Emit emergency stop event
            emit_event("risk.kill_switch", {
                "reason": reason,
                "details": details,
                "severity": "emergency",
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "auto_triggered": True
            })
            
            # Generate emergency alert
            alert = RiskAlert(
                alert_id=f"EMERGENCY_{int(time.time())}",
                severity=RiskLevel.EMERGENCY,
                alert_type="emergency_stop",
                description=f"Emergency stop: {reason}",
                affected_positions=list(self.current_positions.keys()),
                recommended_action=PositionAction.CLOSE,
                timestamp=datetime.now(timezone.utc),
                auto_action_taken=True
            )
            
            self.alert_history.append(alert)
            
            emit_event("risk.alert", asdict(alert))
            
        except Exception as e:
            logger.error(f"‚ùå Emergency stop error: {str(e)}")

    def calculate_position_size(
        self,
        symbol: str,
        strategy_risk: float,
        entry_price: float,
        stop_loss: float
    ) -> float:
        """Calculate optimal position size with institutional risk management"""
        try:
            # Base risk calculation
            base_risk = self.dynamic_params["base_risk_per_trade"]
            
            # Adjust for current drawdown
            drawdown_adjustment = self._get_drawdown_adjustment()
            adjusted_risk = base_risk * drawdown_adjustment
            
            # Adjust for volatility
            volatility_adjustment = self._get_volatility_adjustment(symbol)
            final_risk = adjusted_risk * volatility_adjustment
            
            # Calculate position size
            risk_amount = self.ftmo_compliance.equity * final_risk
            price_distance = abs(entry_price - stop_loss)
            
            if price_distance <= 0:
                return 0.0
            
            position_size = risk_amount / price_distance
            
            # Apply maximum limits
            max_size = self._get_max_position_size(symbol)
            position_size = min(position_size, max_size)
            
            # Check correlation limits
            correlation_limit = self._check_correlation_position_limit(symbol, position_size)
            position_size = min(position_size, correlation_limit)
            
            logger.info(f"üìä Position size calculated for {symbol}: {position_size}")
            
            return position_size
            
        except Exception as e:
            logger.error(f"‚ùå Position size calculation error: {str(e)}")
            return 0.0

    def stop(self) -> None:
        """Stop institutional risk engine with professional compliance"""
        logger.info("üîª Stopping GenesisInstitutionalRiskEngine...")
        
        self.running.clear()
        self.emergency_stop.set()
        
        # Wait for threads to finish
        for thread in [self.monitoring_thread, self.analysis_thread]:
            if thread and thread.is_alive():
                thread.join(timeout=5.0)
        
        # Emit shutdown telemetry
        emit_event("telemetry.risk_engine", {
            "module": "GenesisInstitutionalRiskEngine",
            "status": "shutdown",
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "final_metrics": self._get_final_metrics()
        })
        
        logger.info("‚úÖ GenesisInstitutionalRiskEngine stopped")

    def _get_final_metrics(self) -> Dict[str, Any]:
        """Get final performance metrics for shutdown"""
        try:
            return {
                "version": self.VERSION,
                "performance_metrics": self.performance_metrics,
                "ftmo_compliance": asdict(self.ftmo_compliance),
                "active_positions": len(self.current_positions),
                "alerts_generated": len(self.alert_history),
                "risk_assessments_total": self.performance_metrics["risk_assessments"]
            }
        except Exception as e:
            logger.error(f"‚ùå Final metrics calculation error: {str(e)}")
            return {"error": str(e)}

    def get_risk_report(self) -> Dict[str, Any]:
        """Get comprehensive risk report"""
        try:
            current_metrics = self._calculate_current_risk_metrics()
            
            return {
                "version": self.VERSION,
                "status": "running" if self.running.is_set() else "stopped",
                "current_metrics": asdict(current_metrics),
                "ftmo_compliance": asdict(self.ftmo_compliance),
                "active_positions": {k: asdict(v) for k, v in self.current_positions.items()},
                "performance_metrics": self.performance_metrics,
                "dynamic_parameters": self.dynamic_params,
                "recent_alerts": [asdict(alert) for alert in list(self.alert_history)[-10:]],
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
        except Exception as e:
            logger.error(f"‚ùå Risk report error: {str(e)}")
            return {"error": str(e)}

    def _handle_risk_assessment_request(self, data: Dict[str, Any]) -> None:
        """Handle risk assessment requests from other modules"""
        try:
            request_type = data.get('type', 'standard')
            symbol = data.get('symbol')
            
            if request_type == 'position_size':
                size = self.calculate_optimal_position_size(
                    symbol=symbol,
                    entry_price=data.get('entry_price', 0.0),
                    stop_loss=data.get('stop_loss', 0.0),
                    account_balance=data.get('balance', self.ftmo_compliance.current_balance)
                )
                
                emit_event("risk.assessment_response", {
                    "request_id": data.get('request_id'),
                    "symbol": symbol,
                    "recommended_size": size,
                    "timestamp": datetime.now(timezone.utc).isoformat()
                })
                
        except Exception as e:
            logger.error(f"‚ùå Risk assessment request error: {str(e)}")

    def _assess_all_positions(self) -> None:
        """Assess risk for all current positions"""
        try:
            with self.position_lock:
                for symbol, position in self.current_positions.items():
                    # Update position risk metrics
                    updated_risk = self._calculate_position_risk_level(position)
                    position.overall_risk = updated_risk
                    
                    # Check for critical positions
                    if updated_risk in [RiskLevel.CRITICAL, RiskLevel.EMERGENCY]:
                        self._handle_critical_position(symbol, position)
                        
        except Exception as e:
            logger.error(f"‚ùå Position assessment error: {str(e)}")

    def _monitor_correlation_risk(self) -> None:
        """Monitor correlation risk across all positions"""
        try:
            if len(self.current_positions) < 2:
                return
                
            # Calculate portfolio correlation risk
            correlation_risk = 0.0
            position_pairs = []
            
            symbols = list(self.current_positions.keys())
            for i in range(len(symbols)):
                for j in range(i + 1, len(symbols)):
                    symbol1, symbol2 = symbols[i], symbols[j]
                    correlation = self._get_symbol_correlation(symbol1, symbol2)
                    
                    if correlation > self.config.get('correlation_threshold', 0.70):
                        correlation_risk += correlation
                        position_pairs.append((symbol1, symbol2, correlation))
            
            # Generate alerts for high correlation
            if correlation_risk > 1.5:  # Combined correlation threshold
                emit_event("risk.correlation_alert", {
                    "correlation_risk": correlation_risk,
                    "position_pairs": position_pairs,
                    "timestamp": datetime.now(timezone.utc).isoformat()
                })
                
        except Exception as e:
            logger.error(f"‚ùå Correlation monitoring error: {str(e)}")

    def _generate_risk_alerts(self, metrics: RiskMetrics) -> None:
        """Generate risk alerts based on current metrics"""
        try:
            alerts = []
            
            # Drawdown alerts
            if metrics.current_drawdown > self.ftmo_compliance.max_drawdown_limit * 0.8:
                alerts.append(self._create_alert(
                    "high_drawdown",
                    RiskLevel.CRITICAL,
                    f"Drawdown at {metrics.current_drawdown:.2%}",
                    PositionAction.REDUCE
                ))
            
            # Daily loss alerts
            if abs(metrics.daily_pnl) > self.ftmo_compliance.daily_loss_limit * 0.8:
                alerts.append(self._create_alert(
                    "daily_loss_warning",
                    RiskLevel.HIGH,
                    f"Daily loss at {abs(metrics.daily_pnl):.2%}",
                    PositionAction.REDUCE
                ))
            
            # Risk score alerts
            if metrics.risk_score > 0.85:
                alerts.append(self._create_alert(
                    "high_risk_score",
                    RiskLevel.CRITICAL,
                    f"Risk score at {metrics.risk_score:.2f}",
                    PositionAction.REDUCE
                ))
            
            # Process alerts
            for alert in alerts:
                self._process_alert(alert)
                
        except Exception as e:
            logger.error(f"‚ùå Alert generation error: {str(e)}")

    def _run_predictive_analysis(self) -> None:
        """Run predictive risk analysis using machine learning"""
        try:
            if len(self.risk_prediction_buffer) < 10:
                return
                
            # Prepare data for prediction
            risk_data = list(self.risk_prediction_buffer)
            
            # Simple volatility prediction (would use ML model in production)
            volatility_trend = self._calculate_volatility_trend(risk_data)
            correlation_trend = self._calculate_correlation_trend(risk_data)
            
            # Predict risk for next period
            predicted_risk = self._predict_next_period_risk(
                volatility_trend, correlation_trend
            )
            
            # Emit prediction
            emit_event("risk.prediction", {
                "predicted_risk": predicted_risk,
                "volatility_trend": volatility_trend,
                "correlation_trend": correlation_trend,
                "confidence": self.pattern_recognition.get("model_confidence", 0.0),
                "timestamp": datetime.now(timezone.utc).isoformat()
            })
            
        except Exception as e:
            logger.error(f"‚ùå Predictive analysis error: {str(e)}")

    def _run_scenario_analysis(self) -> None:
        """Run scenario analysis for stress testing"""
        try:
            scenarios = self.scenario_engine.get("stress_scenarios", [])
            
            for scenario in scenarios:
                scenario_name = scenario.get("name", "unknown")
                
                # Run scenario simulation
                scenario_result = self._simulate_scenario(scenario)
                
                # Check if scenario triggers alerts
                if scenario_result.get("max_loss", 0) > self.ftmo_compliance.daily_loss_limit:
                    logger.warning(f"üé≠ Scenario '{scenario_name}' triggers risk limits")
                    
                    emit_event("risk.scenario_alert", {
                        "scenario": scenario_name,
                        "max_loss": scenario_result.get("max_loss", 0),
                        "probability": scenario_result.get("probability", 0),
                        "timestamp": datetime.now(timezone.utc).isoformat()
                    })
            
        except Exception as e:
            logger.error(f"‚ùå Scenario analysis error: {str(e)}")

    def _run_pattern_recognition(self) -> None:
        """Run pattern recognition for risk prediction"""
        try:
            if len(self.risk_history) < 20:
                return
                
            # Simple pattern recognition (would use ML in production)
            recent_data = list(self.risk_history)[-20:]
            
            # Check for drawdown spiral pattern
            drawdown_increases = 0
            for i in range(1, len(recent_data)):
                if recent_data[i].get('current_drawdown', 0) > recent_data[i-1].get('current_drawdown', 0):
                    drawdown_increases += 1
            
            if drawdown_increases > 15:  # 75% of observations show increasing drawdown
                logger.warning("üîç Pattern detected: Drawdown spiral risk")
                
                emit_event("risk.pattern_detected", {
                    "pattern": "drawdown_spiral",
                    "confidence": drawdown_increases / 20.0,
                    "recommendation": "reduce_exposure",
                    "timestamp": datetime.now(timezone.utc).isoformat()
                })
            
        except Exception as e:
            logger.error(f"‚ùå Pattern recognition error: {str(e)}")

    # Missing Helper Methods Implementation
    
    def _calculate_volatility_trend(self, risk_data: List) -> float:
        """Calculate volatility trend from historical risk data"""
        try:
            if len(risk_data) < 5:
                return 0.0
                
            # Extract volatility values from risk data
            volatilities = [data.get('volatility', 0.0) for data in risk_data[-5:]]
            
            # Simple trend calculation (positive = increasing volatility)
            if len(volatilities) >= 2:
                return (volatilities[-1] - volatilities[0]) / len(volatilities)
            
            return 0.0
        except Exception:
            return 0.0

    def _calculate_correlation_trend(self, risk_data: List) -> float:
        """Calculate correlation trend from historical risk data"""
        try:
            if len(risk_data) < 5:
                return 0.0
                
            # Extract correlation values from risk data
            correlations = [data.get('correlation', 0.0) for data in risk_data[-5:]]
            
            # Simple trend calculation
            if len(correlations) >= 2:
                return (correlations[-1] - correlations[0]) / len(correlations)
            
            return 0.0
        except Exception:
            return 0.0

    def _predict_next_period_risk(self, volatility_trend: float, correlation_trend: float) -> float:
        """Predict risk for next period using trends"""
        try:
            # Simple prediction model (would use ML in production)
            base_risk = 0.5
            
            # Adjust based on volatility trend
            volatility_factor = min(abs(volatility_trend) * 2.0, 0.3)
            
            # Adjust based on correlation trend
            correlation_factor = min(abs(correlation_trend) * 1.5, 0.2)
            
            predicted_risk = base_risk + volatility_factor + correlation_factor
            
            return max(0.0, min(1.0, predicted_risk))
        except Exception:
            return 0.5

    def _assess_position_risk(self, symbol: str, size: float, price: float, side: str) -> float:
        """Assess individual position risk"""
        try:
            # Base risk calculation
            base_risk = 0.1
            
            # Size factor
            size_factor = min(size / 10.0, 0.3)  # Assume 10 lots = high size
            
            # Symbol risk factor
            symbol_risks = {
                'EURUSD': 0.1, 'GBPUSD': 0.15, 'USDJPY': 0.12,
                'USDCHF': 0.11, 'AUDUSD': 0.13, 'USDCAD': 0.12
            }
            symbol_risk = symbol_risks.get(symbol, 0.2)
            
            total_risk = base_risk + size_factor + symbol_risk
            
            return max(0.0, min(1.0, total_risk))
        except Exception:
            return 0.5

    def _check_correlation_limits(self, symbol: str, size: float) -> float:
        """Check correlation limits for new position"""
        try:
            if len(self.current_positions) == 0:
                return 0.0
                
            max_correlation = 0.0
            
            for existing_symbol in self.current_positions.keys():
                correlation = self._get_symbol_correlation(symbol, existing_symbol)
                if correlation > max_correlation:
                    max_correlation = correlation
                    
            return max_correlation
        except Exception:
            return 0.0

    def _get_symbol_correlation(self, symbol1: str, symbol2: str) -> float:
        """Get correlation between two symbols"""
        try:
            if symbol1 == symbol2:
                return 1.0
                
            # Simplified correlation matrix (would use real data in production)
            correlations = {
                ('EURUSD', 'GBPUSD'): 0.75,
                ('EURUSD', 'USDCHF'): -0.65,
                ('GBPUSD', 'USDCHF'): -0.60,
                ('AUDUSD', 'NZDUSD'): 0.80,
                ('USDCAD', 'USDJPY'): 0.45
            }
            
            # Check both directions
            correlation = correlations.get((symbol1, symbol2))
            if correlation is None:
                correlation = correlations.get((symbol2, symbol1), 0.0)
                
            return abs(correlation)
        except Exception:
            return 0.0

    def _determine_position_action(self, position_risk: float, correlation_risk: float) -> str:
        """Determine recommended action for position"""
        try:
            if position_risk > 0.8 or correlation_risk > 0.9:
                return "CLOSE_POSITION"
            elif position_risk > 0.6 or correlation_risk > 0.7:
                return "REDUCE_SIZE"
            elif position_risk > 0.4 or correlation_risk > 0.5:
                return "MONITOR_CLOSELY"
            else:
                return "MAINTAIN"
        except Exception:
            return "MONITOR_CLOSELY"

    def _update_ftmo_with_realized_pnl(self, realized_pnl: float) -> None:
        """Update FTMO metrics with realized P&L"""
        try:
            with self.risk_lock:
                # Update daily P&L
                if self.ftmo_compliance.last_reset_date != datetime.now(timezone.utc).date():
                    # Reset daily metrics
                    self.ftmo_compliance.daily_loss_current = 0.0
                    self.ftmo_compliance.last_reset_date = datetime.now(timezone.utc).date()
                
                # Update current balance
                self.ftmo_compliance.current_balance += realized_pnl
                
                # Update daily loss if negative
                if realized_pnl < 0:
                    self.ftmo_compliance.daily_loss_current += abs(realized_pnl)
                
                # Update highest balance if gained
                if self.ftmo_compliance.current_balance > self.ftmo_compliance.highest_balance:
                    self.ftmo_compliance.highest_balance = self.ftmo_compliance.current_balance
                
                # Update drawdowns
                self._update_drawdown_metrics()
                
        except Exception as e:
            logger.error(f"‚ùå FTMO P&L update error: {str(e)}")

    def _update_drawdown_metrics(self) -> None:
        """Update drawdown metrics"""
        try:
            # Calculate current drawdown from peak
            peak_balance = max(self.ftmo_compliance.highest_balance, self.ftmo_compliance.initial_balance)
            current_drawdown = peak_balance - self.ftmo_compliance.current_balance
            
            # Update maximum drawdown
            if current_drawdown > self.ftmo_compliance.max_drawdown_current:
                self.ftmo_compliance.max_drawdown_current = current_drawdown
            
            # Update trailing drawdown
            trailing_drawdown = self.ftmo_compliance.highest_balance - self.ftmo_compliance.current_balance
            if trailing_drawdown > self.ftmo_compliance.trailing_drawdown_current:
                self.ftmo_compliance.trailing_drawdown_current = trailing_drawdown
                
        except Exception as e:
            logger.error(f"‚ùå Drawdown metrics update error: {str(e)}")

    def _update_ftmo_metrics(self, trade_data: Dict[str, Any]) -> None:
        """Update FTMO metrics with trade data"""
        try:
            realized_pnl = trade_data.get('realized_pnl', 0.0)
            if realized_pnl != 0.0:
                self._update_ftmo_with_realized_pnl(realized_pnl)
                
        except Exception as e:
            logger.error(f"‚ùå FTMO metrics update error: {str(e)}")

    def _calculate_position_risk_level(self, position: PositionRisk) -> RiskLevel:
        """Calculate risk level for a position"""
        try:
            # Calculate multiple risk factors
            size_risk = min(position.position_size / 10.0, 1.0)  # Normalize to 10 lots max
            
            # P&L risk factor
            pnl_risk = 0.0
            if hasattr(position, 'unrealized_pnl') and position.unrealized_pnl < 0:
                pnl_risk = min(abs(position.unrealized_pnl) / position.position_value, 1.0)
            
            # Combined risk score
            combined_risk = (size_risk * 0.4) + (pnl_risk * 0.6)
            
            # Determine risk level
            if combined_risk > 0.8:
                return RiskLevel.EMERGENCY
            elif combined_risk > 0.6:
                return RiskLevel.CRITICAL
            elif combined_risk > 0.4:
                return RiskLevel.HIGH
            elif combined_risk > 0.2:
                return RiskLevel.MEDIUM
            else:
                return RiskLevel.LOW
                
        except Exception as e:
            logger.error(f"‚ùå Position risk level calculation error: {str(e)}")
            return RiskLevel.MEDIUM

    def _handle_critical_position(self, symbol: str, position: PositionRisk) -> None:
        """Handle critical risk positions"""
        try:
            logger.warning(f"üö® Critical position detected: {symbol}")
            
            # Create emergency alert
            alert = RiskAlert(
                alert_id=f"CRITICAL_{symbol}_{int(time.time())}",
                severity=RiskLevel.CRITICAL,
                alert_type="critical_position",
                symbol=symbol,
                message=f"Critical risk detected for {symbol}",
                timestamp=datetime.now(timezone.utc).isoformat(),
                recommended_action=PositionAction.REDUCE,
                data={"position": position.symbol if hasattr(position, 'symbol') else symbol}
            )
            
            self._process_alert(alert)
            
            # Emit critical position event
            emit_event("risk.critical_position", {
                "symbol": symbol,
                "risk_level": position.overall_risk.value if hasattr(position, 'overall_risk') else 'high',
                "recommended_action": "reduce_or_close",
                "timestamp": datetime.now(timezone.utc).isoformat()
            })
            
        except Exception as e:
            logger.error(f"‚ùå Critical position handling error: {str(e)}")

    def _create_alert(self, alert_type: str, severity: RiskLevel, message: str, action: PositionAction) -> RiskAlert:
        """Create a risk alert"""
        return RiskAlert(
            alert_id=f"{alert_type}_{int(time.time())}",
            severity=severity,
            alert_type=alert_type,
            symbol="PORTFOLIO",
            message=message,
            timestamp=datetime.now(timezone.utc).isoformat(),
            recommended_action=action,
            data={}
        )

    def _process_alert(self, alert: RiskAlert) -> None:
        """Process a risk alert"""
        try:
            # Add to alert history
            self.alert_history.append(alert)
            
            # Log the alert
            severity_emoji = {
                RiskLevel.LOW: "üü¢",
                RiskLevel.MEDIUM: "üü°", 
                RiskLevel.HIGH: "üü†",
                RiskLevel.CRITICAL: "üî¥",
                RiskLevel.EMERGENCY: "üö®"
            }
            
            emoji = severity_emoji.get(alert.severity, "‚ö†Ô∏è")
            logger.warning(f"{emoji} RISK ALERT: {alert.message}")
            
            # Emit alert event
            emit_event("risk.alert", {
                "alert_id": alert.alert_id,
                "severity": alert.severity.value,
                "type": alert.alert_type,
                "symbol": alert.symbol,
                "message": alert.message,
                "recommended_action": alert.recommended_action.value,
                "timestamp": alert.timestamp,
                "data": alert.data
            })
            
        except Exception as e:
            logger.error(f"‚ùå Alert processing error: {str(e)}")

    def _run_scenario_analysis(self) -> None:
        """Run scenario analysis for stress testing"""
        try:
            scenarios = self.scenario_engine.get("stress_scenarios", [])
            
            for scenario in scenarios:
                scenario_name = scenario.get("name", "unknown")
                
                # Run scenario simulation
                scenario_result = self._simulate_scenario(scenario)
                
                # Check if scenario triggers alerts
                if scenario_result.get("max_loss", 0) > self.ftmo_compliance.daily_loss_limit:
                    logger.warning(f"üé≠ Scenario '{scenario_name}' triggers risk limits")
                    
                    emit_event("risk.scenario_alert", {
                        "scenario": scenario_name,
                        "max_loss": scenario_result.get("max_loss", 0),
                        "probability": scenario_result.get("probability", 0),
                        "timestamp": datetime.now(timezone.utc).isoformat()
                    })
            
        except Exception as e:
            logger.error(f"‚ùå Scenario analysis error: {str(e)}")

    def _simulate_scenario(self, scenario: Dict[str, Any]) -> Dict[str, Any]:
        """Simulate a risk scenario"""
        try:
            scenario_name = scenario.get("name", "unknown")
            
            # Simple scenario simulation (would be more complex in production)
            if scenario_name == "market_crash":
                max_loss = sum(pos.position_value * 0.05 for pos in self.current_positions.values())
                probability = 0.02  # 2% chance
            elif scenario_name == "flash_crash":
                max_loss = sum(pos.position_value * 0.03 for pos in self.current_positions.values())
                probability = 0.01  # 1% chance
            else:
                max_loss = sum(pos.position_value * 0.02 for pos in self.current_positions.values())
                probability = 0.05  # 5% chance
            
            return {
                "max_loss": max_loss,
                "probability": probability,
                "scenario": scenario_name
            }
            
        except Exception:
            return {"max_loss": 0.0, "probability": 0.0, "scenario": "error"}

    def _run_pattern_recognition(self) -> None:
        """Run pattern recognition for risk prediction"""
        try:
            if len(self.risk_history) < 20:
                return
                
            # Simple pattern recognition (would use ML in production)
            recent_data = list(self.risk_history)[-20:]
            
            # Check for drawdown spiral pattern
            drawdown_increases = 0
            for i in range(1, len(recent_data)):
                if recent_data[i].get('current_drawdown', 0) > recent_data[i-1].get('current_drawdown', 0):
                    drawdown_increases += 1
            
            if drawdown_increases > 15:  # 75% of observations show increasing drawdown
                logger.warning("üîç Pattern detected: Drawdown spiral risk")
                
                emit_event("risk.pattern_detected", {
                    "pattern": "drawdown_spiral",
                    "confidence": drawdown_increases / 20.0,
                    "recommendation": "reduce_exposure",
                    "timestamp": datetime.now(timezone.utc).isoformat()
                })
            
        except Exception as e:
            logger.error(f"‚ùå Pattern recognition error: {str(e)}")


def integrate_trading_feedback(model, historical_performance: Dict) -> None:
    """Incorporate real trading feedback into the model"""
    try:
        # Get real trading logs
        real_trades = get_trading_history()
        
        # Extract features and outcomes
        features = []
        outcomes = []
        
        for trade in real_trades:
            # Extract relevant features from the trade
            trade_features = extract_features_from_trade(trade)
            trade_outcome = 1 if trade['profit'] > 0 else 0
            
            features.append(trade_features)
            outcomes.append(trade_outcome)
        
        if len(features) > 10:  # Only update if we have sufficient data
            # Incremental model update
            model.partial_fit(features, outcomes)
            
            # Log update to telemetry
            telemetry.log_event(TelemetryEvent(
                category="ml_optimization", 
                name="model_update", 
                properties={"samples": len(features), "positive_ratio": sum(outcomes)/len(outcomes)}
            ))
            
            # Emit event
            emit_event("model_updated", {
                "model_name": model.__class__.__name__,
                "samples_processed": len(features),
                "timestamp": datetime.now().isoformat()
            })
            
    except Exception as e:
        logging.error(f"Error integrating trading feedback: {str(e)}")
        telemetry.log_event(TelemetryEvent(
            category="error", 
            name="feedback_integration_failed", 
            properties={"error": str(e)}
        ))


def detect_divergence(price_data: list, indicator_data: list, window: int = 10) -> Dict:
    """
    Detect regular and hidden divergences between price and indicator
    
    Args:
        price_data: List of price values (closing prices)
        indicator_data: List of indicator values (e.g., RSI, MACD)
        window: Number of periods to check for divergence
        
    Returns:
        Dictionary with divergence information
    """
    result = {
        "regular_bullish": False,
        "regular_bearish": False,
        "hidden_bullish": False,
        "hidden_bearish": False,
        "strength": 0.0
    }
    
    # Need at least window + 1 periods of data
    if len(price_data) < window + 1 or len(indicator_data) < window + 1:
        return result
        
    # Get the current and historical points
    current_price = price_data[-1]
    previous_price = min(price_data[-window:-1]) if price_data[-1] > price_data[-2] else max(price_data[-window:-1])
    previous_price_idx = price_data[-window:-1].index(previous_price) + len(price_data) - window
    
    current_indicator = indicator_data[-1]
    previous_indicator = indicator_data[previous_price_idx]
    
    # Check for regular divergences
    # Bullish - Lower price lows but higher indicator lows
    if current_price < previous_price and current_indicator > previous_indicator:
        result["regular_bullish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
        
    # Bearish - Higher price highs but lower indicator highs
    elif current_price > previous_price and current_indicator < previous_indicator:
        result["regular_bearish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
    
    # Check for hidden divergences
    # Bullish - Higher price lows but lower indicator lows
    elif current_price > previous_price and current_indicator < previous_indicator:
        result["hidden_bullish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
        
    # Bearish - Lower price highs but higher indicator highs
    elif current_price < previous_price and current_indicator > previous_indicator:
        result["hidden_bearish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
    
    # Emit divergence event if detected
    if any([result["regular_bullish"], result["regular_bearish"], 
            result["hidden_bullish"], result["hidden_bearish"]]):
        emit_event("divergence_detected", {
            "type": next(k for k, v in result.items() if v is True and k != "strength"),
            "strength": result["strength"],
            "symbol": price_data.symbol if hasattr(price_data, "symbol") else "unknown",
            "timestamp": datetime.now().isoformat()
        })
        
    return result


def monitor_drawdown(max_drawdown_percent: float = 5.0, daily_limit_percent: float = 5.0) -> Dict:
    """
    Monitor account drawdown against FTMO limits
    
    Args:
        max_drawdown_percent: Maximum allowed drawdown percentage
        daily_limit_percent: Maximum allowed daily loss percentage
        
    Returns:
        Dictionary with drawdown status information
    """
    try:
        # Get account info
        account_info = mt5.account_info()
        if account_info is None:
            logging.error("Failed to get account info")
            return {"status": "error", "message": "Failed to get account info"}
        
        # Calculate current drawdown
        balance = account_info.balance
        equity = account_info.equity
        
        current_drawdown = (balance - equity) / balance * 100 if balance > 0 else 0
        
        # Get daily high balance
        from_date = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        positions = mt5.history_deals_get(from_date, datetime.now())
        
        daily_starting_balance = balance - sum([deal.profit for deal in positions])
        daily_loss_percent = (daily_starting_balance - equity) / daily_starting_balance * 100 if daily_starting_balance > 0 else 0
        
        # Prepare result
        result = {
            "status": "ok",
            "current_drawdown_percent": current_drawdown,
            "max_drawdown_percent": max_drawdown_percent,
            "drawdown_level": current_drawdown / max_drawdown_percent,  # 0.0 to 1.0+
            "daily_loss_percent": daily_loss_percent,
            "daily_limit_percent": daily_limit_percent,
            "daily_loss_level": daily_loss_percent / daily_limit_percent,  # 0.0 to 1.0+
            "warnings": []
        }
        
        # Check drawdown thresholds
        if current_drawdown > max_drawdown_percent * 0.7:
            result["warnings"].append(f"Drawdown at {current_drawdown:.2f}% approaching maximum of {max_drawdown_percent:.2f}%")
            result["status"] = "warning"
            
        if current_drawdown > max_drawdown_percent:
            result["warnings"].append(f"CRITICAL: Drawdown of {current_drawdown:.2f}% exceeds maximum of {max_drawdown_percent:.2f}%")
            result["status"] = "critical"
            
        # Check daily loss thresholds
        if daily_loss_percent > daily_limit_percent * 0.7:
            result["warnings"].append(f"Daily loss at {daily_loss_percent:.2f}% approaching limit of {daily_limit_percent:.2f}%")
            result["status"] = "warning"
            
        if daily_loss_percent > daily_limit_percent:
            result["warnings"].append(f"CRITICAL: Daily loss of {daily_loss_percent:.2f}% exceeds limit of {daily_limit_percent:.2f}%")
            result["status"] = "critical"
        
        # Emit events for warnings
        if result["status"] in ["warning", "critical"]:
            emit_event("risk_threshold_warning", {
                "status": result["status"],
                "warnings": result["warnings"],
                "timestamp": datetime.now().isoformat()
            })
            
        return result
        
    except Exception as e:
        logging.error(f"Error monitoring drawdown: {str(e)}")
        return {"status": "error", "message": str(e)}
