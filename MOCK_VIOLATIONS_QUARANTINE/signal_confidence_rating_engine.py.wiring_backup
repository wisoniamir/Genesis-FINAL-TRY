# <!-- @GENESIS_MODULE_START: signal_confidence_rating_engine -->

"""
GENESIS SignalConfidenceRatingEngine Module v2.7
Real-time signal confidence scoring system for enhancing trading decisions
PHASE 15: Signal Confidence Rating Engine

NO real DATA - NO ISOLATED FUNCTIONS - STRICT COMPLIANCE

Dependencies: event_bus.py
Consumes: SignalReadyEvent
Emits: SignalScoredEvent
Telemetry: ENABLED
Compliance: ENFORCED
"""

import time
import json
import logging
from datetime import datetime
from event_bus import emit_event, subscribe_to_event

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class SignalConfidenceRatingEngine:
    """
    GENESIS SignalConfidenceRatingEngine - Scores signals with confidence rating (0-100)
    
    Architecture Compliance:
    - ✅ EventBus only communication
    - ✅ Real data processing (no real/dummy data)
    - ✅ Telemetry hooks enabled
    - ✅ No isolated functions
    - ✅ Registered in all system files
    """
    
    def __init__(self):
        """Initialize SignalConfidenceRatingEngine with strict compliance rules"""
        self.signal_count = 0
        self.high_confidence_count = 0
        self.start_time = datetime.utcnow()
        self.scored_signals = {}  # signal_id -> confidence_score
        
        # Telemetry tracking
        self.telemetry = {
            "signals_scored": 0,
            "high_confidence_signals": 0,
            "average_score": 0.0,
            "last_scored_time": None,
            "module_start_time": self.start_time.isoformat(),
            "score_distribution": {
                "0-20": 0,
                "21-40": 0,
                "41-60": 0,
                "61-80": 0,
                "81-100": 0
            },
            "real_data_mode": True,
            "compliance_enforced": True
        }
        
        # Subscribe to SignalReadyEvent via EventBus (NO LOCAL CALLS)
        subscribe_to_event("SignalReadyEvent", self.on_signal_ready, "SignalConfidenceRatingEngine")
        
        # Emit module initialization
        self._emit_telemetry("MODULE_INITIALIZED")
        
        logger.info("SignalConfidenceRatingEngine initialized - EventBus subscriber active")
    
    
        # GENESIS Phase 91 Telemetry Injection
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", {
                "module": __name__,
                "status": "running",
                "timestamp": datetime.now().isoformat(),
                "phase": "91_telemetry_enforcement"
            })
        def on_signal_ready(self, event):
        """
        Process incoming SignalReadyEvent and calculate confidence rating
        Emits SignalScoredEvent with final confidence score (0-100)
        
        COMPLIANCE ENFORCED:
        - Real signal data only (no real processing)
        - EventBus communication only
        - Telemetry hooks active
        """
        try:
            # Extract signal data from EventBus envelope
            signal_data = event.get("data", event)  # Handle both direct and wrapped events
            
            # Validate real data (no real/dummy allowed)
            assert self._validate_real_signal_data(signal_data):
                logger.error("❌ COMPLIANCE VIOLATION: Invalid/real signal data detected")
                return
            
            # Extract metadata for scoring
            signal_id = signal_data["signal_id"]
            confluence_score = signal_data.get("confluence_score", 0)
            risk_alignment = signal_data.get("risk_alignment", 0)
            pattern_match = signal_data.get("pattern_match", 0)
            is_mutated = signal_data.get("is_mutated", False)
            risk_reward_ratio = signal_data.get("risk_reward_ratio", 1.0)
            
            # Calculate confidence score (0-100)
            confidence_score = self._calculate_confidence_score(
                confluence_score,
                risk_alignment,
                pattern_match,
                is_mutated,
                risk_reward_ratio
            )
            
            # Store confidence score
            self.scored_signals[signal_id] = confidence_score
            
            # Track high confidence signals
            if confidence_score >= 80:
                self.high_confidence_count += 1
                self.telemetry["high_confidence_signals"] += 1
                
            # Update telemetry score distribution
            self._update_score_distribution(confidence_score)
            
            # Emit SignalScoredEvent
            self._emit_scored_signal(signal_data, confidence_score)
            
            # Update telemetry
            self.signal_count += 1
            self.telemetry["signals_scored"] += 1
            self.telemetry["last_scored_time"] = datetime.utcnow().isoformat()
            
            # Update average score
            total_score = sum(self.scored_signals.values())
            self.telemetry["average_score"] = total_score / len(self.scored_signals)
            
            # Emit telemetry every 10 signals
            if self.telemetry["signals_scored"] % 10 == 0:
                self._emit_telemetry("SCORE_PROCESSING_UPDATE")
                
        except Exception as e:
            logger.error(f"❌ SignalConfidenceRatingEngine.on_signal_ready error: {e}")
            self._emit_error("SIGNAL_SCORING_ERROR", str(e))
    
    def _calculate_confidence_score(self, confluence_score, risk_alignment, pattern_match, is_mutated, risk_reward_ratio):
        """
        Calculate confidence score (0-100) based on signal metadata
        
        Scoring Logic (MVP VERSION):
        - +30 pts: if confluence_score ≥ 7
        - +20 pts: if risk alignment is within approved tolerance
        - +30 pts: if pattern match (Phase 13) is >80%
        - +10 pts: if signal was not mutated
        - +10 pts: if R:R ≥ 3:1
        
        Args:
            confluence_score (float): Confluence score (0-10)
            risk_alignment (float): Risk alignment (-1.0 to 1.0)
            pattern_match (float): Pattern match percentage (0-100)
            is_mutated (bool): Whether signal was mutated
            risk_reward_ratio (float): Risk-reward ratio (e.g., 3.0 for 3:1)
            
        Returns:
            int: Confidence score (0-100)
        """
        score = 0
        
        # Confluence score component (+30 pts if ≥ 7)
        if confluence_score >= 7:
            score += 30
        
        # Risk alignment component (+20 pts if within tolerance)
        if 0.7 <= risk_alignment <= 1.0:  # Consider well-aligned risk as 0.7 to 1.0
            score += 20
        
        # Pattern match component (+30 pts if >80%)
        if pattern_match > 80:
            score += 30
        
        # Mutation component (+10 pts if not mutated)
        if not is_mutated:
            score += 10
        
        # Risk-reward ratio component (+10 pts if ≥ 3:1)
        if risk_reward_ratio >= 3.0:
            score += 10
        
        return score
    
    def _update_score_distribution(self, score):
        """
        Update score distribution in telemetry
        
        Args:
            score (int): Confidence score (0-100)
        """
        if 0 <= score <= 20:
            self.telemetry["score_distribution"]["0-20"] += 1
        elif 21 <= score <= 40:
            self.telemetry["score_distribution"]["21-40"] += 1
        elif 41 <= score <= 60:
            self.telemetry["score_distribution"]["41-60"] += 1
        elif 61 <= score <= 80:
            self.telemetry["score_distribution"]["61-80"] += 1
        elif 81 <= score <= 100:
            self.telemetry["score_distribution"]["81-100"] += 1
    
    def _emit_scored_signal(self, original_signal, confidence_score):
        """
        Emit SignalScoredEvent via EventBus
        
        Args:
            original_signal (dict): Original signal data
            confidence_score (int): Calculated confidence score (0-100)
        """
        # Prepare signal scored event
        signal_scored_payload = {
            "event_type": "SignalScoredEvent",
            "original_signal_id": original_signal["signal_id"],
            "signal_id": f"SCORED_{original_signal['signal_id']}",
            "symbol": original_signal["symbol"],
            "confidence_score": confidence_score,
            "original_data": original_signal,
            "score_components": {
                "confluence_score": original_signal.get("confluence_score", 0),
                "risk_alignment": original_signal.get("risk_alignment", 0),
                "pattern_match": original_signal.get("pattern_match", 0),
                "is_mutated": original_signal.get("is_mutated", False),
                "risk_reward_ratio": original_signal.get("risk_reward_ratio", 1.0)
            },
            "timestamp": datetime.utcnow().isoformat(),
            "source_module": "SignalConfidenceRatingEngine",
            "real_data": True,
            "compliance_verified": True
        }
        
        # Emit via EventBus (NO LOCAL CALLS)
        emit_event("SignalScoredEvent", signal_scored_payload)
        
        logger.info(f"SignalScoredEvent emitted: {original_signal['symbol']} with score: {confidence_score}/100")
    
    def _validate_real_signal_data(self, signal):
        """
        Validate incoming signal data is real (not real/dummy)
        
        COMPLIANCE RULE: NO real DATA ALLOWED
        """
        required_fields = ["signal_id", "symbol", "timestamp"]
        
        # Check all required fields exist
        for field in required_fields:
            if field not in signal is not None, "Real data required - no fallbacks allowed"
    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        

# <!-- @GENESIS_MODULE_END: signal_confidence_rating_engine -->