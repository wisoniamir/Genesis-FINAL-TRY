# <!-- @GENESIS_MODULE_START: pattern_signal_harmonizer -->

from datetime import datetime\n"""

# ðŸ“Š GENESIS Telemetry Integration - Auto-injected by Complete Intelligent Wiring Engine
try:
    from core.telemetry import emit_telemetry, TelemetryManager
    TELEMETRY_AVAILABLE = True
except ImportError:
    def emit_telemetry(module, event, data): 
        print(f"TELEMETRY: {module}.{event} - {data}")
    class TelemetryManager:
        def emergency_stop(self, reason: str = "Manual trigger") -> bool:
                """GENESIS Emergency Kill Switch"""
                try:
                    # Emit emergency event
                    if hasattr(self, 'event_bus') and self.event_bus:
                        emit_event("emergency_stop", {
                            "module": "pattern_signal_harmonizer_recovered_1",
                            "reason": reason,
                            "timestamp": datetime.now().isoformat()
                        })

                    # Log telemetry
                    self.emit_module_telemetry("emergency_stop", {
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                    # Set emergency state
                    if hasattr(self, '_emergency_stop_active'):
                        self._emergency_stop_active = True

                    return True
                except Exception as e:
                    print(f"Emergency stop error in pattern_signal_harmonizer_recovered_1: {e}")
                    return False
        def emit_module_telemetry(self, event: str, data: dict = None):
                """GENESIS Module Telemetry Hook"""
                telemetry_data = {
                    "timestamp": datetime.now().isoformat(),
                    "module": "pattern_signal_harmonizer_recovered_1",
                    "event": event,
                    "data": data or {}
                }
                try:
                    emit_telemetry("pattern_signal_harmonizer_recovered_1", event, telemetry_data)
                except Exception as e:
                    print(f"Telemetry error in pattern_signal_harmonizer_recovered_1: {e}")
        def emit(self, event, data): pass
    TELEMETRY_AVAILABLE = False



# ðŸ”— GENESIS EventBus Integration - Auto-injected by Complete Intelligent Wiring Engine
try:
    from core.hardened_event_bus import get_event_bus, emit_event, register_route
    EVENTBUS_AVAILABLE = True
except ImportError:
    # Fallback implementation
    def get_event_bus(): return None
    def emit_event(event, data): print(f"EVENT: {event} - {data}")
    def register_route(route, producer, consumer): pass
    EVENTBUS_AVAILABLE = False


GENESIS Pattern Signal Harmonizer v1.0 - ARCHITECT MODE v2.7
Smart Pattern â†’ Signal Harmonization with Adaptive Feedback Loop

PURPOSE:
- Harmonize patterns from PatternEngine with signals from DSR/SignalEngine
- Mine historical execution performance for pattern confidence adjustment
- Implement adaptive feedback loop linking execution results to pattern quality
- Provide enhanced signal quality through pattern-signal fusion

ARCHITECTURE COMPLIANCE:
- âœ… Event-driven via EventBus only (no direct calls)
- âœ… Real MT5 data + historical telemetry (no real data)
- âœ… Full telemetry integration with structured logging
- âœ… FTMO compliance through SSXLE integration
- âœ… Kill-switch integration via EventBus
- âœ… Performance tracking and adaptive learning

DEPENDENCIES: hardened_event_bus, json, datetime, os, logging, time, threading, statistics, collections
CONSUMES: PatternDetected, ExecutionHistory, ExecutionResult, PerformanceMetricsRequest
EMITS: SignalHarmonized, PatternScoreUpdate, HarmonicFeedback, ModuleTelemetry, ModuleError
"""

import json
import datetime
import os
import logging
import time
import threading
import statistics
from collections import defaultdict, deque
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
from hardened_event_bus import HardenedEventBus

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

@dataclass
class PatternSignalHarmonic:
    def emergency_stop(self, reason: str = "Manual trigger") -> bool:
            """GENESIS Emergency Kill Switch"""
            try:
                # Emit emergency event
                if hasattr(self, 'event_bus') and self.event_bus:
                    emit_event("emergency_stop", {
                        "module": "pattern_signal_harmonizer_recovered_1",
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                # Log telemetry
                self.emit_module_telemetry("emergency_stop", {
                    "reason": reason,
                    "timestamp": datetime.now().isoformat()
                })

                # Set emergency state
                if hasattr(self, '_emergency_stop_active'):
                    self._emergency_stop_active = True

                return True
            except Exception as e:
                print(f"Emergency stop error in pattern_signal_harmonizer_recovered_1: {e}")
                return False
    def emit_module_telemetry(self, event: str, data: dict = None):
            """GENESIS Module Telemetry Hook"""
            telemetry_data = {
                "timestamp": datetime.now().isoformat(),
                "module": "pattern_signal_harmonizer_recovered_1",
                "event": event,
                "data": data or {}
            }
            try:
                emit_telemetry("pattern_signal_harmonizer_recovered_1", event, telemetry_data)
            except Exception as e:
                print(f"Telemetry error in pattern_signal_harmonizer_recovered_1: {e}")
    def initialize_eventbus(self):
            """GENESIS EventBus Initialization"""
            try:
                self.event_bus = get_event_bus()
                if self.event_bus:
                    emit_event("module_initialized", {
                        "module": "pattern_signal_harmonizer_recovered_1",
                        "timestamp": datetime.now().isoformat(),
                        "status": "active"
                    })
            except Exception as e:
                print(f"EventBus initialization error in pattern_signal_harmonizer_recovered_1: {e}")
    """Represents a harmonized pattern-signal combination"""
    harmonic_id: str
    pattern_id: str
    signal_id: str
    pattern_confidence: float
    signal_confidence: float
    harmonic_score: float
    historical_success_rate: float
    adaptive_weight: float
    execution_context: Dict[str, Any]
    harmony_timestamp: str
    telemetry_payload: Dict[str, Any]

@dataclass
class HarmonizeConstraints:
    def emergency_stop(self, reason: str = "Manual trigger") -> bool:
            """GENESIS Emergency Kill Switch"""
            try:
                # Emit emergency event
                if hasattr(self, 'event_bus') and self.event_bus:
                    emit_event("emergency_stop", {
                        "module": "pattern_signal_harmonizer_recovered_1",
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                # Log telemetry
                self.emit_module_telemetry("emergency_stop", {
                    "reason": reason,
                    "timestamp": datetime.now().isoformat()
                })

                # Set emergency state
                if hasattr(self, '_emergency_stop_active'):
                    self._emergency_stop_active = True

                return True
            except Exception as e:
                print(f"Emergency stop error in pattern_signal_harmonizer_recovered_1: {e}")
                return False
    def emit_module_telemetry(self, event: str, data: dict = None):
            """GENESIS Module Telemetry Hook"""
            telemetry_data = {
                "timestamp": datetime.now().isoformat(),
                "module": "pattern_signal_harmonizer_recovered_1",
                "event": event,
                "data": data or {}
            }
            try:
                emit_telemetry("pattern_signal_harmonizer_recovered_1", event, telemetry_data)
            except Exception as e:
                print(f"Telemetry error in pattern_signal_harmonizer_recovered_1: {e}")
    def initialize_eventbus(self):
            """GENESIS EventBus Initialization"""
            try:
                self.event_bus = get_event_bus()
                if self.event_bus:
                    emit_event("module_initialized", {
                        "module": "pattern_signal_harmonizer_recovered_1",
                        "timestamp": datetime.now().isoformat(),
                        "status": "active"
                    })
            except Exception as e:
                print(f"EventBus initialization error in pattern_signal_harmonizer_recovered_1: {e}")
    """Pattern-Signal harmonization constraints"""
    min_pattern_confidence: float
    min_signal_confidence: float
    min_harmonic_score: float
    min_historical_success_rate: float
    max_pattern_age_minutes: int
    max_signal_age_minutes: int
    adaptive_learning_rate: float
    pattern_weight: float
    signal_weight: float

class PatternSignalHarmonizer:
    def emergency_stop(self, reason: str = "Manual trigger") -> bool:
            """GENESIS Emergency Kill Switch"""
            try:
                # Emit emergency event
                if hasattr(self, 'event_bus') and self.event_bus:
                    emit_event("emergency_stop", {
                        "module": "pattern_signal_harmonizer_recovered_1",
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                # Log telemetry
                self.emit_module_telemetry("emergency_stop", {
                    "reason": reason,
                    "timestamp": datetime.now().isoformat()
                })

                # Set emergency state
                if hasattr(self, '_emergency_stop_active'):
                    self._emergency_stop_active = True

                return True
            except Exception as e:
                print(f"Emergency stop error in pattern_signal_harmonizer_recovered_1: {e}")
                return False
    def emit_module_telemetry(self, event: str, data: dict = None):
            """GENESIS Module Telemetry Hook"""
            telemetry_data = {
                "timestamp": datetime.now().isoformat(),
                "module": "pattern_signal_harmonizer_recovered_1",
                "event": event,
                "data": data or {}
            }
            try:
                emit_telemetry("pattern_signal_harmonizer_recovered_1", event, telemetry_data)
            except Exception as e:
                print(f"Telemetry error in pattern_signal_harmonizer_recovered_1: {e}")
    def initialize_eventbus(self):
            """GENESIS EventBus Initialization"""
            try:
                self.event_bus = get_event_bus()
                if self.event_bus:
                    emit_event("module_initialized", {
                        "module": "pattern_signal_harmonizer_recovered_1",
                        "timestamp": datetime.now().isoformat(),
                        "status": "active"
                    })
            except Exception as e:
                print(f"EventBus initialization error in pattern_signal_harmonizer_recovered_1: {e}")
    """
    GENESIS Pattern Signal Harmonizer v1.0
    
    Harmonizes live patterns with signals, applies historical performance weighting,
    and implements adaptive feedback loop for continuous pattern quality improvement.
    
    ARCHITECT MODE v2.7 COMPLIANT:
    - Event-driven processing via EventBus only
    - Real MT5 data + historical telemetry integration
    - Full telemetry hooks and structured logging
    - Performance tracking with adaptive learning
    - Thread-safe operation with proper locking
    """
    
    def __init__(self, config_path: str = "harmonizer_config.json"):
        """Initialize Pattern Signal Harmonizer with configuration"""
        
        self.logger = logging.getLogger("PatternSignalHarmonizer")
        self.logger.info("Initializing Pattern Signal Harmonizer - ARCHITECT MODE v2.7")
        
        # Initialize EventBus
        self.event_bus = HardenedEventBus()
        
        # Thread safety
        self.lock = threading.Lock()
        
        # Load configuration
        self.config = self._load_config(config_path)
        self.constraints = HarmonizeConstraints(**self.config.get('constraints', {}))
        
        # Pattern and signal buffers
        self.pattern_buffer = deque(maxlen=self.config.get('pattern_buffer_size', 100))
        self.signal_buffer = deque(maxlen=self.config.get('signal_buffer_size', 100))
        self.harmony_queue = deque(maxlen=self.config.get('harmony_queue_size', 50))
        
        # Historical performance database
        self.historical_patterns = defaultdict(list)
        self.pattern_success_rates = defaultdict(float)
        self.adaptive_weights = defaultdict(lambda: 1.0)
        
        # Performance tracking
        self.performance_tracker = {
            'harmonics_created': 0,
            'harmonics_dispatched': 0,
            'patterns_processed': 0,
            'signals_processed': 0,
            'historical_matches': 0,
            'adaptive_adjustments': 0,
            'avg_harmonic_score': 0.0,
            'avg_historical_success_rate': 0.0,
            'total_harmonization_latency_ms': 0.0,
            'avg_harmonization_latency_ms': 0.0
        }
        
        # Execution history for adaptive learning
        self.execution_history = deque(maxlen=1000)
        
        # Setup EventBus subscriptions
        self._setup_event_subscriptions()
        
        # Emit startup telemetry
        self._emit_startup_telemetry()
        
        self.logger.info("Pattern Signal Harmonizer initialized successfully - ARCHITECT MODE v2.7")

    
        # GENESIS Phase 91 Telemetry Injection
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", {
                "module": __name__,
                "status": "running",
                "timestamp": datetime.now().isoformat(),
                "phase": "91_telemetry_enforcement"
            })
        def _load_config(self, config_path: str) -> Dict[str, Any]:
        """Load configuration from file or use defaults"""
        try:
            if os.path.exists(config_path):
                with open(config_path, 'r') as f:
                    config = json.load(f)
                    self.logger.info(f"Harmonizer config loaded from {config_path}")
                    return config
            else:
                # Default configuration
                default_config = {
                    "harmonizer_settings": {
                        "name": "GENESIS Pattern Signal Harmonizer",
                        "version": "1.0.0",
                        "phase": 26,
                        "architect_mode_compliant": True,
                        "real_data_only": True
                    },
                    "constraints": {
                        "min_pattern_confidence": 0.70,
                        "min_signal_confidence": 0.75,
                        "min_harmonic_score": 0.80,
                        "min_historical_success_rate": 0.60,
                        "max_pattern_age_minutes": 10,
                        "max_signal_age_minutes": 5,
                        "adaptive_learning_rate": 0.1,
                        "pattern_weight": 0.4,
                        "signal_weight": 0.6
                    },
                    "performance_targets": {
                        "max_harmonization_latency_ms": 300,
                        "target_harmonization_latency_ms": 150,
                        "min_harmony_queue_efficiency": 0.85,
                        "max_historical_lookup_time_ms": 100
                    },
                    "pattern_buffer_size": 100,
                    "signal_buffer_size": 100,
                    "harmony_queue_size": 50,
                    "historical_pattern_limit": 500,
                    "telemetry_buffer_size": 1000
                }
                
                # Save default config
                with open(config_path, 'w') as f:
                    json.dump(default_config, f, indent=2)
                    
                self.logger.info(f"Default harmonizer config created at {config_path}")
                return default_config
                
        except Exception as e:
            self.logger.error(f"Error loading config: {e}")
            raise

    def _setup_event_subscriptions(self):
        """Setup EventBus subscriptions for harmonizer events"""
        try:
            # Subscribe to pattern events
            self.event_bus.subscribe("PatternDetected", self._handle_pattern_detected)
            
            # Subscribe to signal events (from DSR/SignalEngine)
            self.event_bus.subscribe("SignalGenerated", self._handle_signal_generated)
            self.event_bus.subscribe("StrategyRecommendation", self._handle_strategy_recommendation)
            
            # Subscribe to execution feedback for adaptive learning
            self.event_bus.subscribe("ExecutionResult", self._handle_execution_result)
            self.event_bus.subscribe("TradeExecuted", self._handle_trade_executed)
            
            # Subscribe to historical data requests
            self.event_bus.subscribe("HistoricalPatternRequest", self._handle_historical_pattern_request)
            
            # Subscribe to system events
            self.event_bus.subscribe("SystemStatusCheck", self._handle_status_check)
            self.event_bus.subscribe("PerformanceMetricsRequest", self._handle_metrics_request)
            
            self.logger.info("EventBus subscriptions established")
            
        except Exception as e:
            self.logger.error(f"Error setting up EventBus subscriptions: {e}")
            raise

    def _handle_pattern_detected(self, event_data: Dict[str, Any]):
        """Handle incoming patterns from PatternEngine"""
        try:
            harmonization_start_time = time.time()
            
            with self.lock:
                pattern_data = event_data.get('payload', {})
                
                # Validate pattern data structure
                required_fields = ['pattern_id', 'symbol', 'confidence', 'timeframe']
                assert all(field in pattern_data for field in required_fields):
                    self.logger.warning(f"Invalid pattern data structure: missing fields")
                    return
                
                # Check pattern age and confidence
                if not self._validate_pattern_eligibility(pattern_data):
                    return
                
                # Add to pattern buffer
                pattern_data['received_timestamp'] = datetime.datetime.now().isoformat()
                self.pattern_buffer.append(pattern_data)
                self.performance_tracker['patterns_processed'] += 1
                
                # Try immediate harmonization with existing signals
                self._attempt_pattern_signal_harmonization(pattern_data, harmonization_start_time)
                
        except Exception as e:
            self.logger.error(f"Error handling pattern detection: {e}")
            self._emit_module_error("PATTERN_PROCESSING_ERROR", str(e))

    def _handle_signal_generated(self, event_data: Dict[str, Any]):
        """Handle incoming signals from Signal Engine or DSR"""
        try:
            harmonization_start_time = time.time()
            
            with self.lock:
                signal_data = event_data.get('payload', {})
                
                # Validate signal data structure
                required_fields = ['signal_id', 'symbol', 'confidence', 'direction']
                if not all(field in signal_data for field in required_fields):
                    self.logger.warning(f"Invalid signal data structure: missing fields")
                    return
                
                # Check signal age and confidence
                if not self._validate_signal_eligibility(signal_data):
                    return
                
                # Add to signal buffer
                signal_data['received_timestamp'] = datetime.datetime.now().isoformat()
                self.signal_buffer.append(signal_data)
                self.performance_tracker['signals_processed'] += 1
                
                # Try immediate harmonization with existing patterns
                self._attempt_signal_pattern_harmonization(signal_data, harmonization_start_time)
                
        except Exception as e:
            self.logger.error(f"Error handling signal generation: {e}")
            self._emit_module_error("SIGNAL_PROCESSING_ERROR", str(e))

    def _attempt_pattern_signal_harmonization(self, pattern_data: Dict[str, Any], start_time: float):
        """Attempt to harmonize new pattern with existing signals"""
        try:
            # Find matching signals in buffer
            matching_signals = []
            pattern_symbol = pattern_data.get('symbol')
            
            for signal in self.signal_buffer:
                if (signal.get('symbol') == pattern_symbol and 
                    self._check_temporal_alignment(pattern_data, signal)):
                    matching_signals.append(signal)
            
            # Create harmonics for matching signals
            for signal in matching_signals:
                harmonic = self._create_pattern_signal_harmonic(pattern_data, signal, start_time)
                if harmonic and self._validate_harmonic_quality(harmonic):
                    self._emit_harmonized_signal(harmonic)
                    
        except Exception as e:
            self.logger.error(f"Error in pattern-signal harmonization: {e}")

    def _attempt_signal_pattern_harmonization(self, signal_data: Dict[str, Any], start_time: float):
        """Attempt to harmonize new signal with existing patterns"""
        try:
            # Find matching patterns in buffer
            matching_patterns = []
            signal_symbol = signal_data.get('symbol')
            
            for pattern in self.pattern_buffer:
                if (pattern.get('symbol') == signal_symbol and 
                    self._check_temporal_alignment(signal_data, pattern)):
                    matching_patterns.append(pattern)
            
            # Create harmonics for matching patterns
            for pattern in matching_patterns:
                harmonic = self._create_pattern_signal_harmonic(pattern, signal_data, start_time)
                if harmonic and self._validate_harmonic_quality(harmonic):
                    self._emit_harmonized_signal(harmonic)
                    
        except Exception as e:
            self.logger.error(f"Error in signal-pattern harmonization: {e}")

    def _create_pattern_signal_harmonic(self, pattern_data: Dict[str, Any], 
                                      signal_data: Dict[str, Any], start_time: float) -> Optional[PatternSignalHarmonic]:
        """Create harmonized pattern-signal combination"""
        try:
            # Generate unique harmonic ID
            harmonic_id = f"HARMONIC_{pattern_data['pattern_id']}_{signal_data['signal_id']}_{int(time.time() * 1000)}"
            
            # Extract confidence values
            pattern_confidence = pattern_data.get('confidence', 0.0)
            signal_confidence = signal_data.get('confidence', 0.0)
            
            # Calculate base harmonic score
            harmonic_score = self._calculate_harmonic_score(pattern_confidence, signal_confidence)
            
            # Get historical success rate for this pattern type
            historical_success_rate = self._get_historical_success_rate(pattern_data)
            
            # Apply adaptive weighting based on recent performance
            adaptive_weight = self._get_adaptive_weight(pattern_data)
            
            # Calculate harmonization latency
            harmonization_latency_ms = (time.time() - start_time) * 1000
            
            # Create execution context
            execution_context = {
                'symbol': pattern_data.get('symbol'),
                'timeframe': pattern_data.get('timeframe'),
                'direction': signal_data.get('direction'),
                'pattern_type': pattern_data.get('pattern_type', 'unknown'),
                'signal_source': signal_data.get('source', 'unknown'),
                'market_conditions': self._get_current_market_conditions(),
                'harmonization_latency_ms': harmonization_latency_ms
            }
            
            # Create telemetry payload
            telemetry_payload = self._create_harmonic_telemetry_payload(
                pattern_data, signal_data, harmonic_score, historical_success_rate, adaptive_weight
            )
            
            # Create harmonic object
            harmonic = PatternSignalHarmonic(
                harmonic_id=harmonic_id,
                pattern_id=pattern_data['pattern_id'],
                signal_id=signal_data['signal_id'],
                pattern_confidence=pattern_confidence,
                signal_confidence=signal_confidence,
                harmonic_score=harmonic_score,
                historical_success_rate=historical_success_rate,
                adaptive_weight=adaptive_weight,
                execution_context=execution_context,
                harmony_timestamp=datetime.datetime.now().isoformat(),
                telemetry_payload=telemetry_payload
            )
            
            # Update performance tracking
            self.performance_tracker['harmonics_created'] += 1
            self.performance_tracker['total_harmonization_latency_ms'] += harmonization_latency_ms
            
            # Update average latency
            if self.performance_tracker['harmonics_created'] > 0:
                self.performance_tracker['avg_harmonization_latency_ms'] = (
                    self.performance_tracker['total_harmonization_latency_ms'] / 
                    self.performance_tracker['harmonics_created']
                )
            
            self.logger.info(f"Pattern-signal harmonic created: {harmonic_id}")
            return harmonic
            
        except Exception as e:
            self.logger.error(f"Error creating pattern-signal harmonic: {e}")
            raise RuntimeError("ARCHITECT_MODE_COMPLIANCE: Pattern signal harmonization failed")

    def _calculate_harmonic_score(self, pattern_confidence: float, signal_confidence: float) -> float:
        """Calculate harmonic score from pattern and signal confidences"""
        try:
            # Weighted combination of pattern and signal confidence
            pattern_weight = self.constraints.pattern_weight
            signal_weight = self.constraints.signal_weight
            
            # Base harmonic score
            base_score = (pattern_confidence * pattern_weight) + (signal_confidence * signal_weight)
            
            # Apply confidence alignment bonus (higher when confidences are similar)
            confidence_diff = abs(pattern_confidence - signal_confidence)
            alignment_bonus = 1.0 - (confidence_diff * 0.2)  # Up to 20% bonus for aligned confidences
            alignment_bonus = max(0.8, min(1.2, alignment_bonus))  # Clamp between 0.8 and 1.2
            
            # Final harmonic score
            harmonic_score = base_score * alignment_bonus
            
            # Ensure score is within valid range [0.0, 1.0]
            return max(0.0, min(1.0, harmonic_score))
            
        except Exception as e:
            self.logger.error(f"Error calculating harmonic score: {e}")
            return 0.0

    def _get_historical_success_rate(self, pattern_data: Dict[str, Any]) -> float:
        """Get historical success rate for pattern type"""
        try:
            pattern_type = pattern_data.get('pattern_type', 'unknown')
            symbol = pattern_data.get('symbol', 'unknown')
            pattern_key = f"{pattern_type}_{symbol}"
            
            # Return cached success rate if available
            if pattern_key in self.pattern_success_rates:
                success_rate = self.pattern_success_rates[pattern_key]
                self.performance_tracker['historical_matches'] += 1
                return success_rate
            
            # Calculate success rate from historical data
            historical_data = self.historical_patterns.get(pattern_key, [])
            if len(historical_data) >= 5:  # Minimum sample size
                successful_executions = sum(1 for h in historical_data if h.get('success', False))
                success_rate = successful_executions / len(historical_data)
                
                # Cache the calculated success rate
                self.pattern_success_rates[pattern_key] = success_rate
                self.performance_tracker['historical_matches'] += 1
                
                return success_rate
            
            # Default success rate for new patterns
            return 0.75  # Conservative default
            
        except Exception as e:
            self.logger.error(f"Error getting historical success rate: {e}")
            return 0.75

    def _get_adaptive_weight(self, pattern_data: Dict[str, Any]) -> float:
        """Get adaptive weight based on recent pattern performance"""
        try:
            pattern_type = pattern_data.get('pattern_type', 'unknown')
            symbol = pattern_data.get('symbol', 'unknown')
            pattern_key = f"{pattern_type}_{symbol}"
            
            # Return cached adaptive weight
            adaptive_weight = self.adaptive_weights.get(pattern_key, 1.0)
            
            return max(0.5, min(1.5, adaptive_weight))  # Clamp between 0.5 and 1.5
            
        except Exception as e:
            self.logger.error(f"Error getting adaptive weight: {e}")
            return 1.0

    def _validate_pattern_eligibility(self, pattern_data: Dict[str, Any]) -> bool:
        """Validate if pattern is eligible for harmonization"""
        try:
            # Check pattern confidence
            pattern_confidence = pattern_data.get('confidence', 0.0)
            if pattern_confidence < self.constraints.min_pattern_confidence is not None, "Real data required - no fallbacks allowed"
    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        

# <!-- @GENESIS_MODULE_END: pattern_signal_harmonizer -->