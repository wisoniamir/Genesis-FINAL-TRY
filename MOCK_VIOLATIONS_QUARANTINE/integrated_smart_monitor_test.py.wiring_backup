from event_bus import EventBus
#!/usr/bin/env python3
"""
GENESIS INTEGRATED SMART MONITOR TEST v1.0 - ARCHITECT MODE v2.7
================================================================
Integrated test that starts SmartExecutionMonitor and validates all thresholds.

This test:
1. Starts SmartExecutionMonitor in background
2. Emits test data to trigger thresholds
3. Validates all responses: ExecutionDeviationAlert, KillSwitchTrigger, RecalibrationRequest
4. Confirms telemetry and logging compliance

Dependencies: event_bus.py, smart_execution_monitor.py
Real Data: ENABLED
Compliance: ENFORCED
"""

import os
import sys
import json
import time
import logging
import threading
from datetime import datetime, timedelta
from typing import Dict, Any, List

# Import required modules
from event_bus import emit_event, subscribe_to_event, register_route
from smart_execution_monitor import SmartExecutionMonitor


# <!-- @GENESIS_MODULE_END: integrated_smart_monitor_test -->


# <!-- @GENESIS_MODULE_START: integrated_smart_monitor_test -->

# Configure logging
log_dir = "logs/smart_monitor"
os.makedirs(log_dir, exist_ok=True)
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] - %(message)s",
    handlers=[
        logging.FileHandler(f"{log_dir}/integrated_test_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.log"),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("IntegratedSmartMonitorTest")

# Test results tracking
test_results = {
    "test_id": f"integrated_test_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}",
    "test_start_time": datetime.utcnow().isoformat(),
    "slippage_alert_received": False,
    "latency_alert_received": False,
    "killswitch_triggered": False,
    "recalibration_requested": False,
    "smart_log_sync_received": False,
    "events_received": [],
    "test_result": "PENDING",
    "test_completion_time": None,
    "monitor_status": "PENDING"
}

# Global monitor instance
monitor = None

def start_smart_monitor():
    """Start SmartExecutionMonitor in background thread"""
    global monitor
    try:
        logger.info("STARTING SmartExecutionMonitor...")
        monitor = SmartExecutionMonitor()
        test_results["monitor_status"] = "RUNNING"
        logger.info("✅ SmartExecutionMonitor started successfully")
        
        # Keep monitor running
        while True:
            time.sleep(1)
            
    except Exception as e:
        logger.error(f"❌ Failed to start SmartExecutionMonitor: {e}")
        test_results["monitor_status"] = "FAILED"

# Event callbacks
def on_execution_deviation_alert(event):
    """Tracks ExecutionDeviationAlert events from SmartExecutionMonitor"""
    event_data = event.get("data", event)
    
    logger.info(f"✅ ExecutionDeviationAlert Received: {json.dumps(event_data, indent=2)}")
    
    # Check for slippage alert
    if "slippage" in str(event_data):
        test_results["slippage_alert_received"] = True
        logger.info("✅ SLIPPAGE ALERT TEST PASSED")
    
    # Check for latency alert
    if "latency" in str(event_data):
        test_results["latency_alert_received"] = True
        logger.info("✅ LATENCY ALERT TEST PASSED")
    
    test_results["events_received"].append({
        "event_type": "ExecutionDeviationAlert",
        "timestamp": datetime.utcnow().isoformat(),
        "data": event_data
    })
    
    check_test_completion()

def on_kill_switch_trigger(event):
    """Tracks KillSwitchTrigger events from SmartExecutionMonitor"""
    event_data = event.get("data", event)
    
    logger.info(f"✅ KillSwitchTrigger Received: {json.dumps(event_data, indent=2)}")
    test_results["killswitch_triggered"] = True
    logger.info("✅ KILL SWITCH TEST PASSED")
    
    test_results["events_received"].append({
        "event_type": "KillSwitchTrigger",
        "timestamp": datetime.utcnow().isoformat(),
        "data": event_data
    })
    
    check_test_completion()

def on_recalibration_request(event):
    """Tracks RecalibrationRequest events from SmartExecutionMonitor"""
    event_data = event.get("data", event)
    
    logger.info(f"✅ RecalibrationRequest Received: {json.dumps(event_data, indent=2)}")
    test_results["recalibration_requested"] = True
    logger.info("✅ PATTERN RECALIBRATION TEST PASSED")
    
    test_results["events_received"].append({
        "event_type": "RecalibrationRequest",
        "timestamp": datetime.utcnow().isoformat(),
        "data": event_data
    })
    
    check_test_completion()

def on_smart_log_sync(event):
    """Tracks SmartLogSync events from SmartExecutionMonitor"""
    event_data = event.get("data", event)
    
    logger.info(f"📊 SmartLogSync Received: {json.dumps(event_data, indent=2)}")
    test_results["smart_log_sync_received"] = True
    
    test_results["events_received"].append({
        "event_type": "SmartLogSync",
        "timestamp": datetime.utcnow().isoformat(),
        "data": event_data
    })

def check_test_completion():
    """Checks if all required tests have completed"""
    if (test_results["slippage_alert_received"] and 
        test_results["latency_alert_received"] and 
        test_results["killswitch_triggered"] and 
        test_results["recalibration_requested"]):
        
        logger.info("✅ ALL SMART MONITOR VALIDATION TESTS PASSED!")
        test_results["test_result"] = "PASSED"
        test_results["test_completion_time"] = datetime.utcnow().isoformat()
        save_test_results()

def save_test_results():
    """Saves test results to file"""
    with open(f"{log_dir}/integrated_test_{test_results['test_id']}.json", 'w') as f:
        json.dump(test_results, f, indent=2)
    logger.info(f"💾 Test results saved to {log_dir}/integrated_test_{test_results['test_id']}.json")

def run_integrated_test():
    """Run the complete integrated SmartExecutionMonitor test"""
    
    # Start SmartExecutionMonitor in background thread
    monitor_thread = threading.Thread(target=start_smart_monitor, daemon=True)
    monitor_thread.start()
    
    # Give monitor time to start
    time.sleep(3)
    
    if test_results["monitor_status"] != "RUNNING":
        logger.error("❌ Failed to start SmartExecutionMonitor")
        return False
    
    # Register event handlers for expected responses
    subscribe_to_event("ExecutionDeviationAlert", on_execution_deviation_alert, "IntegratedTest")
    subscribe_to_event("KillSwitchTrigger", on_kill_switch_trigger, "IntegratedTest")
    subscribe_to_event("RecalibrationRequest", on_recalibration_request, "IntegratedTest")
    subscribe_to_event("SmartLogSync", on_smart_log_sync, "IntegratedTest")
    
    logger.info("🚀 GENESIS INTEGRATED SMART EXECUTION MONITOR TEST - STARTING")
    logger.info("📡 Event subscribers registered")
    
    # Test 1: Emit LiveTradeExecuted with high slippage (>0.7)
    high_slippage_trade = {
        "trade_id": f"trade_{int(time.time())}",
        "symbol": "EURUSD",
        "direction": "BUY",
        "entry_price": 1.0840,
        "requested_price": 1.0830,
        "slippage": 1.0,  # 1.0 pip slippage > 0.7 threshold
        "lot_size": 1.0,
        "execution_time": datetime.utcnow().isoformat(),
        "execution_latency_ms": 120,
        "strategy_id": "test_strategy_1",
        "profit": 0
    }
    
    logger.info(f"📤 TEST 1: Emitting LiveTradeExecuted with high slippage (1.0 > 0.7)")
    emit_event("LiveTradeExecuted", high_slippage_trade, "IntegratedTest")
    time.sleep(2)
    
    # Test 2: Emit ModuleTelemetry with high latency (>350ms)
    high_latency_telemetry = {
        "timestamp": datetime.utcnow().isoformat(),
        "module": "ExecutionEngine",
        "metrics": {
            "execution_latency_ms": 400,  # 400ms > 350ms threshold
            "trades_executed": 10,
            "success_rate": 1.0
        },
        "status": "active"
    }
    
    logger.info(f"📤 TEST 2: Emitting ModuleTelemetry with high latency (400ms > 350ms)")
    emit_event("ModuleTelemetry", high_latency_telemetry, "IntegratedTest")
    time.sleep(2)
    
    # Test 3: Emit series of losing trades to trigger drawdown >12.5%
    logger.info(f"📤 TEST 3: Emitting series of trades to execute_live >12.5% drawdown")
    initial_equity = 10000.0
    current_equity = initial_equity
    
    for i in range(10):
        loss = -150 * (i+1)  # Increasing loss
        current_equity += loss
        trade = {
            "trade_id": f"dd_trade_{i}_{int(time.time())}",
            "symbol": "EURUSD",
            "direction": "BUY",
            "entry_price": 1.0840,
            "exit_price": 1.0820,
            "lot_size": 1.0,
            "execution_time": (datetime.utcnow() - timedelta(minutes=i*10)).isoformat(),
            "closing_time": (datetime.utcnow() - timedelta(minutes=i*5)).isoformat(),
            "strategy_id": "test_strategy_2",
            "profit": loss
        }
        emit_event("LiveTradeExecuted", trade, "IntegratedTest")
        time.sleep(0.5)
    
    drawdown_pct = (initial_equity - current_equity) / initial_equity * 100
    logger.info(f"Simulated drawdown: {drawdown_pct:.2f}% (threshold: 12.5%)")
    time.sleep(2)
    
    # Test 4: Emit ModuleTelemetry with pattern edge decay >7 sessions
    pattern_edge_decay_telemetry = {
        "timestamp": datetime.utcnow().isoformat(),
        "module": "PatternEngine",
        "metrics": {
            "pattern_performance": {
                "pattern_id": "OB_compression_4h",
                "edge_decay_sessions": 9,  # 9 sessions > 7 threshold
                "win_rate": 0.42,
                "expected_edge": 0.62
            }
        },
        "status": "active"
    }
    
    logger.info(f"📤 TEST 4: Emitting ModuleTelemetry with pattern edge decay (9 > 7 sessions)")
    emit_event("ModuleTelemetry", pattern_edge_decay_telemetry, "IntegratedTest")
    time.sleep(2)
    
    # Wait for all events to process
    timeout_seconds = 15
    start_time = time.time()
    
    while time.time() - start_time < timeout_seconds:
        if test_results["test_result"] != "PENDING":
            break
        time.sleep(0.5)
    
    # Handle timeout
    if test_results["test_result"] == "PENDING":
        logger.warning("⚠️ TEST TIMEOUT: Not all expected events were received")
        test_results["test_result"] = "TIMEOUT"
        test_results["test_completion_time"] = datetime.utcnow().isoformat()
        save_test_results()
    
    # Final test summary
    print("\n" + "="*80)
    print(f"🧾 INTEGRATED SMART MONITOR TEST SUMMARY: {test_results['test_result']}")
    print(f"🏭 Monitor Status: {test_results['monitor_status']}")
    if test_results['test_completion_time']:
        duration = (datetime.fromisoformat(test_results['test_completion_time']) - 
                   datetime.fromisoformat(test_results['test_start_time'])).total_seconds()
        print(f"⏱️ Duration: {duration} seconds")
    print(f"📊 Events Received: {len(test_results['events_received'])}")
    print(f"✅ Slippage Alert: {'PASSED' if test_results['slippage_alert_received'] else 'FAILED'}")
    print(f"✅ Latency Alert: {'PASSED' if test_results['latency_alert_received'] else 'FAILED'}")
    print(f"✅ KillSwitch Trigger: {'PASSED' if test_results['killswitch_triggered'] else 'FAILED'}")
    print(f"✅ Pattern Recalibration: {'PASSED' if test_results['recalibration_requested'] else 'FAILED'}")
    print(f"📡 SmartLogSync: {'RECEIVED' if test_results['smart_log_sync_received'] else 'NOT RECEIVED'}")
    print("="*80 + "\n")
    
    return test_results["test_result"] == "PASSED"

if __name__ == "__main__":
    try:
        success = run_integrated_test()
        sys.exit(0 if success else 1)
    except Exception as e:
        logger.exception(f"❌ INTEGRATED TEST FAILED WITH EXCEPTION: {e}")
        sys.exit(1)
