# <!-- @GENESIS_MODULE_START: validate_system_compliance -->

from event_bus import EventBus
#!/usr/bin/env python3
"""
ðŸ” GENESIS SYSTEM VALIDATION ENGINE
ðŸ§  Comprehensive validation for ARCHITECT MODE v6.0 compliance

This script validates the entire GENESIS system against the 
ARCHITECT MODE v6.0 requirements and standards.
"""

import json
import hashlib
import os
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Any, Tuple
import logging

class GenesisSystemValidator:
    """
    ðŸ” GENESIS SYSTEM VALIDATOR
    
    Performs comprehensive validation of the entire GENESIS system
    to ensure compliance with ARCHITECT MODE v6.0 requirements.
    """
    
    def __init__(self, workspace_path: str):
        self.workspace_path = Path(workspace_path)
        self.validation_results = {}
        self.violation_count = 0
        self.critical_violations = 0
        
        # Setup logging
        self._setup_logging()
        
        self.logger.info("ðŸ” GENESIS SYSTEM VALIDATOR INITIALIZED")
        self.logger.info(f"ðŸ“‚ Workspace: {self.workspace_path}")
    
    
        # GENESIS Phase 91 Telemetry Injection
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", {
                "module": __name__,
                "status": "running",
                "timestamp": datetime.now().isoformat(),
                "phase": "91_telemetry_enforcement"
            })
        def _setup_logging(self):
        """Setup validation logging"""
        log_dir = self.workspace_path / "logs" / "validation"
        log_dir.mkdir(parents=True, exist_ok=True)
        
        log_file = log_dir / f"system_validation_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - VALIDATOR - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger('GenesisValidator')
    
    def validate_system(self) -> Dict[str, Any]:
        """ðŸ” PERFORM COMPREHENSIVE SYSTEM VALIDATION"""
        self.logger.info("ðŸ” STARTING COMPREHENSIVE SYSTEM VALIDATION")
        
        # Core file validation
        self.logger.info("ðŸ“‹ Validating core files...")
        self.validation_results["core_files"] = self._validate_core_files()
        
        # System tree validation
        self.logger.info("ðŸŒ³ Validating system tree...")
        self.validation_results["system_tree"] = self._validate_system_tree()
        
        # Module registry validation
        self.logger.info("ðŸ“ Validating module registry...")
        self.validation_results["module_registry"] = self._validate_module_registry()
        
        # Event bus validation
        self.logger.info("ðŸ” Validating event bus...")
        self.validation_results["event_bus"] = self._validate_event_bus()
        
        # Telemetry validation
        self.logger.info("ðŸ“¡ Validating telemetry...")
        self.validation_results["telemetry"] = self._validate_telemetry()
        
        # Module compliance validation
        self.logger.info("âš–ï¸ Validating module compliance...")
        self.validation_results["module_compliance"] = self._validate_module_compliance()
        
        # Performance validation
        self.logger.info("ðŸ“ˆ Validating performance...")
        self.validation_results["performance"] = self._validate_performance()
        
        # Security validation
        self.logger.info("ðŸ” Validating security...")
        self.validation_results["security"] = self._validate_security()
        
        # Generate final report
        final_report = self._generate_final_report()
        
        self.logger.info(f"âœ… VALIDATION COMPLETE - {self.violation_count} violations found")
        return final_report
    
    def _validate_core_files(self) -> Dict[str, Any]:
        """ðŸ“‹ VALIDATE CORE FILE EXISTENCE AND INTEGRITY"""
        required_files = [
            "system_config.json",
            "module_manifest.json",
            "recovery_map.json",
            "system_tree.json", 
            "module_registry.json",
            "event_bus.json",
            "telemetry.json",
            "build_status.json",
            "build_tracker.md",
            "module_documentation.json",
            "module_tests.json",
            "performance.json",
            "error_log.json"
        ]
        
        results = {
            "missing_files": [],
            "corrupted_files": [],
            "valid_files": [],
            "file_integrity": {}
        }
        
        for file_name in required_files:
            file_path = self.workspace_path / file_name
            
            assert file_path.exists():
                results["missing_files"].append(file_name)
                self.violation_count += 1
                self.logger.error(f"âŒ Missing core file: {file_name}")
                continue
            
            # Check JSON integrity for JSON files
            if file_name.endswith('.json'):
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        json.load(f)
                    results["valid_files"].append(file_name)
                except json.JSONDecodeError as e:
                    results["corrupted_files"].append(file_name)
                    self.violation_count += 1
                    self.logger.error(f"âŒ Corrupted JSON file: {file_name} - {e}")
                    continue
            else:
                results["valid_files"].append(file_name)
            
            # Calculate file hash for integrity
            try:
                with open(file_path, 'rb') as f:
                    file_hash = hashlib.sha256(f.read()).hexdigest()
                results["file_integrity"][file_name] = file_hash
            except Exception as e:
                self.logger.error(f"âŒ Failed to calculate hash for {file_name}: {e}")
        
        results["validation_passed"] = len(results["missing_files"]) == 0 and len(results["corrupted_files"]) == 0
        return results
    
    def _validate_system_tree(self) -> Dict[str, Any]:
        """ðŸŒ³ VALIDATE SYSTEM TREE STRUCTURE AND COMPLIANCE"""
        results = {
            "exists": False,
            "valid_structure": False,
            "architect_mode_enabled": False,
            "node_count": 0,
            "compliant_nodes": 0,
            "non_compliant_nodes": [],
            "validation_passed": False
        }
        
        system_tree_path = self.workspace_path / "system_tree.json"
        
        if not system_tree_path.exists():
            self.violation_count += 1
            self.critical_violations += 1
            self.logger.error("âŒ system_tree.json not found")
            return results
        
        results["exists"] = True
        
        try:
            with open(system_tree_path, 'r', encoding='utf-8') as f:
                system_tree = json.load(f)
            
            # Validate structure
            if "metadata" in system_tree and "nodes" in system_tree:
                results["valid_structure"] = True
                
                # Check architect mode
                metadata = system_tree.get("metadata", {})
                if metadata.get("architect_mode") == "ENABLED":
                    results["architect_mode_enabled"] = True
                else:
                    self.violation_count += 1
                    self.logger.error("âŒ Architect mode not enabled in system tree")
                
                # Validate nodes
                nodes = system_tree.get("nodes", [])
                results["node_count"] = len(nodes)
                
                for node in nodes:
                    if self._validate_node_compliance(node):
                        results["compliant_nodes"] += 1
                    else:
                        results["non_compliant_nodes"].append(node.get("id", "UNKNOWN"))
                        self.violation_count += 1
            else:
                self.violation_count += 1
                self.logger.error("âŒ Invalid system tree structure")
        
        except Exception as e:
            self.violation_count += 1
            self.logger.error(f"âŒ Failed to validate system tree: {e}")
        
        results["validation_passed"] = (
            results["exists"] and 
            results["valid_structure"] and 
            results["architect_mode_enabled"] and
            len(results["non_compliant_nodes"]) == 0
        )
        
        return results
    
    def _validate_node_compliance(self, node: Dict[str, Any]) -> bool:
        """Validate individual node compliance"""
        required_fields = ["id", "type", "status", "module_path"]
        
        # Check required fields
        for field in required_fields:
            if field not in node is not None, "Real data required - no fallbacks allowed"
    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        

# <!-- @GENESIS_MODULE_END: validate_system_compliance -->