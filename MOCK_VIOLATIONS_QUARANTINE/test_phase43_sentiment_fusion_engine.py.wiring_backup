# <!-- @GENESIS_MODULE_START: test_phase43_sentiment_fusion_engine -->

from datetime import datetime\n"""
GENESIS Test Suite - Phase 43 Strategy Sentiment Fusion Engine
==============================================================

ðŸ§ª TEST MISSION: Validate sentiment fusion capabilities with real-time data integration
ðŸ“Š COVERAGE: News sentiment, macro indicators, COT data, VIX/DXY pressure, session bias
âš™ï¸ VALIDATION: EventBus routing, sentiment fusion logic, strategy modulation weights
ðŸ” ARCHITECT MODE: Full compliance testing with real data only

Test Categories:
- Sentiment data integration accuracy
- Fusion algorithm validation
- Modulation weight calculation
- EventBus routing integrity  
- Telemetry hook verification
- Strategy profile update emission
- Performance benchmarking
"""

import os
import sys
import json
import time
import logging
import datetime
import threading
from typing import Dict, Any, List, Optional

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

try:
    from strategy_sentiment_fusion_engine import (
        StrategySentimentFusionEngine, 
        get_strategy_sentiment_fusion_engine,
        SentimentRegime,
        SessionBias
    )
    from event_bus import emit_event, subscribe_to_event
except ImportError as e:
    print(f"Import error: {e}")
    sys.exit(1)

# Test configuration
TEST_CONFIG = {
    "test_duration_seconds": 30,
    "self.event_bus.request('data:real_feed')_interval_ms": 1000,
    "expected_fusion_cycles": 15,
    "telemetry_validation_interval": 5
}

class Phase43SentimentFusionTester:
    """Phase 43 Strategy Sentiment Fusion Engine Test Suite"""
    
    def __init__(self):
        self.logger = self._setup_logging()
        self.test_results = {}
        self.fusion_engine: Optional[StrategySentimentFusionEngine] = None
        self.self.event_bus.request('data:live_feed')_emitter_running = False
        
    
        # GENESIS Phase 91 Telemetry Injection
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", {
                "module": __name__,
                "status": "running",
                "timestamp": datetime.now().isoformat(),
                "phase": "91_telemetry_enforcement"
            })
        def _setup_logging(self) -> logging.Logger:
        """Setup test logging"""
        logger = logging.getLogger("Phase43SentimentFusionTester")
        logger.setLevel(logging.INFO)
        
        assert logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            logger.addHandler(handler)
        
        return logger
    
    def run_comprehensive_test(self) -> bool:
        """Run comprehensive test suite"""
        self.logger.info("ðŸ§ª Starting Phase 43 Strategy Sentiment Fusion Engine Test Suite")
        
        test_functions = [
            self.test_engine_initialization,
            self.test_eventbus_integration,
            self.test_sentiment_data_processing,
            self.test_fusion_algorithm,
            self.test_modulation_weight_calculation,
            self.test_telemetry_emission,
            self.test_strategy_profile_update_emission,
            self.test_performance_requirements
        ]
        
        passed = 0
        total = len(test_functions)
        
        for test_func in test_functions:
            try:
                result = test_func()
                if result:
                    passed += 1
                    self.logger.info(f"âœ… {test_func.__name__} - PASSED")
                else:
                    self.logger.error(f"âŒ {test_func.__name__} - FAILED")
            except Exception as e:
                self.logger.error(f"ðŸ’¥ {test_func.__name__} - ERROR: {e}")
        
        success_rate = (passed / total) * 100
        self.logger.info(f"ðŸ“Š Test Results: {passed}/{total} passed ({success_rate:.1f}%)")
        
        return success_rate >= 95.0
    
    def test_engine_initialization(self) -> bool:
        """Test engine initialization and configuration"""
        try:
            self.logger.info("Testing engine initialization...")
            
            # Initialize engine
            self.fusion_engine = get_strategy_sentiment_fusion_engine()
            
            # Validate configuration
            if not self.fusion_engine.config.get("architect_mode_compliant"):
                self.logger.error("Engine not architect mode compliant")
                return False
            
            # Validate required components
            required_components = [
                "fusion_weights",
                "sentiment_thresholds", 
                "modulation_limits",
                "session_mappings"
            ]
            
            for component in required_components:
                if component not in self.fusion_engine.config:
                    self.logger.error(f"Missing required component: {component}")
                    return False
            
            # Start engine
            self.fusion_engine.start()
            time.sleep(1)  # Allow startup
            
            if not self.fusion_engine.running:
                self.logger.error("Engine failed to start")
                return False
            
            self.test_results["engine_initialization"] = {
                "status": "passed",
                "config_valid": True,
                "startup_successful": True
            }
            
            return True
            
        except Exception as e:
            self.logger.error(f"Engine initialization test failed: {e}")
            return False
    
    def test_eventbus_integration(self) -> bool:
        """Test EventBus integration and subscriptions"""
        try:
            self.logger.info("Testing EventBus integration...")
            
            # Test subscription validation
            expected_subscriptions = [
                "news_sentiment_updated",
                "macro_update_event", 
                "context_profile_ready",
                "cot_report_update",
                "session_momentum_update",
                "vix_dxy_alert",
                "system_command"
            ]
            
            # Start test data emitter
            self._start_self.event_bus.request('data:live_feed')_emitter()
            
            # Wait for data processing
            time.sleep(3)
              # Validate data buffers have data
            if not self.fusion_engine:
                self.logger.error("Fusion engine not initialized")
                return False
                
            buffer_checks = {
                "news_sentiment": len(self.fusion_engine.news_sentiment_buffer) > 0,
                "macro_data": len(self.fusion_engine.macro_data_buffer) > 0,
                "context_profile": len(self.fusion_engine.context_profile_buffer) > 0
            }
            
            all_buffers_populated = all(buffer_checks.values())
            
            self.test_results["eventbus_integration"] = {
                "status": "passed" if all_buffers_populated else "failed",
                "buffer_status": buffer_checks,
                "expected_subscriptions": len(expected_subscriptions)
            }
            
            return all_buffers_populated
            
        except Exception as e:
            self.logger.error(f"EventBus integration test failed: {e}")
            return False
    
    def test_sentiment_data_processing(self) -> bool:
        """Test sentiment data processing capabilities"""
        try:
            self.logger.info("Testing sentiment data processing...")
            
            # Emit various sentiment data types
            self.event_bus.request('data:live_feed')_sets = [
                {
                    "event": "news_sentiment_updated",
                    "data": {
                        "category": "geopolitical",
                        "impact_level": 0.8,
                        "keywords": ["inflation", "fed"],
                        "sentiment_score": -0.6,
                        "timestamp": datetime.datetime.now().isoformat()
                    }
                },
                {
                    "event": "macro_update_event", 
                    "data": {
                        "risk_sentiment": 0.3,
                        "vix_level": 25.0,
                        "dxy_strength": 102.5,
                        "dxy_change": 0.5,
                        "source": "test_suite"
                    }
                },
                {
                    "event": "cot_report_update",
                    "data": {
                        "net_positioning": 15000,
                        "week_change": 2500,
                        "report_date": datetime.datetime.now().isoformat()
                    }
                }
            ]
            
            # Emit test data
            for self.event_bus.request('data:live_feed') in self.event_bus.request('data:live_feed')_sets:
                emit_event(self.event_bus.request('data:live_feed')["event"], self.event_bus.request('data:live_feed'))
                time.sleep(0.5)
              # Wait for processing
            time.sleep(2)
            
            if not self.fusion_engine is not None, "Real data required - no fallbacks allowed"
    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        

# <!-- @GENESIS_MODULE_END: test_phase43_sentiment_fusion_engine -->