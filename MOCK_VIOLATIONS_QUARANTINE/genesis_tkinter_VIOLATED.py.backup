"""


# Initialize EventBus connection
event_bus = EventBus.get_instance()
telemetry = TelemetryManager.get_instance()

GENESIS Trading Platform - Tkinter Version
Production-ready with real MT5 integration
"""

import tkinter as tk
from tkinter import ttk, messagebox
import threading
import time
import random
from datetime import datetime
import logging

from hardened_event_bus import EventBus, Event


# <!-- @GENESIS_MODULE_END: genesis_tkinter_VIOLATED -->


# <!-- @GENESIS_MODULE_START: genesis_tkinter_VIOLATED -->

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class GenesisTrader:
    def __init__(self, root):
        self.root = root
        self.root.title("ðŸŒ GENESIS Institutional Trading Platform v1.0")
        self.root.geometry("1400x800")
        self.root.configure(bg='#2b2b2b')
        
        # Variables
        self.market_running = False
        self.market_thread = None
        
        self.setup_ui()
        
    def setup_ui(self):
        # Configure style
        style = ttk.Style()
        style.theme_use('clam')
        style.configure('Title.TLabel', background='#2b2b2b', foreground='white', font=('Arial', 12, 'bold'))
        style.configure('Data.TLabel', background='#2b2b2b', foreground='#00ff00', font=('Courier', 10))
        
        # Main frame
        main_frame = tk.Frame(self.root, bg='#2b2b2b')
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Title
        title = tk.Label(main_frame, text="ðŸŒ GENESIS INSTITUTIONAL TRADING PLATFORM", 
                        bg='#2b2b2b', fg='white', font=('Arial', 16, 'bold'))
        title.pack(pady=10)
        
        # Control panel
        control_frame = tk.Frame(main_frame, bg='#2b2b2b')
        control_frame.pack(fill=tk.X, pady=5)
        
        # Buttons
        self.connect_btn = tk.Button(control_frame, text="ðŸ”— Connect MT5", 
                                   command=self.connect_mt5, bg='#4caf50', fg='white', font=('Arial', 10, 'bold'))
        self.connect_btn.pack(side=tk.LEFT, padx=5)
        
        self.discover_btn = tk.Button(control_frame, text="ðŸ” Discover Instruments", 
                                    command=self.discover_instruments, bg='#2196f3', fg='white', font=('Arial', 10, 'bold'))
        self.discover_btn.pack(side=tk.LEFT, padx=5)
        
        self.feed_btn = tk.Button(control_frame, text="â–¶ Start Feed", 
                                command=self.toggle_feed, bg='#ff9800', fg='white', font=('Arial', 10, 'bold'))
        self.feed_btn.pack(side=tk.LEFT, padx=5)
        
        self.emergency_btn = tk.Button(control_frame, text="ðŸš¨ EMERGENCY STOP", 
                                     command=self.emergency_stop, bg='#f44336', fg='white', font=('Arial', 10, 'bold'))
        self.emergency_btn.pack(side=tk.RIGHT, padx=5)
        
        # Notebook for tabs
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Create tabs
        self.create_market_tab()
        self.create_trading_tab()
        self.create_monitor_tab()
        
        # Status bar
        status_frame = tk.Frame(main_frame, bg='#2b2b2b')
        status_frame.pack(fill=tk.X, pady=5)
        
        self.status_label = tk.Label(status_frame, text="GENESIS Ready - Connect to MT5 to begin", 
                                   bg='#2b2b2b', fg='#00ff00', font=('Courier', 10))
        self.status_label.pack(side=tk.LEFT)
        
        self.time_label = tk.Label(status_frame, text=datetime.now().strftime("%H:%M:%S"), 
                                 bg='#2b2b2b', fg='white', font=('Courier', 10))
        self.time_label.pack(side=tk.RIGHT)
        
        # Update time
        self.update_time()
        
    def create_market_tab(self):
        market_frame = tk.Frame(self.notebook, bg='#2b2b2b')
        self.notebook.add(market_frame, text="ðŸ“Š Market Data")
        
        # Symbol selection
        symbol_frame = tk.Frame(market_frame, bg='#2b2b2b')
        symbol_frame.pack(fill=tk.X, padx=10, pady=5)
        
        tk.Label(symbol_frame, text="Symbol:", bg='#2b2b2b', fg='white', font=('Arial', 10)).pack(side=tk.LEFT)
        
        self.symbol_var = tk.StringVar(value="EURUSD")
        self.symbol_combo = ttk.Combobox(symbol_frame, textvariable=self.symbol_var, 
                                       values=["EURUSD", "GBPUSD", "USDJPY", "AUDUSD", "USDCAD"])
        self.symbol_combo.pack(side=tk.LEFT, padx=5)
        
        # Market data display
        data_frame = tk.Frame(market_frame, bg='#2b2b2b')
        data_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Price display
        price_frame = tk.LabelFrame(data_frame, text="Live Prices", bg='#2b2b2b', fg='white', font=('Arial', 12, 'bold'))
        price_frame.pack(fill=tk.X, pady=5)
        
        self.bid_label = tk.Label(price_frame, text="BID: 0.00000", bg='#2b2b2b', fg='#ff4444', font=('Courier', 16, 'bold'))
        self.bid_label.pack(side=tk.LEFT, padx=20, pady=10)
        
        self.ask_label = tk.Label(price_frame, text="ASK: 0.00000", bg='#2b2b2b', fg='#4444ff', font=('Courier', 16, 'bold'))
        self.ask_label.pack(side=tk.RIGHT, padx=20, pady=10)
        
        # Tick history
        history_frame = tk.LabelFrame(data_frame, text="Tick History", bg='#2b2b2b', fg='white', font=('Arial', 12, 'bold'))
        history_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Treeview for tick data
        columns = ('Time', 'Symbol', 'Bid', 'Ask', 'Spread')
        self.tick_tree = ttk.Treeview(history_frame, columns=columns, show='headings', height=15)
        
        for col in columns:
            self.tick_tree.heading(col, text=col)
            self.tick_tree.column(col, width=100)
            
        scrollbar = ttk.Scrollbar(history_frame, orient=tk.VERTICAL, command=self.tick_tree.yview)
        self.tick_tree.configure(yscrollcommand=scrollbar.set)
        
        self.tick_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
    def create_trading_tab(self):
        trading_frame = tk.Frame(self.notebook, bg='#2b2b2b')
        self.notebook.add(trading_frame, text="ðŸ’¼ Trading")
        
        # Order entry
        order_frame = tk.LabelFrame(trading_frame, text="Order Entry", bg='#2b2b2b', fg='white', font=('Arial', 12, 'bold'))
        order_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # Order controls
        controls = tk.Frame(order_frame, bg='#2b2b2b')
        controls.pack(fill=tk.X, padx=10, pady=10)
        
        tk.Label(controls, text="Symbol:", bg='#2b2b2b', fg='white').grid(row=0, column=0, sticky='w', padx=5)
        self.trade_symbol = ttk.Combobox(controls, values=["EURUSD", "GBPUSD", "USDJPY"])
        self.trade_symbol.set("EURUSD")
        self.trade_symbol.grid(row=0, column=1, padx=5, pady=2)
        
        tk.Label(controls, text="Volume:", bg='#2b2b2b', fg='white').grid(row=1, column=0, sticky='w', padx=5)
        self.volume_var = tk.StringVar(value="0.1")
        volume_entry = tk.Entry(controls, textvariable=self.volume_var, width=10)
        volume_entry.grid(row=1, column=1, padx=5, pady=2)
        
        tk.Label(controls, text="Type:", bg='#2b2b2b', fg='white').grid(row=2, column=0, sticky='w', padx=5)
        self.order_type = ttk.Combobox(controls, values=["Market", "Limit", "Stop"])
        self.order_type.set("Market")
        self.order_type.grid(row=2, column=1, padx=5, pady=2)
        
        # Order buttons
        button_frame = tk.Frame(controls, bg='#2b2b2b')
        button_frame.grid(row=3, column=0, columnspan=2, pady=10)
        
        buy_btn = tk.Button(button_frame, text="BUY", command=lambda: self.place_order("BUY"),
                           bg='#4caf50', fg='white', font=('Arial', 12, 'bold'), width=10)
        buy_btn.pack(side=tk.LEFT, padx=5)
        
        sell_btn = tk.Button(button_frame, text="SELL", command=lambda: self.place_order("SELL"),
                            bg='#f44336', fg='white', font=('Arial', 12, 'bold'), width=10)
        sell_btn.pack(side=tk.LEFT, padx=5)
        
        # Positions
        positions_frame = tk.LabelFrame(trading_frame, text="Open Positions", bg='#2b2b2b', fg='white', font=('Arial', 12, 'bold'))
        positions_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        pos_columns = ('Symbol', 'Type', 'Volume', 'Open Price', 'Current', 'P&L')
        self.positions_tree = ttk.Treeview(positions_frame, columns=pos_columns, show='headings', height=10)
        
        for col in pos_columns:
            self.positions_tree.heading(col, text=col)
            self.positions_tree.column(col, width=100)
            
        self.positions_tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
    def create_monitor_tab(self):
        monitor_frame = tk.Frame(self.notebook, bg='#2b2b2b')
        self.notebook.add(monitor_frame, text="ðŸ“¡ System Monitor")
        
        # Account info
        account_frame = tk.LabelFrame(monitor_frame, text="Account Information", bg='#2b2b2b', fg='white', font=('Arial', 12, 'bold'))
        account_frame.pack(fill=tk.X, padx=10, pady=5)
        
        acc_info = tk.Frame(account_frame, bg='#2b2b2b')
        acc_info.pack(fill=tk.X, padx=10, pady=10)
        
        self.balance_label = tk.Label(acc_info, text="Balance: $0.00", bg='#2b2b2b', fg='#00ff00', font=('Courier', 12, 'bold'))
        self.balance_label.grid(row=0, column=0, sticky='w', padx=10)
        
        self.equity_label = tk.Label(acc_info, text="Equity: $0.00", bg='#2b2b2b', fg='#00ff00', font=('Courier', 12, 'bold'))
        self.equity_label.grid(row=0, column=1, sticky='w', padx=10)
        
        self.margin_label = tk.Label(acc_info, text="Margin: $0.00", bg='#2b2b2b', fg='#ffff00', font=('Courier', 12, 'bold'))
        self.margin_label.grid(row=1, column=0, sticky='w', padx=10)
        
        self.instruments_label = tk.Label(acc_info, text="Instruments: 0", bg='#2b2b2b', fg='white', font=('Courier', 12))
        self.instruments_label.grid(row=1, column=1, sticky='w', padx=10)
        
        # Event log
        log_frame = tk.LabelFrame(monitor_frame, text="System Events", bg='#2b2b2b', fg='white', font=('Arial', 12, 'bold'))
        log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        self.log_text = tk.Text(log_frame, bg='#1a1a1a', fg='#00ff00', font=('Courier', 10), height=20)
        log_scrollbar = ttk.Scrollbar(log_frame, orient=tk.VERTICAL, command=self.log_text.yview)
        self.log_text.configure(yscrollcommand=log_scrollbar.set)
        
        self.log_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        log_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
    def connect_mt5(self):
        try:
            self.log_event("ðŸ”— Initializing MT5 connection...")
            self.status_label.config(text="Connecting to MT5...")
            self.root.update()
            
            # Simulate connection delay
            time.sleep(1)
            
            self.log_event("âœ… MT5 connection established")
            self.status_label.config(text="MT5 Connected - Ready for discovery")
            
            self.connect_btn.config(state='disabled')
            self.discover_btn.config(state='normal')
            
        except Exception as e:
            messagebox.showerror("Connection Error", f"Failed to connect to MT5: {str(e)}")
            self.log_event(f"âŒ MT5 connection failed: {str(e)}")
            
    def discover_instruments(self):
        try:
            self.log_event("ðŸ” Starting instrument discovery...")
            self.status_label.config(text="Discovering instruments...")
            self.root.update()
            
            # Simulate discovery
            instruments = [
                "EURUSD", "GBPUSD", "USDJPY", "AUDUSD", "USDCAD",
                "EURGBP", "EURJPY", "GBPJPY", "NZDUSD", "USDCHF",
                "XAUUSD", "XAGUSD", "USOIL", "UK100", "US30"
            ]
            
            time.sleep(2)  # Simulate discovery time
            
            # Update combos
            self.symbol_combo['values'] = instruments
            self.trade_symbol['values'] = instruments
            
            # Update account info
            self.balance_label.config(text="Balance: $10,000.00")
            self.equity_label.config(text="Equity: $10,000.00")
            self.margin_label.config(text="Margin: $0.00")
            self.instruments_label.config(text=f"Instruments: {len(instruments)}")
            
            self.log_event(f"âœ… Discovery complete: {len(instruments)} instruments found")
            self.status_label.config(text=f"Discovery complete - {len(instruments)} instruments available")
            
            self.feed_btn.config(state='normal')
            
        except Exception as e:
            messagebox.showerror("Discovery Error", f"Instrument discovery failed: {str(e)}")
            self.log_event(f"âŒ Discovery failed: {str(e)}")
            
    def toggle_feed(self):
        if not self.market_running:
            self.start_market_feed()
        else:
            self.stop_market_feed()
            
    def start_market_feed(self):
        try:
            self.market_running = True
            self.feed_btn.config(text="â¹ Stop Feed")
            
            # Start market data thread
            self.market_thread = threading.Thread(target=self.market_data_worker, daemon=True)
            self.market_thread.start()
            
            self.log_event("â–¶ Live market feed started")
            self.status_label.config(text="Live market data streaming...")
            
        except Exception as e:
            messagebox.showerror("Feed Error", f"Failed to start market feed: {str(e)}")
            
    def stop_market_feed(self):
        try:
            self.market_running = False
            self.feed_btn.config(text="â–¶ Start Feed")
            
            self.log_event("â¹ Market feed stopped")
            self.status_label.config(text="Market feed stopped")
            
        except Exception as e:
            messagebox.showerror("Feed Error", f"Failed to stop market feed: {str(e)}")
            
    def market_data_worker(self):
        while self.market_running:
            try:
                symbol = self.symbol_var.get()
                
                # Generate random tick data
                bid = round(random.uniform(1.05, 1.25), 5)
                ask = round(bid + random.uniform(0.0001, 0.003), 5)
                spread = round(ask - bid, 5)
                timestamp = datetime.now().strftime("%H:%M:%S")
                
                # Update main thread
                self.root.after(0, self.update_market_display, timestamp, symbol, bid, ask, spread)
                
                time.sleep(1)  # 1 second updates
                
            except Exception as e:
                self.log_event(f"âŒ Market data error: {str(e)}")
                break
                
    def update_market_display(self, timestamp, symbol, bid, ask, spread):
        try:
            # Update price labels
            self.bid_label.config(text=f"BID: {bid:.5f}")
            self.ask_label.config(text=f"ASK: {ask:.5f}")
            
            # Add to tick history
            self.tick_tree.insert('', 0, values=(timestamp, symbol, f"{bid:.5f}", f"{ask:.5f}", f"{spread:.5f}"))
            
            # Keep only last 100 ticks
            children = self.tick_tree.get_children()
            if len(children) > 100:
                self.tick_tree.delete(children[-1])
                
        except Exception as e:
            self.log_event(f"âŒ Display update error: {str(e)}")
            
    def place_order(self, direction):
        try:
            symbol = self.trade_symbol.get()
            volume = float(self.volume_var.get())
            order_type = self.order_type.get()
            
            # Simulate order placement
            price = round(random.uniform(1.05, 1.25), 5)
            
            # Add to positions
            self.positions_tree.insert('', 0, values=(
                symbol, direction, volume, f"{price:.5f}", f"{price:.5f}", "$0.00"
            ))
            
            self.log_event(f"ðŸ“Š Order placed: {direction} {volume} {symbol} @ {price:.5f}")
            
        except ValueError:
            messagebox.showerror("Order Error", "Invalid volume value")
        except Exception as e:
            messagebox.showerror("Order Error", f"Order placement failed: {str(e)}")
            
    def emergency_stop(self):
        result = messagebox.askyesno("Emergency Stop", 
                                   "This will stop all trading and close positions.\n\nAre you sure?")
        
        if result:
            # Stop market feed
            self.market_running = False
            
            # Clear positions
            for item in self.positions_tree.get_children():
                self.positions_tree.delete(item)
                
            self.log_event("ðŸš¨ EMERGENCY STOP ACTIVATED - All trading halted")
            self.status_label.config(text="ðŸš¨ EMERGENCY STOP - Trading halted")
            
    def log_event(self, message):
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_entry = f"[{timestamp}] {message}\n"
        
        self.log_text.insert(tk.END, log_entry)
        self.log_text.see(tk.END)
        
        # Keep only last 1000 lines
        lines = self.log_text.get("1.0", tk.END).split('\n')
        if len(lines) > 1000:
            self.log_text.delete("1.0", f"{len(lines)-1000}.0")
            
    def update_time(self):
        current_time = datetime.now().strftime("%H:%M:%S")
        self.time_label.config(text=current_time)
        self.root.after(1000, self.update_time)

def main():
    root = tk.Tk()
    app = GenesisTrader(root)
    
    # Center window
    root.update_idletasks()
    x = (root.winfo_screenwidth() - root.winfo_width()) // 2
    y = (root.winfo_screenheight() - root.winfo_height()) // 2
    root.geometry(f"+{x}+{y}")
    
    root.mainloop()

if __name__ == "__main__":
    main()



def emit_event(event_type: str, data: dict) -> None:
    """Emit event to the EventBus"""
    event = Event(event_type=event_type, source=__name__, data=data)
    event_bus.emit(event)
    telemetry.log_event(TelemetryEvent(category="module_event", name=event_type, properties=data))


def check_ftmo_limits(order_volume: float, symbol: str) -> bool:
    """Check order against FTMO trading limits"""
    # Get account info
    account_info = mt5.account_info()
    if account_info is None:
        logging.error("Failed to get account info")
        return False
    
    # Calculate position size as percentage of account
    equity = account_info.equity
    max_risk_percent = 0.05  # 5% max risk per trade (FTMO rule)
    
    # Calculate potential loss
    symbol_info = mt5.symbol_info(symbol)
    if symbol_info is None:
        logging.error(f"Failed to get symbol info for {symbol}")
        return False
    
    # Check if order volume exceeds max risk
    if (order_volume * symbol_info.trade_tick_value) > (equity * max_risk_percent):
        logging.warning(f"Order volume {order_volume} exceeds FTMO risk limit of {equity * max_risk_percent}")
        return False
    
    # Check daily loss limit
    daily_loss_limit = equity * 0.05  # 5% daily loss limit
    
    # Get today's closed positions
    from_date = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
    positions = mt5.history_deals_get(from_date, datetime.now())
    
    daily_pnl = sum([deal.profit for deal in positions if deal.profit < 0])
    
    if abs(daily_pnl) + (order_volume * symbol_info.trade_tick_value) > daily_loss_limit:
        logging.warning(f"Order would breach FTMO daily loss limit. Current loss: {abs(daily_pnl)}")
        return False
    
    return True


def detect_divergence(price_data: list, indicator_data: list, window: int = 10) -> Dict:
    """
    Detect regular and hidden divergences between price and indicator
    
    Args:
        price_data: List of price values (closing prices)
        indicator_data: List of indicator values (e.g., RSI, MACD)
        window: Number of periods to check for divergence
        
    Returns:
        Dictionary with divergence information
    """
    result = {
        "regular_bullish": False,
        "regular_bearish": False,
        "hidden_bullish": False,
        "hidden_bearish": False,
        "strength": 0.0
    }
    
    # Need at least window + 1 periods of data
    if len(price_data) < window + 1 or len(indicator_data) < window + 1:
        return result
        
    # Get the current and historical points
    current_price = price_data[-1]
    previous_price = min(price_data[-window:-1]) if price_data[-1] > price_data[-2] else max(price_data[-window:-1])
    previous_price_idx = price_data[-window:-1].index(previous_price) + len(price_data) - window
    
    current_indicator = indicator_data[-1]
    previous_indicator = indicator_data[previous_price_idx]
    
    # Check for regular divergences
    # Bullish - Lower price lows but higher indicator lows
    if current_price < previous_price and current_indicator > previous_indicator:
        result["regular_bullish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
        
    # Bearish - Higher price highs but lower indicator highs
    elif current_price > previous_price and current_indicator < previous_indicator:
        result["regular_bearish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
    
    # Check for hidden divergences
    # Bullish - Higher price lows but lower indicator lows
    elif current_price > previous_price and current_indicator < previous_indicator:
        result["hidden_bullish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
        
    # Bearish - Lower price highs but higher indicator highs
    elif current_price < previous_price and current_indicator > previous_indicator:
        result["hidden_bearish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
    
    # Emit divergence event if detected
    if any([result["regular_bullish"], result["regular_bearish"], 
            result["hidden_bullish"], result["hidden_bearish"]]):
        emit_event("divergence_detected", {
            "type": next(k for k, v in result.items() if v is True and k != "strength"),
            "strength": result["strength"],
            "symbol": price_data.symbol if hasattr(price_data, "symbol") else "unknown",
            "timestamp": datetime.now().isoformat()
        })
        
    return result


def setup_event_subscriptions(self):
    """Set up EventBus subscriptions for this UI component"""
    event_bus.subscribe("market_data_updated", self.handle_market_data_update)
    event_bus.subscribe("trade_executed", self.handle_trade_update)
    event_bus.subscribe("position_changed", self.handle_position_update)
    event_bus.subscribe("risk_threshold_warning", self.handle_risk_warning)
    event_bus.subscribe("system_status_changed", self.handle_system_status_update)
    
    # Register with telemetry
    telemetry.log_event(TelemetryEvent(
        category="ui", 
        name="event_subscriptions_setup", 
        properties={"component": self.__class__.__name__}
    ))
