# <!-- @GENESIS_MODULE_START: phase11_focused_test -->

from datetime import datetime\n"""

# 📊 GENESIS Telemetry Integration - Auto-injected by Complete Intelligent Wiring Engine
try:
    from core.telemetry import emit_telemetry, TelemetryManager
    TELEMETRY_AVAILABLE = True
except ImportError:
    def emit_telemetry(module, event, data): 
        print(f"TELEMETRY: {module}.{event} - {data}")
    class TelemetryManager:
        def emergency_stop(self, reason: str = "Manual trigger") -> bool:
                """GENESIS Emergency Kill Switch"""
                try:
                    # Emit emergency event
                    if hasattr(self, 'event_bus') and self.event_bus:
                        emit_event("emergency_stop", {
                            "module": "phase11_focused_test_recovered_2",
                            "reason": reason,
                            "timestamp": datetime.now().isoformat()
                        })

                    # Log telemetry
                    self.emit_module_telemetry("emergency_stop", {
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                    # Set emergency state
                    if hasattr(self, '_emergency_stop_active'):
                        self._emergency_stop_active = True

                    return True
                except Exception as e:
                    print(f"Emergency stop error in phase11_focused_test_recovered_2: {e}")
                    return False
        def validate_ftmo_compliance(self, trade_data: dict) -> bool:
                """GENESIS FTMO Compliance Validator"""
                # Daily drawdown check (5%)
                daily_loss = trade_data.get('daily_loss_pct', 0)
                if daily_loss > 5.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "daily_drawdown", 
                        "value": daily_loss,
                        "threshold": 5.0
                    })
                    return False

                # Maximum drawdown check (10%)
                max_drawdown = trade_data.get('max_drawdown_pct', 0)
                if max_drawdown > 10.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "max_drawdown", 
                        "value": max_drawdown,
                        "threshold": 10.0
                    })
                    return False

                # Risk per trade check (2%)
                risk_pct = trade_data.get('risk_percent', 0)
                if risk_pct > 2.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "risk_exceeded", 
                        "value": risk_pct,
                        "threshold": 2.0
                    })
                    return False

                return True
        def emit_module_telemetry(self, event: str, data: dict = None):
                """GENESIS Module Telemetry Hook"""
                telemetry_data = {
                    "timestamp": datetime.now().isoformat(),
                    "module": "phase11_focused_test_recovered_2",
                    "event": event,
                    "data": data or {}
                }
                try:
                    emit_telemetry("phase11_focused_test_recovered_2", event, telemetry_data)
                except Exception as e:
                    print(f"Telemetry error in phase11_focused_test_recovered_2: {e}")
        def emit(self, event, data): pass
    TELEMETRY_AVAILABLE = False



# 🔗 GENESIS EventBus Integration - Auto-injected by Complete Intelligent Wiring Engine
try:
    from core.hardened_event_bus import get_event_bus, emit_event, register_route
    EVENTBUS_AVAILABLE = True
except ImportError:
    # Fallback implementation
    def get_event_bus(): return None
    def emit_event(event, data): print(f"EVENT: {event} - {data}")
    def register_route(route, producer, consumer): pass
    EVENTBUS_AVAILABLE = False




# Initialize EventBus connection
event_bus = EventBus.get_instance()
telemetry = TelemetryManager.get_instance()

GENESIS PHASE 11: META-BIAS OVERRIDE FOCUSED TEST
ARCHITECT MODE v2.7 COMPLIANT

Creates identical patterns to trigger bias override thresholds and test all Phase 11 functionality.
"""

import json
import datetime
from typing import Dict, List

from pattern_meta_strategy_engine import PatternMetaStrategyEngine


def test_phase_11_bias_override_focused():
    """Test with identical patterns to trigger bias overrides"""
    print("🧠 GENESIS PHASE 11: FOCUSED META-BIAS OVERRIDE TEST")
    print("Creating identical patterns to trigger bias override threshold...")
    print("="*60)
    
    try:
        # Create 25 identical high-performing patterns to trigger bias override
        identical_trades = create_identical_pattern_trades()
        
        print(f"📊 Created {len(identical_trades)} identical high-performing trades")
        
        # Initialize engine
        engine = PatternMetaStrategyEngine()
        
        # Lower threshold for testing
        engine.min_pattern_occurrences = 5  # Lower for testing
        engine.bias_override_threshold = 0.70  # 70% win rate
        
        print("🧠 Running focused meta-pattern analysis...")
        analysis_result = engine.analyze_pattern_performance(identical_trades)
        
        # Display results
        print("\n✅ PHASE 11: FOCUSED META-BIAS OVERRIDE COMPLETE")
        print(f"📊 Patterns analyzed: {analysis_result.get('total_patterns_analyzed', 0)}")
        print(f"🎯 Bias overrides issued: {analysis_result.get('bias_overrides_issued', 0)}")
        print(f"🔧 Calibration requests: {analysis_result.get('calibration_requests', 0)}")
        
        # Verify pattern registry
        verify_detailed_pattern_registry()
        
        # Test specific pattern cluster analysis
        test_individual_pattern_analysis(engine, identical_trades)
        
        if analysis_result.get('bias_overrides_issued', 0) > 0:
            print("\n🎯 SUCCESS: Bias overrides were successfully issued!")
            print("✅ PHASE 11: META-BIAS OVERRIDE FUNCTIONALITY VALIDATED")
        else:
            print("\n⚠️ No bias overrides issued - checking pattern clustering...")
            debug_pattern_clustering(engine, identical_trades)
        
        return analysis_result
        
    except Exception as e:
        print(f"❌ PHASE 11: Focused test failed: {e}")
        return {"error": str(e)}


def create_identical_pattern_trades() -> List[Dict]:
    """Create identical trades to ensure pattern clustering works"""
    base_time = datetime.datetime.now() - datetime.timedelta(days=30)
    identical_trades = []
    
    # Create 25 identical high-performing EURUSD trades
    for i in range(25):
        trade = {
            "trade_id": f"IDENTICAL_{i:03d}",
            "timestamp": (base_time + datetime.timedelta(hours=i*2)).isoformat(),
            "symbol": "EURUSD",
            "ohlc_data": {
                "open": 1.0850,
                "high": 1.0875,
                "low": 1.0845,
                "close": 1.0867,
                "volume": 15000
            },
            "indicators": {
                "macd_signal": "BULLISH_CROSS",
                "stochrsi_state": "OVERSOLD_REVERSAL", 
                "ob_pattern": "COMPRESSION_BREAK",
                "macd_histogram": 0.0015,
                "stochrsi_k": 25.4,
                "stochrsi_d": 22.1
            },
            "sl_tp_ratio": 1.5,
            "killzone_hour": 8,
            "is_profitable": True if i < 20 else False,  # 80% win rate
            "tp_ratio": 1.8 if i < 20 else 0.0,
            "sl_ratio": 0.0 if i < 20 else 1.0,
            "slippage": 0.2,
            "entry_price": 1.0850,
            "exit_price": 1.0868 if i < 20 else 1.0835,
            "pnl": 180.0 if i < 20 else -150.0,
            "trade_duration_minutes": 45
        }
        identical_trades.append(trade)
    
    return identical_trades


def verify_detailed_pattern_registry():
    """Detailed verification of pattern registry"""
    try:
        with open("pattern_registry.json", 'r') as f:
            registry_data = json.load(f)
        
        patterns = registry_data.get("patterns", {})
        print(f"\n📊 Pattern Registry Analysis:")
        print(f"   - Total patterns: {len(patterns)}")
        print(f"   - Registry metadata: {registry_data.get('metadata', {}).get('total_patterns', 0)} patterns processed")
        
        if patterns:
            for pattern_id, pattern_data in patterns.items():
                print(f"\n🔍 Pattern {pattern_id[:8]}:")
                print(f"   - Occurrences: {pattern_data.get('total_occurrences', 0)}")
                print(f"   - Win rate: {pattern_data.get('win_rate', 0):.1%}")
                print(f"   - Performance score: {pattern_data.get('performance_score', 0):.3f}")
                print(f"   - Bias override eligible: {pattern_data.get('bias_override_eligible', False)}")
                print(f"   - Volatility cluster: {pattern_data.get('volatility_cluster', 'UNKNOWN')}")
        else:
            print("   - No patterns stored in registry")
            
    except Exception as e:
        print(f"❌ Error verifying pattern registry: {e}")


def test_individual_pattern_analysis(engine, trades):
    """Test individual pattern analysis components"""
    print(f"\n🔧 Testing Individual Pattern Analysis Components:")
    
    # Test pattern hash generation for first trade
    live_trade = trades[0]
    pattern_hash = engine._generate_pattern_hash(live_trade)
    print(f"✅ Pattern Hash: {pattern_hash.ohlc_hash}")
    
    # Test performance extraction
    performance = engine._extract_performance_metrics(live_trade)
    print(f"✅ Performance extraction: Profitable={performance['is_profitable']}, TP={performance['tp_ratio']}")
    
    # Test cluster performance calculation
    mock_trades = []
    for trade in trades[:10]:
        mock_trades.append({
            'trade': trade,
            'hash': pattern_hash,  # Same hash for clustering
            'performance': engine._extract_performance_metrics(trade)
        })
    
    cluster_perf = engine._calculate_cluster_performance(mock_trades)
    print(f"✅ Cluster Performance: {cluster_perf.get('win_rate', 0):.1%} win rate, {cluster_perf.get('total_trades', 0)} trades")
    
    # Test bias override generation
    if cluster_perf.get('win_rate', 0) >= 0.70:
        override_signal = engine._generate_bias_override("TEST_PATTERN", mock_trades, cluster_perf)
        print(f"✅ Bias Override Generated: {override_signal.bias} with {override_signal.confidence:.1%} confidence")
    else:
        print(f"⚠️ Win rate {cluster_perf.get('win_rate', 0):.1%} below 70% threshold for bias override")


def debug_pattern_clustering(engine, trades):
    """Debug why pattern clustering might not be working"""
    print(f"\n🔍 Debugging Pattern Clustering:")
    
    # Check if trades generate same hash
    hashes = []
    for trade in trades[:5]:
        pattern_hash = engine._generate_pattern_hash(trade)
        hashes.append(pattern_hash.ohlc_hash)
    
    print(f"   - Sample pattern hashes: {hashes}")
    print(f"   - All identical: {len(set(hashes)) == 1}")
    
    # Check minimum occurrence threshold
    print(f"   - Min pattern occurrences threshold: {engine.min_pattern_occurrences}")
    print(f"   - Bias override threshold: {engine.bias_override_threshold}")
    
    # Manual clustering test
    from collections import defaultdict

from hardened_event_bus import EventBus, Event
    pattern_clusters = defaultdict(list)
    
    for trade in trades:
        pattern_hash = engine._generate_pattern_hash(trade)
        pattern_clusters[pattern_hash.ohlc_hash].append(trade)
    
    print(f"   - Pattern clusters found: {len(pattern_clusters)}")
    for cluster_id, cluster_trades in pattern_clusters.items():
        print(f"     * Cluster {cluster_id[:8]}: {len(cluster_trades)} trades")
        
        if len(cluster_trades) >= engine.min_pattern_occurrences:
            print(f"       - Meets minimum threshold ✅")
            # Calculate win rate
            profitable = sum(1 for t in cluster_trades if t['is_profitable'])
            win_rate = profitable / len(cluster_trades)
            print(f"       - Win rate: {win_rate:.1%}")
            
            if win_rate >= engine.bias_override_threshold:
                print(f"       - Bias override threshold met ✅")
            else:
                print(f"       - Win rate below {engine.bias_override_threshold:.1%} threshold ❌")
        else:
            print(f"       - Below minimum threshold of {engine.min_pattern_occurrences} ❌")


if __name__ == "__main__":
    """PHASE 11: Focused bias override test"""
    test_phase_11_bias_override_focused()


# <!-- @GENESIS_MODULE_END: phase11_focused_test -->


def emit_event(event_type: str, data: dict) -> None:
    """Emit event to the EventBus"""
    event = Event(event_type=event_type, source=__name__, data=data)
    event_bus.emit(event)
    telemetry.log_event(TelemetryEvent(category="module_event", name=event_type, properties=data))


def detect_divergence(price_data: list, indicator_data: list, window: int = 10) -> Dict:
    """
    Detect regular and hidden divergences between price and indicator
    
    Args:
        price_data: List of price values (closing prices)
        indicator_data: List of indicator values (e.g., RSI, MACD)
        window: Number of periods to check for divergence
        
    Returns:
        Dictionary with divergence information
    """
    result = {
        "regular_bullish": False,
        "regular_bearish": False,
        "hidden_bullish": False,
        "hidden_bearish": False,
        "strength": 0.0
    }
    
    # Need at least window + 1 periods of data
    if len(price_data) < window + 1 or len(indicator_data) < window + 1:
        return result
        
    # Get the current and historical points
    current_price = price_data[-1]
    previous_price = min(price_data[-window:-1]) if price_data[-1] > price_data[-2] else max(price_data[-window:-1])
    previous_price_idx = price_data[-window:-1].index(previous_price) + len(price_data) - window
    
    current_indicator = indicator_data[-1]
    previous_indicator = indicator_data[previous_price_idx]
    
    # Check for regular divergences
    # Bullish - Lower price lows but higher indicator lows
    if current_price < previous_price and current_indicator > previous_indicator:
        result["regular_bullish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
        
    # Bearish - Higher price highs but lower indicator highs
    elif current_price > previous_price and current_indicator < previous_indicator:
        result["regular_bearish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
    
    # Check for hidden divergences
    # Bullish - Higher price lows but lower indicator lows
    elif current_price > previous_price and current_indicator < previous_indicator:
        result["hidden_bullish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
        
    # Bearish - Lower price highs but higher indicator highs
    elif current_price < previous_price and current_indicator > previous_indicator:
        result["hidden_bearish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
    
    # Emit divergence event if detected
    if any([result["regular_bullish"], result["regular_bearish"], 
            result["hidden_bullish"], result["hidden_bearish"]]):
        emit_event("divergence_detected", {
            "type": next(k for k, v in result.items() if v is True and k != "strength"),
            "strength": result["strength"],
            "symbol": price_data.symbol if hasattr(price_data, "symbol") else "unknown",
            "timestamp": datetime.now().isoformat()
        })
        
    return result


def setup_event_subscriptions(self):
    """Set up EventBus subscriptions for this UI component"""
    event_bus.subscribe("market_data_updated", self.handle_market_data_update)
    event_bus.subscribe("trade_executed", self.handle_trade_update)
    event_bus.subscribe("position_changed", self.handle_position_update)
    event_bus.subscribe("risk_threshold_warning", self.handle_risk_warning)
    event_bus.subscribe("system_status_changed", self.handle_system_status_update)
    
    # Register with telemetry
    telemetry.log_event(TelemetryEvent(
        category="ui", 
        name="event_subscriptions_setup", 
        properties={"component": self.__class__.__name__}
    ))
