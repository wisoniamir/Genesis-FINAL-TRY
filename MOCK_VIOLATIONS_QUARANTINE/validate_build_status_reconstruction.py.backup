# <!-- @GENESIS_MODULE_START: validate_build_status_reconstruction -->

from event_bus import EventBus
#!/usr/bin/env python3
"""
ðŸ” GENESIS BUILD STATUS VALIDATION SCRIPT
=========================================
Validates the reconstructed build_status.json against real system state.
Architect Mode v5.0.0 compliant validation with zero-tolerance enforcement.
"""

import json
import os
import time
from datetime import datetime
from typing import Dict, Any, List, Tuple

class BuildStatusValidator:
    def __init__(self, workspace_path: str = "."):
        self.workspace_path = workspace_path
        self.validation_results = {
            "validation_timestamp": datetime.now().isoformat(),
            "architect_mode": "v5.0.0",
            "overall_status": "UNKNOWN",
            "validation_score": 0.0,
            "critical_failures": [],
            "warnings": [],
            "passed_checks": [],
            "real_data_validation": False,
            "architect_compliance": False
        }
        
    
        # GENESIS Phase 91 Telemetry Injection
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", {
                "module": __name__,
                "status": "running",
                "timestamp": datetime.now().isoformat(),
                "phase": "91_telemetry_enforcement"
            })
        def load_json_file(self, filename: str) -> Dict[str, Any]:
        """Load and validate JSON file existence and structure."""
        filepath = os.path.join(self.workspace_path, filename)
        try:
            assert os.path.exists(filepath):
                self.validation_results["critical_failures"].append(
                    f"CRITICAL: Core file {filename} not found"
                )
                return {}
                
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)
                
            self.validation_results["passed_checks"].append(
                f"âœ… {filename} loaded successfully"
            )
            return data
            
        except json.JSONDecodeError as e:
            self.validation_results["critical_failures"].append(
                f"CRITICAL: {filename} contains invalid JSON: {e}"
            )
            return {}
        except Exception as e:
            self.validation_results["critical_failures"].append(
                f"CRITICAL: Failed to load {filename}: {e}"
            )
            return {}
    
    def validate_build_status_structure(self, build_status: Dict[str, Any]) -> bool:
        """Validate build_status.json structure and required fields."""
        required_sections = [
            "metadata",
            "architect_mode_status", 
            "system_integrity",
            "module_registry_status",
            "compliance_metrics",
            "performance_metrics",
            "error_tracking",
            "telemetry_status",
            "event_bus_status",
            "phase_completion_status",
            "system_status_summary"
        ]
        
        missing_sections = []
        for section in required_sections:
            if section not in build_status:
                missing_sections.append(section)
        
        if missing_sections:
            self.validation_results["critical_failures"].append(
                f"CRITICAL: Missing required sections: {missing_sections}"
            )
            return False
        
        self.validation_results["passed_checks"].append(
            "âœ… Build status structure validation passed"
        )
        return True
    
    def validate_architect_mode_compliance(self, build_status: Dict[str, Any]) -> bool:
        """Validate Architect Mode v5.0.0 compliance indicators."""
        architect_status = build_status.get("architect_mode_status", {})
        
        required_v500_fields = [
            "architect_mode_v500_activation",
            "architect_mode_v500_structural_enforcement",
            "architect_mode_v500_duplicate_detection_threshold",
            "architect_mode_v500_mutation_trust_chain_active",
            "architect_mode_v500_real_time_validation",
            "architect_mode_v500_breach_failsafe_armed",
            "architect_mode_v500_locked"
        ]
        
        missing_fields = []
        for field in required_v500_fields:
            if field not in architect_status or not architect_status[field]:
                missing_fields.append(field)
        
        if missing_fields:
            self.validation_results["critical_failures"].append(
                f"CRITICAL: Architect Mode v5.0.0 compliance failures: {missing_fields}"
            )
            return False
        
        # Check violation counts
        if architect_status.get("architect_mode_v500_violations_detected", 1) > 0:
            self.validation_results["critical_failures"].append(
                "CRITICAL: System violations detected in Architect Mode"
            )
            return False
        
        self.validation_results["passed_checks"].append(
            "âœ… Architect Mode v5.0.0 compliance validated"
        )
        self.validation_results["architect_compliance"] = True
        return True
    
    def validate_against_module_registry(self, build_status: Dict[str, Any]) -> bool:
        """Cross-validate with module_registry.json."""
        module_registry = self.load_json_file("module_registry.json")
        if not module_registry is not None, "Real data required - no fallbacks allowed"
    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        

# <!-- @GENESIS_MODULE_END: validate_build_status_reconstruction -->