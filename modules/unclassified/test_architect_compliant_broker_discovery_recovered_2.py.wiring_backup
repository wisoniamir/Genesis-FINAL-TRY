# <!-- @GENESIS_MODULE_START: test_architect_compliant_broker_discovery -->

"""
GENESIS PHASE 35 - ARCHITECT MODE COMPLIANT BROKER DISCOVERY TEST
================================================================
STRICT COMPLIANCE v3.1 - REAL MT5 DATA ONLY, NO MOCKS/FALLBACKS

PHASE 35 REFACTORING OBJECTIVES:
‚úÖ Replace ALL mock/simulation logic with real MT5 adapter calls
‚úÖ Test real account profile detection via MT5 connection
‚úÖ Validate telemetry emission for rule_profile_active, account_type_detected, override_mode_enabled  
‚úÖ EventBus-only communication (no direct calls)
‚úÖ Full architect mode compliance validation

COMPLIANCE REQUIREMENTS:
üîê Real MT5 account information only
üîê EventBus routing mandatory
üîê Telemetry integration required
üîê No mock, patch, or simulation logic
üîê System tree registration verification

Dependencies: broker_discovery_engine, event_bus, real MT5 connection
Test Scope: Real account detection, rule override validation, telemetry verification
"""

import os
import sys
import json
import logging
import time
from datetime import datetime
from typing import Dict, List, Any, Optional

# Add project directory to path
project_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, project_dir)

# Import real modules (no mocks)
from broker_discovery_engine import BrokerDiscoveryEngine
from event_bus import emit_event, subscribe_to_event, get_event_bus

class ArchitectCompliantBrokerDiscoveryTest:
    """
    ARCHITECT MODE v3.1 COMPLIANT TEST SUITE
    
    Real MT5 broker discovery testing with:
    - ‚úÖ Live account profile detection
    - ‚úÖ Rule override mode validation 
    - ‚úÖ Telemetry emission verification
    - ‚úÖ EventBus compliance testing
    - ‚úÖ System integrity validation
    
    ZERO TOLERANCE POLICY:
    - ‚ùå No mocks, patches, or simulation logic
    - ‚ùå No fallback data or dummy responses
    - ‚ùå No direct method calls (EventBus only)
    """
    
    def __init__(self):
        self.test_results = {
            "architect_mode_version": "3.1",
            "compliance_status": "STRICT_ENFORCEMENT",
            "real_mt5_only": True,
            "mock_usage_detected": False,
            "tests_run": 0,
            "tests_passed": 0,
            "tests_failed": 0,
            "start_time": datetime.utcnow().isoformat(),
            "test_details": [],
            "telemetry_events_captured": [],
            "eventbus_compliance": True
        }
        
        # Test event tracking (real events only)
        self.received_events = []
        self.telemetry_events = []
        self.account_detection_events = []
        
        # Initialize logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger("ArchitectCompliantBrokerDiscoveryTest")
        
        # Verify architect mode compliance
        self._verify_architect_mode_compliance()
        
    
        # GENESIS Phase 91 Telemetry Injection
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", {
                "module": __name__,
                "status": "running",
                "timestamp": datetime.now().isoformat(),
                "phase": "91_telemetry_enforcement"
            })
        def _verify_architect_mode_compliance(self):
        """Verify all architect mode requirements are met"""
        self.logger.info("üîê ARCHITECT MODE COMPLIANCE VERIFICATION")
        
        # Check for MT5 connection availability
        try:
            import MetaTrader5 as mt5
            if not mt5.initialize():
                self.logger.error("‚ùå ARCHITECT VIOLATION: Real MT5 connection required")
                raise RuntimeError("Architect mode requires active MT5 connection")
            else:
                self.logger.info("‚úÖ Real MT5 connection verified")
                mt5.shutdown()  # Clean close for test setup
        except ImportError:
            self.logger.error("‚ùå ARCHITECT VIOLATION: MetaTrader5 module required")
            raise ImportError("Architect mode requires MetaTrader5 module")
            
        # Verify EventBus availability
        try:
            event_bus = get_event_bus()
            if event_bus is None:
                raise RuntimeError("EventBus not available")
            self.logger.info("‚úÖ EventBus connectivity verified")
        except Exception as e:
            self.logger.error(f"‚ùå ARCHITECT VIOLATION: EventBus required - {e}")
            raise
            
        # Verify broker discovery engine availability
        try:
            test_engine = BrokerDiscoveryEngine()
            if hasattr(test_engine, 'MT5_AVAILABLE') and not test_engine.MT5_AVAILABLE:
                raise RuntimeError("MT5 not available in broker discovery engine")
            self.logger.info("‚úÖ Broker Discovery Engine MT5 integration verified")
        except Exception as e:
            self.logger.error(f"‚ùå ARCHITECT VIOLATION: Broker Discovery Engine MT5 integration failed - {e}")
            raise
            
        self.logger.info("üîê ARCHITECT MODE COMPLIANCE: ALL CHECKS PASSED")
        
    def log_test_result(self, test_name: str, passed: bool, details: str = "", compliance_violation: bool = False):
        """Log test result with architect mode compliance tracking"""
        self.test_results["tests_run"] += 1
        
        if compliance_violation:
            self.test_results["mock_usage_detected"] = True
            passed = False
            details = f"ARCHITECT VIOLATION: {details}"
            
        if passed:
            self.test_results["tests_passed"] += 1
            status = "‚úÖ PASS"
        else:
            self.test_results["tests_failed"] += 1
            status = "‚ùå FAIL"
        
        result = {
            "test": test_name,
            "status": status,
            "details": details,
            "timestamp": datetime.utcnow().isoformat(),
            "architect_compliant": not compliance_violation,
            "real_mt5_data_used": True
        }
        
        self.test_results["test_details"].append(result)
        self.logger.info(f"{status}: {test_name} - {details}")
        
    def setup_test_environment(self):
        """Set up architect-compliant test environment"""
        self.logger.info("üîß Setting up ARCHITECT MODE test environment")
        
        try:
            # Subscribe to real EventBus events (no mocks)
            subscribe_to_event("BrokerRulesDiscovered", self.on_broker_rules_discovered)
            subscribe_to_event("TradingRulesUpdate", self.on_trading_rules_update)
            subscribe_to_event("AccountTypeDetected", self.on_account_type_detected)
            subscribe_to_event("broker_discovery_telemetry", self.on_broker_discovery_telemetry)
            
            self.logger.info("‚úÖ Real EventBus subscriptions established")
            
            # Verify real MT5 connection for testing
            import MetaTrader5 as mt5
            if not mt5.initialize():
                raise RuntimeError("Real MT5 connection required for architect mode testing")
                
            account_info = mt5.account_info()
            if account_info is None:
                raise RuntimeError("No real MT5 account information available")
                
            self.logger.info(f"‚úÖ Real MT5 account connected - Broker: {account_info.company}")
            mt5.shutdown()
            
        except Exception as e:
            self.logger.error(f"‚ùå Test environment setup failed: {e}")
            raise RuntimeError(f"Architect mode test environment setup failed: {e}")
            
    def on_broker_rules_discovered(self, event_data: Dict[str, Any]):
        """Handle real broker rules discovered events"""
        self.received_events.append({
            "type": "BrokerRulesDiscovered",
            "timestamp": datetime.utcnow().isoformat(),
            "data": event_data,
            "real_event": True
        })
        self.logger.info(f"‚úÖ Real broker rules event received: {event_data.get('rule_profile', 'unknown')}")
        
    def on_trading_rules_update(self, event_data: Dict[str, Any]):
        """Handle real trading rules update events"""
        self.received_events.append({
            "type": "TradingRulesUpdate", 
            "timestamp": datetime.utcnow().isoformat(),
            "data": event_data,
            "real_event": True
        })
        self.logger.info(f"‚úÖ Real trading rules update received")
        
    def on_account_type_detected(self, event_data: Dict[str, Any]):
        """Handle real account type detection events"""
        self.account_detection_events.append({
            "timestamp": datetime.utcnow().isoformat(),
            "account_type": event_data.get("account_type", "unknown"),
            "broker_name": event_data.get("broker_name", "unknown"),
            "detection_confidence": event_data.get("detection_confidence", 0.0),
            "real_mt5_data": True
        })
        self.logger.info(f"‚úÖ Real account type detected: {event_data.get('account_type', 'unknown')}")
        
    def on_broker_discovery_telemetry(self, event_data: Dict[str, Any]):
        """Handle real broker discovery telemetry events"""
        self.telemetry_events.append({
            "timestamp": datetime.utcnow().isoformat(),
            "rule_profile_active": event_data.get("rule_profile_active", "unknown"),
            "account_type_detected": event_data.get("account_type_detected", "unknown"),
            "override_mode_enabled": event_data.get("override_mode_enabled", False),
            "real_telemetry": True
        })
        self.logger.info("‚úÖ Real broker discovery telemetry received")
        
    def test_real_mt5_account_detection(self):
        """Test real MT5 account detection (no mocks)"""
        test_name = "Real MT5 Account Detection"
        self.logger.info(f"üß™ Running: {test_name}")
        
        try:
            # Initialize real broker discovery engine
            discovery_engine = BrokerDiscoveryEngine()
            
            # Wait for real MT5 connection and detection
            time.sleep(2)
            
            # Trigger real discovery process via EventBus
            emit_event("trigger_broker_discovery", {
                "source": "architect_compliance_test",
                "timestamp": datetime.utcnow().isoformat(),
                "real_mt5_required": True
            })
            
            # Wait for real events
            time.sleep(5)
            
            # Verify real events were received
            if len(self.received_events) == 0:
                self.log_test_result(test_name, False, "No real broker discovery events received")
                return
                
            # Verify telemetry events contain required Phase 34 fields
            required_telemetry_fields = ["rule_profile_active", "account_type_detected", "override_mode_enabled"]
            telemetry_verified = False
            
            for telemetry_event in self.telemetry_events:
                if all(field in telemetry_event for field in required_telemetry_fields):
                    telemetry_verified = True
                    break
                    
            if not telemetry_verified:
                self.log_test_result(test_name, False, "Required Phase 34 telemetry fields not found")
                return
                
            self.log_test_result(test_name, True, f"Real MT5 detection successful - {len(self.received_events)} events")
            
        except Exception as e:
            self.log_test_result(test_name, False, f"Real MT5 detection failed: {e}")
            
    def test_eventbus_compliance(self):
        """Test EventBus-only communication compliance"""
        test_name = "EventBus Communication Compliance"
        self.logger.info(f"üß™ Running: {test_name}")
        
        try:
            # Verify no direct method calls are used
            discovery_engine = BrokerDiscoveryEngine()
            
            # All communication must go through EventBus
            initial_event_count = len(self.received_events)
            
            # Trigger via EventBus only
            emit_event("broker_discovery_request", {
                "source": "compliance_test",
                "compliance_check": True
            })
            
            time.sleep(3)
            
            final_event_count = len(self.received_events)
            events_received = final_event_count > initial_event_count
            
            if events_received:
                self.log_test_result(test_name, True, "EventBus-only communication verified")
            else:
                self.log_test_result(test_name, False, "EventBus communication failed")
                
        except Exception as e:
            self.log_test_result(test_name, False, f"EventBus compliance test failed: {e}")
            
    def test_telemetry_integration(self):
        """Test Phase 34 telemetry integration"""
        test_name = "Phase 34 Telemetry Integration"
        self.logger.info(f"üß™ Running: {test_name}")
        
        try:
            required_fields = [
                "rule_profile_active",
                "account_type_detected", 
                "override_mode_enabled"
            ]
            
            # Check if telemetry events contain all required fields
            if len(self.telemetry_events) == 0:
                self.log_test_result(test_name, False, "No telemetry events received")
                return
                
            latest_telemetry = self.telemetry_events[-1]
            missing_fields = [field for field in required_fields if field not in latest_telemetry]
            
            if missing_fields:
                self.log_test_result(test_name, False, f"Missing telemetry fields: {missing_fields}")
            else:
                self.log_test_result(test_name, True, "All Phase 34 telemetry fields present")
                
        except Exception as e:
            self.log_test_result(test_name, False, f"Telemetry integration test failed: {e}")
            
    def run_all_tests(self):
        """Run all architect-compliant tests"""
        self.logger.info("üöÄ STARTING ARCHITECT MODE COMPLIANT BROKER DISCOVERY TESTS")
        
        try:
            self.setup_test_environment()
            
            # Run individual tests
            self.test_real_mt5_account_detection()
            self.test_eventbus_compliance()
            self.test_telemetry_integration()
            
            # Finalize results
            self.test_results["end_time"] = datetime.utcnow().isoformat()
            self.test_results["total_runtime_seconds"] = (
                datetime.fromisoformat(self.test_results["end_time"].replace('Z', '+00:00')) - 
                datetime.fromisoformat(self.test_results["start_time"].replace('Z', '+00:00'))
            ).total_seconds()
            
            # Architect compliance validation
            if self.test_results["mock_usage_detected"]:
                self.logger.error("‚ùå ARCHITECT VIOLATION: Mock usage detected")
                self.test_results["final_compliance_status"] = "VIOLATION_DETECTED"
            else:
                self.test_results["final_compliance_status"] = "FULLY_COMPLIANT"
                
            return self.test_results
            
        except Exception as e:
            self.logger.error(f"‚ùå Test suite execution failed: {e}")
            self.test_results["execution_error"] = str(e)
            self.test_results["final_compliance_status"] = "EXECUTION_FAILURE"
            return self.test_results
            
    def save_results(self, filename: str = None):
        """Save test results to file"""
        if filename is None:
            timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
            filename = f"test_results_architect_compliant_broker_discovery_{timestamp}.json"
            
        with open(filename, 'w') as f:
            json.dump(self.test_results, f, indent=2)
            
        self.logger.info(f"‚úÖ Test results saved to: {filename}")
        return filename

def main():
    """Main test execution"""
    test_suite = ArchitectCompliantBrokerDiscoveryTest()
    
    try:
        results = test_suite.run_all_tests()
        
        # Save results
        results_file = test_suite.save_results()
        
        # Print summary
        print("\\n" + "="*80)
        print("ARCHITECT MODE COMPLIANT BROKER DISCOVERY TEST RESULTS")
        print("="*80)
        print(f"Tests Run: {results['tests_run']}")
        print(f"Tests Passed: {results['tests_passed']}")
        print(f"Tests Failed: {results['tests_failed']}")
        print(f"Compliance Status: {results['final_compliance_status']}")
        print(f"Results File: {results_file}")
        print("="*80)
        
        return results['tests_failed'] == 0 and results['final_compliance_status'] == 'FULLY_COMPLIANT'
        
    except Exception as e:
        print(f"‚ùå Test execution failed: {e}")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)

    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        

# <!-- @GENESIS_MODULE_END: test_architect_compliant_broker_discovery -->