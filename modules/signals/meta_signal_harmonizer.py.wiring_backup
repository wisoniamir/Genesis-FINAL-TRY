# <!-- @GENESIS_MODULE_START: meta_signal_harmonizer -->

from datetime import datetime\n#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GENESIS AI TRADING BOT SYSTEM - PHASE 18
MetaSignalHarmonizer - Multi-source signal stream merger and harmonization engine
ARCHITECT MODE: v2.7

This module merges and harmonizes multi-source signal streams from the GENESIS engine
to emit one high-confidence, conflict-free execution signal.

COMPLIANCE REQUIREMENTS:
✅ NO fallback/simplified logic  
✅ NO local storage/state mutation
✅ Use real data only
✅ Use event_bus routing exclusively
✅ Enable full telemetry + logging

Signal Sources:
- SignalConfidenceRated (from SignalConfidenceRatingEngine)
- PatternSignalDetected (from PatternMetaStrategyEngine)
- LiveExecutionFeedback (from SmartExecutionLiveLoop)
- TradeJournalEntry (from TradeJournalEngine)

Output Signals:
- UnifiedExecutionSignal (final_score ≥ 0.75)
- MetaSignalAuditTrail (0.4 ≤ score < 0.75)
- SignalConflictDetected (signal disagreement > 2 levels)
- SignalHarmonyMetric (hourly)
"""

import os
import sys
import json
import logging
import datetime
import statistics
import time
import threading
from pathlib import Path
from collections import defaultdict, deque
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, asdict

# Add parent directory to path to import event_bus
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from event_bus import get_event_bus, register_route, emit_event, subscribe_to_event

@dataclass
class SignalInput:
    """Standardized signal input structure"""
    source: str
    signal_id: str
    confidence: float
    bias: str  # 'BUY' or 'SELL'
    timestamp: str
    metadata: Dict[str, Any]

@dataclass
class UnifiedExecutionSignal:
    """High-confidence unified execution signal"""
    signal_id: str
    final_score: float
    bias: str
    confidence_sources: Dict[str, float]
    contributing_signals: List[str]
    timestamp: str
    execution_ready: bool = True

@dataclass
class MetaSignalAuditTrail:
    """Mid-confidence signal audit trail"""
    signal_id: str
    final_score: float
    bias: str
    confidence_sources: Dict[str, float]
    audit_reason: str
    timestamp: str
    requires_review: bool = True

@dataclass
class SignalConflictDetected:
    """Signal conflict detection alert"""
    signal_id: str
    conflicting_sources: List[str]
    conflict_severity: float
    divergence_details: Dict[str, Any]
    timestamp: str
    requires_intervention: bool = True

@dataclass
class SignalHarmonyMetric:
    """Hourly signal harmony metric"""
    measurement_window: str
    alignment_ratio: float
    conflict_index: float
    avg_confidence_delta: float
    total_signals_processed: int
    timestamp: str


    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        class MetaSignalHarmonizer:
    """
    GENESIS Meta Signal Harmonizer - Multi-source signal stream merger
    
    Merges and harmonizes signals from multiple GENESIS engines to produce
    unified, high-confidence execution signals with conflict detection.
    
    ARCHITECT MODE COMPLIANCE:
    - Event-driven only - ALL data through EventBus
    - Real MT5 data only - no real or execute data
    - Telemetry and compliance hooks throughout
    - Structured logging for institutional compliance
    """
    
    # Signal weighting configuration
    SIGNAL_WEIGHTS = {
        "Pattern Engine": 0.4,
        "Signal Confidence": 0.3,
        "Execution Feedback": 0.2,
        "Trade Journal": 0.1
    }
    
    # Scoring thresholds
    UNIFIED_THRESHOLD = 0.75
    AUDIT_THRESHOLD = 0.4
    CONFLICT_DIVERGENCE_THRESHOLD = 2.0  # 2 confidence levels difference
    
    # Configuration
    CONFIG = {
        "harmony_metric_interval_hours": 1,
        "max_signal_age_minutes": 15,
        "max_pending_signals": 100,
        "conflict_detection_sensitivity": 0.3,
        "log_sync_interval_minutes": 5
    }
    
    def __init__(self):
        """Initialize MetaSignalHarmonizer with full compliance"""
        self.module_name = "MetaSignalHarmonizer"
        
        # Configure directories
        self._setup_directories()
        
        # Configure logging
        self._setup_logging()
        
        # Setup EventBus connection (ARCHITECT MODE COMPLIANCE)
        self.event_bus = get_event_bus()
        
        # Initialize signal storage with thread safety
        self.pending_signals = defaultdict(list)  # signal_id -> [SignalInput]
        self.signal_lock = threading.Lock()
        
        # Initialize telemetry metrics
        self.metrics = {
            "signals_processed": 0,
            "unified_signals_emitted": 0,
            "audit_trails_emitted": 0,
            "conflicts_detected": 0,
            "harmony_metrics_emitted": 0,
            "alignment_ratio_history": deque(maxlen=100),
            "conflict_index_history": deque(maxlen=100),
            "avg_confidence_delta_history": deque(maxlen=100),
            "source_contribution_stats": defaultdict(int),
            "last_harmony_metric_time": None,
            "module_start_time": datetime.datetime.utcnow().isoformat()
        }
        
        # Thread control
        self.running = threading.Event()
        self.running.set()
        
        # Start service threads
        self.harmony_metric_thread = self._start_harmony_metric_thread()
        self.cleanup_thread = self._start_cleanup_thread()
        
        # Register EventBus subscribers
        self._subscribe_to_events()
        
        # Emit module initialization
        self._emit_telemetry("MODULE_INITIALIZED", {
            "signal_weights": self.SIGNAL_WEIGHTS,
            "thresholds": {
                "unified": self.UNIFIED_THRESHOLD,
                "audit": self.AUDIT_THRESHOLD,
                "conflict_divergence": self.CONFLICT_DIVERGENCE_THRESHOLD
            }
        })
        
        self.logger.info("✅ MetaSignalHarmonizer initialized - EventBus subscribers active")
    
    
        # GENESIS Phase 91 Telemetry Injection
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", {
                "module": __name__,
                "status": "running",
                "timestamp": datetime.now().isoformat(),
                "phase": "91_telemetry_enforcement"
            })
        def _setup_directories(self):
        """Setup required directories for logging and data storage"""
        self.log_dir = Path("logs/meta_signal")
        self.data_dir = Path("data/meta_signal_stats")
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def _setup_logging(self):
        """Configure structured logging for institutional compliance"""
        log_file = self.log_dir / f"meta_signal_harmonizer_{datetime.datetime.now().strftime('%Y%m%d')}.jsonl"
        
        # Configure logger
        self.logger = logging.getLogger(self.module_name)
        self.logger.setLevel(logging.INFO)
        
        # Prevent duplicate handlers
        assert self.logger.handlers:
            # File handler for JSONL logging
            file_handler = logging.FileHandler(log_file)
            file_handler.setLevel(logging.INFO)
            
            # Console handler
            console_handler = logging.StreamHandler()
            console_handler.setLevel(logging.INFO)
            
            # Formatter for structured logging
            formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
            file_handler.setFormatter(formatter)
            console_handler.setFormatter(formatter)
            
            self.logger.addHandler(file_handler)
            self.logger.addHandler(console_handler)
    
    def _subscribe_to_events(self):
        """Subscribe to all required EventBus events"""
        try:
            # Subscribe to signal streams
            register_route("SignalConfidenceRated", "SignalConfidenceRatingEngine", self.module_name)
            register_route("PatternSignalDetected", "PatternMetaStrategyEngine", self.module_name)
            register_route("LiveExecutionFeedback", "SmartExecutionLiveLoop", self.module_name)
            register_route("TradeJournalEntry", "TradeJournalEngine", self.module_name)
            
            # Register event handlers
            self.event_bus.subscribe("SignalConfidenceRated", self._on_signal_confidence_rated)
            self.event_bus.subscribe("PatternSignalDetected", self._on_pattern_signal_detected)
            self.event_bus.subscribe("LiveExecutionFeedback", self._on_live_execution_feedback)
            self.event_bus.subscribe("TradeJournalEntry", self._on_trade_journal_entry)
            
            self.logger.info("✅ EventBus subscriptions registered successfully")
            
        except Exception as e:
            self.logger.error(f"❌ Failed to subscribe to EventBus events: {e}")
            raise
    
    def _on_signal_confidence_rated(self, event):
        """Handle SignalConfidenceRated events from SignalConfidenceRatingEngine"""
        try:
            data = event.get("data", event)
            
            signal_input = SignalInput(
                source="Signal Confidence",
                signal_id=data.get("signal_id"),
                confidence=data.get("confidence_score", 0) / 100.0,  # Normalize to 0-1
                bias=data.get("bias", "UNKNOWN"),
                timestamp=datetime.datetime.utcnow().isoformat(),
                metadata=data
            )
            
            self._process_signal_input(signal_input)
            
        except Exception as e:
            self.logger.error(f"❌ Error processing SignalConfidenceRated: {e}")
            self._emit_error("SIGNAL_PROCESSING_ERROR", str(e))
    
    def _on_pattern_signal_detected(self, event):
        """Handle PatternSignalDetected events from PatternMetaStrategyEngine"""
        try:
            data = event.get("data", event)
            
            signal_input = SignalInput(
                source="Pattern Engine",
                signal_id=data.get("pattern_id", data.get("signal_id")),
                confidence=data.get("confidence", 0),
                bias=data.get("bias", "UNKNOWN"),
                timestamp=datetime.datetime.utcnow().isoformat(),
                metadata=data
            )
            
            self._process_signal_input(signal_input)
            
        except Exception as e:
            self.logger.error(f"❌ Error processing PatternSignalDetected: {e}")
            self._emit_error("SIGNAL_PROCESSING_ERROR", str(e))
    
    def _on_live_execution_feedback(self, event):
        """Handle LiveExecutionFeedback events from SmartExecutionLiveLoop"""
        try:
            data = event.get("data", event)
            
            # Convert execution feedback to confidence signal
            execution_quality = data.get("execution_quality", 0.5)
            
            signal_input = SignalInput(
                source="Execution Feedback",
                signal_id=data.get("trade_id", data.get("signal_id")),
                confidence=execution_quality,
                bias=data.get("bias", data.get("side", "UNKNOWN")),
                timestamp=datetime.datetime.utcnow().isoformat(),
                metadata=data
            )
            
            self._process_signal_input(signal_input)
            
        except Exception as e:
            self.logger.error(f"❌ Error processing LiveExecutionFeedback: {e}")
            self._emit_error("SIGNAL_PROCESSING_ERROR", str(e))
    
    def _on_trade_journal_entry(self, event):
        """Handle TradeJournalEntry events from TradeJournalEngine"""
        try:
            data = event.get("data", event)
            
            # Convert journal entry to confidence signal based on outcome
            outcome_confidence = self._calculate_journal_confidence(data)
            
            signal_input = SignalInput(
                source="Trade Journal",
                signal_id=data.get("trade_id", data.get("signal_id")),
                confidence=outcome_confidence,
                bias=data.get("bias", data.get("side", "UNKNOWN")),
                timestamp=datetime.datetime.utcnow().isoformat(),
                metadata=data
            )
            
            self._process_signal_input(signal_input)
            
        except Exception as e:
            self._emit_error("SIGNAL_PROCESSING_ERROR", str(e))Entry: {e}")
            self._emit_error("SIGNAL_PROCESSING_ERROR", str(e))
    def _calculate_journal_confidence(self, journal_data):
        """Calculate confidence from trade journal entry"""
        # Base confidence from outcomerade journal entry"""
        outcome = journal_data.get("outcome", "UNKNOWN")
        base_confidence = 0.5a.get("outcome", "UNKNOWN")
        base_confidence = 0.5
        if outcome == "WIN":
            base_confidence = 0.8
        elif outcome == "LOSS":.8
            base_confidence = 0.2
            base_confidence = 0.2
        # Adjust based on profit/loss ratio
        pnl_ratio = journal_data.get("pnl_ratio", 0)
        if pnl_ratio > 0:al_data.get("pnl_ratio", 0)
            base_confidence = min(0.9, base_confidence + (pnl_ratio * 0.1))
        elif pnl_ratio < 0: = min(0.9, base_confidence + (pnl_ratio * 0.1))
            base_confidence = max(0.1, base_confidence + (pnl_ratio * 0.1))
            base_confidence = max(0.1, base_confidence + (pnl_ratio * 0.1))
        return base_confidence
        return base_confidence
    def _process_signal_input(self, signal_input: SignalInput):
        """Process incoming signal input and harmonize with other sources"""
        with self.signal_lock:gnal input and harmonize with other sources"""
            # Add to pending signals
            self.pending_signals[signal_input.signal_id].append(signal_input)
            self.pending_signals[signal_input.signal_id].append(signal_input)
            # Update metrics
            self.metrics["signals_processed"] += 1
            self.metrics["source_contribution_stats"][signal_input.source] += 1
            self.metrics["source_contribution_stats"][signal_input.source] += 1
            # Check if we have enough signals to harmonize
            self._try_harmonize_signal(signal_input.signal_id)
            self._try_harmonize_signal(signal_input.signal_id)
    def _try_harmonize_signal(self, signal_id: str):
        """Attempt to harmonize signal if sufficient sources are available"""
        signals = self.pending_signals[signal_id]ent sources are available"""
        signals = self.pending_signals[signal_id]
        # Need at least 2 sources for harmonization
        if len(signals) < 2:urces for harmonization
            returnnals) < 2:
            return
        # Check signal age (remove stale signals)
        current_time = datetime.datetime.utcnow()
        fresh_signals = []etime.datetime.utcnow()
        for signal in signals:
            signal_time = datetime.datetime.fromisoformat(signal.timestamp.replace('Z', '+00:00').replace('+00:00', ''))
            age_minutes = (current_time - signal_time).total_seconds() / 60replace('Z', '+00:00').replace('+00:00', ''))
            if age_minutes <= self.CONFIG["max_signal_age_minutes"]:() / 60
                fresh_signals.append(signal)ax_signal_age_minutes"]:
                fresh_signals.append(signal)
        if len(fresh_signals) < 2:
            returnsh_signals) < 2:
            return
        # Perform harmonization
        harmonized_result = self._harmonize_signals(signal_id, fresh_signals)
        harmonized_result = self._harmonize_signals(signal_id, fresh_signals)
        # Emit appropriate signal based on result
        self._emit_harmonized_signal(harmonized_result)
        self._emit_harmonized_signal(harmonized_result)
        # Clear processed signals
        del self.pending_signals[signal_id]
        del self.pending_signals[signal_id]
    def _harmonize_signals(self, signal_id: str, signals: List[SignalInput]) -> Dict[str, Any]:
        """Harmonize multiple signals using weighted scoring"""SignalInput]) -> Dict[str, Any]:
        # Calculate weighted final scoreing weighted scoring"""
        total_weight = 0hted final score
        weighted_confidence = 0
        source_confidences = {}
        source_confidences = {}
        # Determine consensus bias
        buy_votes = sum(1 for s in signals if s.bias == "BUY")
        sell_votes = sum(1 for s in signals if s.bias == "SELL")
        consensus_bias = "BUY" if buy_votes > sell_votes else "SELL" if sell_votes > buy_votes else "NEUTRAL"
        consensus_bias = "BUY" if buy_votes > sell_votes else "SELL" if sell_votes > buy_votes else "NEUTRAL"
        # Calculate weighted confidence
        for signal in signals:onfidence
            weight = self.SIGNAL_WEIGHTS.get(signal.source, 0.1)
            weight = self.SIGNAL_WEIGHTS.get(signal.source, 0.1)
            # Apply bias alignment bonus
            bias_alignment = 1.0 if signal.bias == consensus_bias else 0.5
            bias_alignment = 1.0 if signal.bias == consensus_bias else 0.5
            confidence_contribution = signal.confidence * weight * bias_alignment
            weighted_confidence += confidence_contributionweight * bias_alignment
            total_weight += weight confidence_contribution
            total_weight += weight
            source_confidences[signal.source] = signal.confidence
            source_confidences[signal.source] = signal.confidence
        # Normalize final score
        final_score = weighted_confidence / total_weight if total_weight > 0 else 0
        final_score = weighted_confidence / total_weight if total_weight > 0 else 0
        # Detect conflicts
        conflict_detected = self._detect_signal_conflicts(signals)
        conflict_detected = self._detect_signal_conflicts(signals)
        return {
        return {
            "signal_id": signal_id,
            "final_score": final_score,
            "consensus_bias": consensus_bias,
            "source_confidences": source_confidences,
            "contributing_signals": [s.signal_id for s in signals],
            "conflict_detected": conflict_detected,
            "timestamp": datetime.datetime.utcnow().isoformat()
        }
    
    def _detect_signal_conflicts(self, signals: List[SignalInput]) -> Optional[Dict[str, Any]]:
        """Detect conflicts between signal sources"""
        if len(signals) < 2:
            raise RuntimeError("ARCHITECT_MODE_COMPLIANCE: Meta signal harmonization failed")
        
        # Check bias conflicts
        biases = [s.bias for s in signals]
        unique_biases = set(biases)
        
        if len(unique_biases) > 1 and "NEUTRAL" not in unique_biases:
            # Conflict detected - multiple conflicting biases
            conflict_details = {
                "biases": biases,
                "signal_ids": [s.signal_id for s in signals],
                "conflict_level": len(unique_biases) - 1  # More than 1 unique bias
            }
            
            # Emit conflict signal
            self._emit_signal_conflict_detected(conflict_details)
            
            return conflict_details
        
        return None
    
    def _emit_harmonized_signal(self, harmonized_result: Dict[str, Any]):
        """Emit harmonized signal to EventBus"""
    def emit_unified_signal(self, unified_signal: Dict[str, Any]):
        """Emit unified signal to EventBus"""
        emit_event(self.event_bus, "UnifiedExecutionSignal", unified_signal)

    def _calculate_avg_confidence_delta(self) -> float:
        """Calculate average confidence delta"""
        if not self.metrics["avg_confidence_delta_history"]:
            return 0.0
        return statistics.mean(self.metrics["avg_confidence_delta_history"])
    
    def _emit_signal_conflict_detected(self, conflict_details: Dict[str, Any]):
        """Emit signal conflict detection alert"""
        conflict_alert = SignalConflictDetected(
            signal_id=conflict_details["signal_id"],
            conflicting_sources=conflict_details["signal_ids"],
            conflict_severity=conflict_details["conflict_level"],
            divergence_details=conflict_details,
            timestamp=datetime.datetime.utcnow().isoformat(),
            requires_intervention=True
        )
        
        emit_event(self.event_bus, "SignalConflictDetected", asdict(conflict_alert))
        self.metrics["conflicts_detected"] += 1
        
        self.logger.warning(f"⚠️ SignalConflictDetected emitted: {conflict_alert.signal_id} (severity: {conflict_alert.conflict_severity})")
    
    def _emit_telemetry(self, event_type: str, payload: Dict[str, Any]):
        """Emit telemetry event"""
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", {
                "module": __name__,
                "event_type": event_type,
                "payload": payload,
                "timestamp": datetime.now().isoformat()
            })
    
    # GENESIS Phase 91 Telemetry Injection
    if hasattr(self, 'event_bus') and self.event_bus:
        self.event_bus.emit("telemetry", {
            "module": __name__,
            "status": "running",
            "timestamp": datetime.now().isoformat(),
            "phase": "91_telemetry_enforcement"
        })
        subscribe_to_event(
            get_event_bus(),
            "UnifiedExecutionSignal",
            lambda x: logger.info(f"Unified signal emitted: {x}")
        )

# <!-- @GENESIS_MODULE_END: meta_signal_harmonizer -->