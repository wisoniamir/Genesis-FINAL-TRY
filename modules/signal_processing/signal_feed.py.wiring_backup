
# ðŸ”— GENESIS EventBus Integration - Auto-injected by Orphan Recovery Engine
from datetime import datetime
import json

class SignalFeedEventBusIntegration:
    """EventBus integration for signal_feed"""
    
    def __init__(self):
        self.module_id = "signal_feed"
        self.event_routes = []
        
    def emit_event(self, event_type, data):
        """Emit event to EventBus"""
        event = {
            "timestamp": datetime.now().isoformat(),
            "module": self.module_id,
            "event_type": event_type,
            "data": data
        }
        print(f"ðŸ”— EVENTBUS EMIT: {event}")
        
    def emit_telemetry(self, metric_name, value):
        """Emit telemetry data"""
        telemetry = {
            "timestamp": datetime.now().isoformat(),
            "module": self.module_id,
            "metric": metric_name,
            "value": value
        }
        print(f"ðŸ“Š TELEMETRY: {telemetry}")

# Auto-instantiate EventBus integration
signal_feed_eventbus = SignalFeedEventBusIntegration()

"""
GENESIS Dashboard - Signal Feed Component
Real-time monitoring of trading signals
"""

import streamlit as st
import pandas as pd
import json
import time
from datetime import datetime, timedelta
import os
from styles.dashboard_styles import confidence_badge, tag_badge

class SignalFeedComponent:
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.event_bus = self._get_event_bus()
        
    def _get_event_bus(self):
        # Auto-injected EventBus connection
        try:
            from event_bus_manager import EventBusManager


# <!-- @GENESIS_MODULE_END: signal_feed -->


# <!-- @GENESIS_MODULE_START: signal_feed -->
            return EventBusManager.get_instance()
        except ImportError:
            logging.warning("EventBus not available - integration required")
            return None
            
    def emit_telemetry(self, data):
        if self.event_bus:
            self.event_bus.emit('telemetry', data)
    """
    Component for displaying real-time signal feed
    """
    
    def __init__(self, config):
        """Initialize with configuration"""
        self.config = config
        self.signal_config = config["signal_feed"]
        self.refresh_rate = config["refresh_rate"]["signals"]
        self.last_updated = datetime.now()
        self.signals = []
    
    def load_signals(self):
        """Load signals from SignalValidator and PatternEngine"""
        try:
            signals = []
            
            # Try to load from signal_validator logs
            today = datetime.now().strftime("%Y-%m-%d")
            yesterday = (datetime.now() - timedelta(days=1)).strftime("%Y-%m-%d")
            
            # Check files from signal validator
            signal_files = [
                f"logs/signal_validator/validated_signals_{today}.jsonl",
                f"logs/signal_validator/validated_signals_{yesterday}.jsonl"
            ]
            
            for file_path in signal_files:
                if os.path.exists(file_path):
                    with open(file_path, "r") as f:
                        for line in f:
                            try:
                                signal = json.loads(line.strip())
                                signals.append(signal)
                            except:
                                continue
            
            # Also check pattern engine logs
            pattern_files = [
                f"logs/pattern_engine/patterns_{today}.jsonl",
                f"logs/pattern_engine/patterns_{yesterday}.jsonl"
            ]
            
            for file_path in pattern_files:
                if os.path.exists(file_path):
                    with open(file_path, "r") as f:
                        for line in f:
                            try:
                                pattern = json.loads(line.strip())
                                # Convert pattern to signal format
                                signal = {
                                    "timestamp": pattern.get("timestamp", ""),
                                    "symbol": pattern.get("symbol", ""),
                                    "direction": pattern.get("direction", ""),
                                    "confidence": pattern.get("score", 0) * 10,  # Convert 0-10 score to percentage
                                    "source": "PatternEngine",
                                    "pattern_type": pattern.get("pattern_type", "Unknown"),
                                    "timeframe": pattern.get("timeframe", "Unknown")
                                }
                                signals.append(signal)
                            except:
                                continue
            
            # Sort by timestamp, newest first
            signals = sorted(signals, key=lambda s: s.get("timestamp", ""), reverse=True)
            
            # Limit to max_signals
            signals = signals[:self.signal_config["max_signals"]]
            
            self.signals = signals
            self.last_updated = datetime.now()
            return signals
            
        except Exception as e:
            st.error(f"Error loading signals: {str(e)}")
            return []
    
    def render(self):
        """Render the signal feed panel"""
        st.markdown('<div class="main-title">Signal Feed</div>', unsafe_allow_html=True)
        
        # Get current signals
        signals = self.load_signals()
        
        # Display last updated time
        st.markdown(f'<div class="last-update">Last updated: {self.last_updated.strftime("%H:%M:%S")}</div>', unsafe_allow_html=True)
        
        # Show filters
        with st.expander("Filter Options", expanded=False):
            col1, col2, col3 = st.columns(3)
            
            with col1:
                direction_filter = st.multiselect(
                    "Direction", 
                    options=["Buy", "Sell"],
                    default=[]
                )
            
            with col2:
                symbol_filter = st.multiselect(
                    "Symbol",
                    options=list(set([s.get("symbol", "Unknown") for s in signals])),
                    default=[]
                )
            
            with col3:
                source_filter = st.multiselect(
                    "Source",
                    options=list(set([s.get("source", "Unknown") for s in signals])),
                    default=[]
                )
                
            confidence_threshold = st.slider(
                "Min. Confidence",
                min_value=0,
                max_value=100,
                value=50,
                step=5
            )
        
        # Apply filters
        filtered_signals = signals
        
        if direction_filter:
            filtered_signals = [s for s in filtered_signals if s.get("direction", "").lower() in [d.lower() for d in direction_filter]]
        
        if symbol_filter:
            filtered_signals = [s for s in filtered_signals if s.get("symbol", "") in symbol_filter]
        
        if source_filter:
            filtered_signals = [s for s in filtered_signals if s.get("source", "") in source_filter]
        
        filtered_signals = [s for s in filtered_signals if s.get("confidence", 0) >= confidence_threshold]
        
        # Limit to display signals
        filtered_signals = filtered_signals[:self.signal_config["display_signals"]]
        
        # Check if we have signals
        if not filtered_signals:
            st.info("No signals matching the criteria.")
            return
        
        # Display signals as cards
        for signal in filtered_signals:
            # Format timestamp
            timestamp = signal.get("timestamp", "")
            formatted_time = timestamp.split("T")[1].split(".")[0] if "T" in timestamp else timestamp
            formatted_date = timestamp.split("T")[0] if "T" in timestamp else ""
            
            # Get confidence score and badge
            confidence = signal.get("confidence", 0)
            conf_badge = confidence_badge(confidence)
            
            # Get direction and symbol
            direction = signal.get("direction", "Unknown").upper()
            symbol = signal.get("symbol", "Unknown")
            
            # Source badge
            source = signal.get("source", "Unknown")
            source_badge = tag_badge(source)
            
            # Additional tags
            timeframe = signal.get("timeframe", "")
            timeframe_badge = tag_badge(timeframe) if timeframe else ""
            
            pattern_type = signal.get("pattern_type", "")
            pattern_badge = tag_badge(pattern_type) if pattern_type else ""
            
            # Create signal card
            card_html = f"""
            <div class="signal-card">
                <div class="signal-header">
                    <div class="signal-symbol">{direction} {symbol}</div>
                    <div>{formatted_time}</div>
                </div>
                <div style="margin-bottom: 8px;">
                    {conf_badge}
                    {source_badge}
                    {timeframe_badge}
                    {pattern_badge}
                </div>
                <div class="metric-row">
                    <div class="metric-label">Entry:</div>
                    <div class="metric-value">{signal.get('entry_price', 'Market')}</div>
                </div>
                <div class="metric-row">
                    <div class="metric-label">SL:</div>
                    <div class="metric-value">{signal.get('stop_loss', 'N/A')}</div>
                </div>
                <div class="metric-row">
                    <div class="metric-label">TP:</div>
                    <div class="metric-value">{signal.get('take_profit', 'N/A')}</div>
                </div>
                <div class="metric-row">
                    <div class="metric-label">Signal ID:</div>
                    <div class="metric-value">{signal.get('signal_id', 'N/A')}</div>
                </div>
            </div>
            """
            
            st.markdown(card_html, unsafe_allow_html=True)
        
        # Display signal statistics
        if filtered_signals:
            st.markdown('<div class="subtitle">Signal Statistics</div>', unsafe_allow_html=True)
            
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("Total Signals", len(filtered_signals))
            
            with col2:
                buy_count = len([s for s in filtered_signals if s.get("direction", "").lower() == "buy"])
                sell_count = len([s for s in filtered_signals if s.get("direction", "").lower() == "sell"])
                st.metric("Buy/Sell Ratio", f"{buy_count}/{sell_count}")
            
            with col3:
                avg_conf = sum([s.get("confidence", 0) for s in filtered_signals]) / len(filtered_signals) if filtered_signals else 0
                st.metric("Avg. Confidence", f"{avg_conf:.1f}%")
            
            with col4:
                sources = {}
                for s in filtered_signals:
                    source = s.get("source", "Unknown")
                    if source not in sources:
                        sources[source] = 0
                    sources[source] += 1
                
                top_source = max(sources.items(), key=lambda x: x[1])[0] if sources else "None"
                st.metric("Top Source", top_source)


def setup_event_subscriptions(self):
    """Set up EventBus subscriptions for this UI component"""
    event_bus.subscribe("market_data_updated", self.handle_market_data_update)
    event_bus.subscribe("trade_executed", self.handle_trade_update)
    event_bus.subscribe("position_changed", self.handle_position_update)
    event_bus.subscribe("risk_threshold_warning", self.handle_risk_warning)
    event_bus.subscribe("system_status_changed", self.handle_system_status_update)
    
    # Register with telemetry
    telemetry.log_event(TelemetryEvent(
        category="ui", 
        name="event_subscriptions_setup", 
        properties={"component": self.__class__.__name__}
    ))
