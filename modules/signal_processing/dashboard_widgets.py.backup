# <!-- @GENESIS_MODULE_START: dashboard_widgets -->

#!/usr/bin/env python3
"""
üîπ Name: Dashboard Widgets
üîÅ EventBus Bindings: [widget.interaction, ui.update.request, data.visualization.update]
üì° Telemetry: [widget_render_time, user_interaction_count, data_update_frequency]
üß™ MT5 Tests: [real-time data display, interactive responsiveness]
ü™µ Error Handling: [widget rendering errors, data formatting issues, user input validation]
‚öôÔ∏è Performance: [sub-100ms render time, efficient memory usage, smooth animations]
üóÉÔ∏è Registry ID: dashboard_widgets_phase69
‚öñÔ∏è Compliance Score: A
üìå Status: active
üìÖ Last Modified: 2025-06-18
üìù Author(s): GENESIS Architect Agent
üîó Dependencies: [tkinter, matplotlib, event_bus, telemetry_sync]

GENESIS Phase 69: Dashboard Widgets Library
==========================================

Comprehensive widget library for GENESIS execution dashboard.
Provides reusable, high-performance UI components for real-time trading data visualization.

Widget Components:
- SignalMonitorWidget: Real-time signal display and monitoring
- PerformanceWidget: Performance metrics visualization
- ControlPanelWidget: System control and override interface
- PatternConfidenceWidget: Pattern confidence heatmap display
- RiskMonitorWidget: Risk metrics and alert display
- LogDisplayWidget: System log viewer with filtering
"""

import tkinter as tk
from tkinter import ttk, scrolledtext
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Any, Callable, Optional
import threading
import time
from collections import deque

class BaseWidget:
    """Base class for all dashboard widgets"""
    
    def __init__(self, parent, colors: Dict[str, str], title: str = ""):
        self.parent = parent
        self.colors = colors
        self.title = title
        self.frame = None
        self.last_update = time.time()
        self.update_count = 0
        
        self._create_frame()
    
    
        # GENESIS Phase 91 Telemetry Injection
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", {
                "module": __name__,
                "status": "running",
                "timestamp": datetime.now().isoformat(),
                "phase": "91_telemetry_enforcement"
            })
        def _create_frame(self):
        """Create main widget frame"""
        self.frame = ttk.LabelFrame(self.parent, text=self.title)
        self.frame.configure(style='Dashboard.TLabelframe')
    
    def grid(self, **kwargs):
        """Grid the widget frame"""
        if self.frame:
            self.frame.grid(**kwargs)
    
    def update_performance_metric(self):
        """Update widget performance metrics"""
        self.update_count += 1
        self.last_update = time.time()

class SignalMonitorWidget(BaseWidget):
    """Real-time signal monitoring widget"""
    
    def __init__(self, parent, colors: Dict[str, str], on_signal_click: Callable = None):
        self.on_signal_click = on_signal_click
        self.signals_data = deque(maxlen=50)
        
        super().__init__(parent, colors, "Live Signals")
        self._create_components()
    
    def _create_components(self):
        """Create signal monitor components"""
        # Create treeview for signals
        columns = ('Time', 'Symbol', 'Type', 'Confidence', 'Status')
        self.tree = ttk.Treeview(self.frame, columns=columns, show='headings', height=12)
        
        # Configure columns
        for col in columns:
            self.tree.heading(col, text=col)
            self.tree.column(col, width=80, anchor='center')
        
        # Add scrollbar
        scrollbar = ttk.Scrollbar(self.frame, orient='vertical', command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)
        
        # Layout
        self.tree.grid(row=0, column=0, sticky='nsew', padx=5, pady=5)
        scrollbar.grid(row=0, column=1, sticky='ns', pady=5)
        
        # Configure grid weights
        self.frame.grid_rowconfigure(0, weight=1)
        self.frame.grid_columnconfigure(0, weight=1)
        
        # Bind click event
        if self.on_signal_click:
            self.tree.bind('<Double-1>', self._on_tree_click)
        
        # Add signal statistics frame
        stats_frame = ttk.Frame(self.frame)
        stats_frame.grid(row=1, column=0, columnspan=2, sticky='ew', padx=5, pady=2)
        
        self.stats_labels = {
            'total': ttk.Label(stats_frame, text="Total: 0"),
            'active': ttk.Label(stats_frame, text="Active: 0"),
            'success_rate': ttk.Label(stats_frame, text="Success: 0%")
        }
        
        for i, (key, label) in enumerate(self.stats_labels.items()):
            label.grid(row=0, column=i, padx=10)
    
    def update_signals(self, signals: List[Dict[str, Any]]):
        """Update signals display"""
        try:
            # Clear existing items
            for item in self.tree.get_children():
                self.tree.delete(item)
            
            # Add new signals
            for signal in signals[-20:]:  # Show last 20 signals
                time_str = datetime.fromisoformat(signal.get('timestamp', '')).strftime('%H:%M:%S')
                
                # Determine status color
                confidence = signal.get('confidence', 0.0)
                if confidence >= 0.8:
                    status = "üü¢ High"
                elif confidence >= 0.6:
                    status = "üü° Med"
                else:
                    status = "üî¥ Low"
                
                self.tree.insert('', 0, values=(
                    time_str,
                    signal.get('symbol', ''),
                    signal.get('type', ''),
                    f"{confidence:.2f}",
                    status
                ))
            
            # Update statistics
            self._update_statistics(signals)
            self.update_performance_metric()
            
        except Exception as e:
            print(f"Error updating signals: {e}")
    
    def _update_statistics(self, signals: List[Dict[str, Any]]):
        """Update signal statistics"""
        try:
            total_signals = len(signals)
            active_signals = sum(1 for s in signals if s.get('confidence', 0) >= 0.6)
            
            # Calculate success rate (simplified)
            high_confidence = sum(1 for s in signals if s.get('confidence', 0) >= 0.8)
            success_rate = (high_confidence / total_signals * 100) if total_signals > 0 else 0
            
            # Update labels
            self.stats_labels['total'].config(text=f"Total: {total_signals}")
            self.stats_labels['active'].config(text=f"Active: {active_signals}")
            self.stats_labels['success_rate'].config(text=f"Success: {success_rate:.1f}%")
            
        except Exception as e:
            print(f"Error updating statistics: {e}")
    
    def _on_tree_click(self, event):
        """Handle tree item click"""
        if self.on_signal_click:
            item = self.tree.selection()[0]
            values = self.tree.item(item, 'values')
            signal_data = {
                'time': values[0],
                'symbol': values[1],
                'type': values[2],
                'confidence': float(values[3])
            }
            self.on_signal_click(signal_data)

class PatternConfidenceWidget(BaseWidget):
    """Pattern confidence heatmap widget"""
    
    def __init__(self, parent, colors: Dict[str, str], on_confidence_click: Callable = None):
        self.on_confidence_click = on_confidence_click
        self.confidence_data = {}
        
        super().__init__(parent, colors, "Pattern Confidence")
        self._create_components()
    
    def _create_components(self):
        """Create pattern confidence heatmap"""
        # Create matplotlib figure
        self.fig = Figure(figsize=(6, 3), dpi=80, facecolor=self.colors['background'])
        self.ax = self.fig.add_subplot(111)
        
        # Create canvas
        self.canvas = FigureCanvasTkAgg(self.fig, self.frame)
        self.canvas.get_tk_widget().grid(row=0, column=0, sticky='nsew', padx=5, pady=5)
        
        # Configure grid
        self.frame.grid_rowconfigure(0, weight=1)
        self.frame.grid_columnconfigure(0, weight=1)
        
        # Initialize empty heatmap
        self._create_empty_heatmap()
        
        # Bind click event
        if self.on_confidence_click:
            self.canvas.mpl_connect('button_press_event', self._on_canvas_click)
    
    def _create_empty_heatmap(self):
        """Create empty heatmap actual_data"""
        symbols = ['EURUSD', 'GBPUSD', 'USDJPY', 'AUDUSD']
        timeframes = ['H1', 'H4', 'D1']
        
        data = np.zeros((len(symbols), len(timeframes)))
        
        im = self.ax.imshow(data, cmap='RdYlGn', aspect='auto', vmin=0, vmax=1)
        
        self.ax.set_xticks(range(len(timeframes)))
        self.ax.set_xticklabels(timeframes)
        self.ax.set_yticks(range(len(symbols)))
        self.ax.set_yticklabels(symbols)
        
        self.ax.set_title('Pattern Confidence Matrix', color=self.colors['text'])
        self.ax.tick_params(colors=self.colors['text'])
        
        # Add colorbar
        cbar = self.fig.colorbar(im, ax=self.ax, fraction=0.046, pad=0.04)
        cbar.ax.tick_params(colors=self.colors['text'])
        
        self.fig.tight_layout()
        self.canvas.draw()
    
    def update_confidence_data(self, confidence_data: Dict[str, Any]):
        """Update confidence heatmap with new data"""
        try:
            self.confidence_data = confidence_data
            
            if not confidence_data:
                return
            
            # Extract symbols and timeframes from data
            symbols = list(confidence_data.keys())[:6]  # Limit to 6 symbols
            timeframes = ['H1', 'H4', 'D1']
            
            if not symbols:
                return
            
            # Create confidence matrix
            matrix = np.zeros((len(symbols), len(timeframes)))
            
            for i, symbol in enumerate(symbols):
                symbol_data = confidence_data.get(symbol, {})
                for j, timeframe in enumerate(timeframes):
                    tf_data = symbol_data.get(timeframe, {})
                    confidence = tf_data.get('confidence', 0.0)
                    matrix[i, j] = confidence
            
            # Clear and redraw
            self.ax.clear()
            
            im = self.ax.imshow(matrix, cmap='RdYlGn', aspect='auto', vmin=0, vmax=1)
            
            self.ax.set_xticks(range(len(timeframes)))
            self.ax.set_xticklabels(timeframes)
            self.ax.set_yticks(range(len(symbols)))
            self.ax.set_yticklabels(symbols)
            
            self.ax.set_title('Pattern Confidence Matrix', color=self.colors['text'])
            self.ax.tick_params(colors=self.colors['text'])
            
            # Add confidence values as text
            for i in range(len(symbols)):
                for j in range(len(timeframes)):
                    text_color = 'white' if matrix[i, j] < 0.5 else 'black'
                    self.ax.text(j, i, f'{matrix[i, j]:.2f}', 
                               ha='center', va='center', color=text_color, fontsize=8)
            
            self.fig.tight_layout()
            self.canvas.draw()
            self.update_performance_metric()
            
        except Exception as e:
            print(f"Error updating confidence data: {e}")
    
    def _on_canvas_click(self, event):
        """Handle canvas click events"""
        if event.inaxes == self.ax and self.on_confidence_click:
            # Calculate clicked symbol/timeframe
            x, y = int(event.xdata + 0.5), int(event.ydata + 0.5)
            
            symbols = list(self.confidence_data.keys())[:6]
            timeframes = ['H1', 'H4', 'D1']
            
            if 0 <= y < len(symbols) and 0 <= x < len(timeframes):
                confidence_data = {
                    'symbol': symbols[y],
                    'timeframe': timeframes[x],
                    'confidence': self.confidence_data.get(symbols[y], {}).get(timeframes[x], {}).get('confidence', 0.0)
                }
                self.on_confidence_click(confidence_data)

class PerformanceWidget(BaseWidget):
    """Performance metrics visualization widget"""
    
    def __init__(self, parent, colors: Dict[str, str]):
        self.performance_data = {}
        super().__init__(parent, colors, "Performance Metrics")
        self._create_components()
    
    def _create_components(self):
        """Create performance metrics display"""
        # Create notebook for different metric views
        self.notebook = ttk.Notebook(self.frame)
        self.notebook.grid(row=0, column=0, sticky='nsew', padx=5, pady=5)
        
        # Summary tab
        self.summary_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.summary_frame, text='Summary')
        
        # Chart tab
        self.chart_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.chart_frame, text='Charts')
        
        # Create summary metrics
        self._create_summary_display()
        
        # Create performance chart
        self._create_performance_chart()
        
        # Configure grid
        self.frame.grid_rowconfigure(0, weight=1)
        self.frame.grid_columnconfigure(0, weight=1)
    
    def _create_summary_display(self):
        """Create summary metrics display"""
        # Key metrics labels
        self.metric_labels = {}
        
        metrics = [
            ('Total Trades', 'total_trades'),
            ('Win Rate', 'win_rate'),
            ('Profit Factor', 'profit_factor'),
            ('Max Drawdown', 'max_drawdown'),
            ('Daily PnL', 'daily_pnl'),
            ('Active Positions', 'active_positions')
        ]
        
        for i, (label, key) in enumerate(metrics):
            row, col = divmod(i, 2)
            
            label_widget = ttk.Label(self.summary_frame, text=f"{label}:")
            label_widget.grid(row=row, column=col*2, sticky='w', padx=5, pady=2)
            
            value_widget = ttk.Label(self.summary_frame, text="0", foreground=self.colors['accent'])
            value_widget.grid(row=row, column=col*2+1, sticky='w', padx=5, pady=2)
            
            self.metric_labels[key] = value_widget
    
    def _create_performance_chart(self):
        """Create performance chart"""
        self.perf_fig = Figure(figsize=(5, 2.5), dpi=80, facecolor=self.colors['background'])
        self.perf_ax = self.perf_fig.add_subplot(111)
        
        self.perf_canvas = FigureCanvasTkAgg(self.perf_fig, self.chart_frame)
        self.perf_canvas.get_tk_widget().grid(row=0, column=0, sticky='nsew', padx=5, pady=5)
        
        # Configure chart
        self.perf_ax.set_title('Performance Over Time', color=self.colors['text'])
        self.perf_ax.tick_params(colors=self.colors['text'])
        self.perf_ax.set_facecolor(self.colors['background'])
        
        self.chart_frame.grid_rowconfigure(0, weight=1)
        self.chart_frame.grid_columnconfigure(0, weight=1)
        
        self.perf_fig.tight_layout()
        self.perf_canvas.draw()
    
    def update_metrics(self, performance_data: Dict[str, Any]):
        """Update performance metrics display"""
        try:
            self.performance_data = performance_data
            
            # Update summary metrics
            for key, label_widget in self.metric_labels.items():
                if key in performance_data:
                    value = performance_data[key]
                    if isinstance(value, (list, deque)) and value:
                        # Take latest value from time series
                        display_value = value[-1].get('value', 0) if isinstance(value[-1], dict) else value[-1]
                    else:
                        display_value = value
                    
                    # Format value based on type
                    if key in ['win_rate']:
                        formatted_value = f"{display_value:.1f}%"
                    elif key in ['profit_factor', 'max_drawdown']:
                        formatted_value = f"{display_value:.2f}"
                    elif key in ['daily_pnl']:
                        formatted_value = f"${display_value:.2f}"
                    else:
                        formatted_value = str(display_value)
                    
                    label_widget.config(text=formatted_value)
            
            # Update performance chart
            self._update_performance_chart()
            self.update_performance_metric()
            
        except Exception as e:
            print(f"Error updating performance metrics: {e}")
    
    def _update_performance_chart(self):
        """Update performance chart with latest data"""
        try:
            if 'daily_pnl' in self.performance_data:
                pnl_data = self.performance_data['daily_pnl']
                
                if isinstance(pnl_data, (list, deque)) and len(pnl_data) > 1:
                    # Extract values and timestamps
                    values = []
                    timestamps = []
                    
                    for item in list(pnl_data)[-50:]:  # Last 50 data points
                        if isinstance(item, dict):
                            values.append(item.get('value', 0))
                            timestamps.append(item.get('timestamp', ''))
                        else:
                            values.append(item)
                            timestamps.append('')
                    
                    if values:
                        self.perf_ax.clear()
                        
                        # Calculate cumulative PnL
                        cumulative_pnl = np.cumsum(values)
                        
                        self.perf_ax.plot(cumulative_pnl, color=self.colors['accent'], linewidth=2)
                        self.perf_ax.fill_between(range(len(cumulative_pnl)), cumulative_pnl, 
                                                alpha=0.3, color=self.colors['accent'])
                        
                        self.perf_ax.set_title('Cumulative PnL', color=self.colors['text'])
                        self.perf_ax.tick_params(colors=self.colors['text'])
                        self.perf_ax.set_facecolor(self.colors['background'])
                        self.perf_ax.grid(True, alpha=0.3)
                        
                        self.perf_fig.tight_layout()
                        self.perf_canvas.draw()
            
        except Exception as e:
            print(f"Error updating performance chart: {e}")

class ControlPanelWidget(BaseWidget):
    """System control and override interface widget"""
    
    def __init__(self, parent, colors: Dict[str, str], on_control_command: Callable):
        self.on_control_command = on_control_command
        self.current_status = {
            'auto_mode': True,
            'manual_override': False,
            'kill_switch_armed': False
        }
        
        super().__init__(parent, colors, "Control Panel")
        self._create_components()
    
    def _create_components(self):
        """Create control panel components"""
        # Status indicators
        status_frame = ttk.LabelFrame(self.frame, text="System Status")
        status_frame.grid(row=0, column=0, sticky='ew', padx=5, pady=5)
        
        self.status_labels = {
            'auto_mode': ttk.Label(status_frame, text="üü¢ Auto Mode: ON"),
            'manual_override': ttk.Label(status_frame, text="‚ö™ Manual Override: OFF"),
            'kill_switch': ttk.Label(status_frame, text="‚ö™ Kill Switch: SAFE")
        }
        
        for i, (key, label) in enumerate(self.status_labels.items()):
            label.grid(row=i, column=0, sticky='w', padx=5, pady=2)
        
        # Control buttons
        control_frame = ttk.LabelFrame(self.frame, text="Controls")
        control_frame.grid(row=1, column=0, sticky='ew', padx=5, pady=5)
        
        buttons = [
            ("Toggle Auto Mode", "toggle_auto_mode", self.colors['accent']),
            ("Manual Override", "activate_manual_override", self.colors['warning']),
            ("Emergency Stop", "emergency_kill_switch", self.colors['danger']),
            ("Restart System", "restart_system", self.colors['text'])
        ]
        
        self.control_buttons = {}
        for i, (text, command, color) in enumerate(buttons):
            btn = tk.Button(control_frame, text=text, 
                          command=lambda cmd=command: self._handle_button_click(cmd),
                          bg=color, fg='white', font=('Arial', 9, 'bold'))
            btn.grid(row=i, column=0, sticky='ew', padx=5, pady=2)
            self.control_buttons[command] = btn
        
        # Configure grid
        self.frame.grid_rowconfigure(0, weight=1)
        self.frame.grid_rowconfigure(1, weight=1)
        self.frame.grid_columnconfigure(0, weight=1)
        
        control_frame.grid_columnconfigure(0, weight=1)
    
    def update_status(self, status: Dict[str, bool]):
        """Update control panel status display"""
        try:
            self.current_status.update(status)
            
            # Update status labels
            auto_status = "üü¢ Auto Mode: ON" if status.get('auto_mode', False) else "üî¥ Auto Mode: OFF"
            self.status_labels['auto_mode'].config(text=auto_status)
            
            manual_status = "üü° Manual Override: ON" if status.get('manual_override', False) else "‚ö™ Manual Override: OFF"
            self.status_labels['manual_override'].config(text=manual_status)
            
            kill_status = "üî¥ Kill Switch: ARMED" if status.get('kill_switch_armed', False) else "üü¢ Kill Switch: SAFE"
            self.status_labels['kill_switch'].config(text=kill_status)
            
            self.update_performance_metric()
            
        except Exception as e:
            print(f"Error updating control panel status: {e}")
    
    def _handle_button_click(self, command: str):
        """Handle control button clicks"""
        if self.on_control_command:
            self.on_control_command(command)

class RiskMonitorWidget(BaseWidget):
    """Risk metrics and alert display widget"""
    
    def __init__(self, parent, colors: Dict[str, str], on_risk_alert: Callable = None):
        self.on_risk_alert = on_risk_alert
        self.risk_data = {}
        
        super().__init__(parent, colors, "Risk Monitor")
        self._create_components()
    
    def _create_components(self):
        """Create risk monitor components"""
        # Risk metrics display
        metrics_frame = ttk.Frame(self.frame)
        metrics_frame.grid(row=0, column=0, sticky='nsew', padx=5, pady=5)
        
        # Risk gauge (simplified)
        self.risk_canvas = tk.Canvas(metrics_frame, width=150, height=100, 
                                   bg=self.colors['background'], highlightthickness=0)
        self.risk_canvas.grid(row=0, column=0, padx=5, pady=5)
        
        # Risk metrics labels
        risk_labels_frame = ttk.Frame(metrics_frame)
        risk_labels_frame.grid(row=0, column=1, sticky='nsew', padx=5, pady=5)
        
        self.risk_labels = {
            'exposure': ttk.Label(risk_labels_frame, text="Exposure: 0%"),
            'var': ttk.Label(risk_labels_frame, text="VaR: $0.00"),
            'drawdown': ttk.Label(risk_labels_frame, text="Drawdown: 0%"),
            'margin': ttk.Label(risk_labels_frame, text="Margin: 0%")
        }
        
        for i, (key, label) in enumerate(self.risk_labels.items()):
            label.grid(row=i, column=0, sticky='w', padx=5, pady=2)
        
        # Configure grid
        self.frame.grid_rowconfigure(0, weight=1)
        self.frame.grid_columnconfigure(0, weight=1)
        metrics_frame.grid_rowconfigure(0, weight=1)
        metrics_frame.grid_columnconfigure(1, weight=1)
        
        # Initialize risk gauge
        self._draw_risk_gauge(0.0)
    
    def update_metrics(self, risk_metrics: Dict[str, Any]):
        """Update risk metrics display"""
        try:
            self.risk_data = risk_metrics
            
            # Calculate overall risk level
            risk_level = self._calculate_risk_level(risk_metrics)
            
            # Update risk gauge
            self._draw_risk_gauge(risk_level)
            
            # Update risk labels
            for key, label in self.risk_labels.items():
                if key in risk_metrics:
                    value = risk_metrics[key]
                    if isinstance(value, dict):
                        display_value = value.get('value', 0)
                    else:
                        display_value = value
                    
                    # Format based on metric type
                    if key in ['exposure', 'drawdown', 'margin']:
                        formatted_value = f"{key.title()}: {display_value:.1f}%"
                    elif key == 'var':
                        formatted_value = f"VaR: ${display_value:.2f}"
                    else:
                        formatted_value = f"{key.title()}: {display_value}"
                    
                    label.config(text=formatted_value)
            
            self.update_performance_metric()
            
        except Exception as e:
            print(f"Error updating risk metrics: {e}")
    
    def _calculate_risk_level(self, risk_metrics: Dict[str, Any]) -> float:
        """Calculate overall risk level (0.0 to 1.0)"""
        try:
            # Simple risk calculation based on key metrics
            exposure = risk_metrics.get('exposure', {}).get('value', 0) if isinstance(risk_metrics.get('exposure'), dict) else risk_metrics.get('exposure', 0)
            drawdown = risk_metrics.get('drawdown', {}).get('value', 0) if isinstance(risk_metrics.get('drawdown'), dict) else risk_metrics.get('drawdown', 0)
            margin = risk_metrics.get('margin', {}).get('value', 0) if isinstance(risk_metrics.get('margin'), dict) else risk_metrics.get('margin', 0)
            
            # Normalize and weight
            risk_level = (exposure * 0.4 + drawdown * 0.4 + margin * 0.2) / 100.0
            return min(1.0, max(0.0, risk_level))
            
        except Exception as e:
            print(f"Error calculating risk level: {e}")
            return 0.0
    
    def _draw_risk_gauge(self, risk_level: float):
        """Draw risk gauge visualization"""
        try:
            self.risk_canvas.delete("all")
            
            # Draw gauge background
            self.risk_canvas.create_arc(25, 25, 125, 125, start=0, extent=180, 
                                      outline=self.colors['text'], width=3, style='arc')
            
            # Calculate gauge fill
            fill_extent = int(180 * risk_level)
            
            # Determine color based on risk level
            if risk_level < 0.3:
                gauge_color = self.colors['success']
            elif risk_level < 0.7:
                gauge_color = self.colors['warning']
            else:
                gauge_color = self.colors['danger']
            
            # Draw gauge fill
            if fill_extent > 0:
                self.risk_canvas.create_arc(25, 25, 125, 125, start=0, extent=fill_extent,
                                          fill=gauge_color, outline=gauge_color, width=3)
            
            # Draw risk level text
            self.risk_canvas.create_text(75, 90, text=f"{risk_level*100:.1f}%", 
                                       fill=self.colors['text'], font=('Arial', 12, 'bold'))
            
        except Exception as e:
            print(f"Error drawing risk gauge: {e}")


    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        class LogDisplayWidget(BaseWidget):
    """System log viewer with filtering"""
    
    def __init__(self, parent, colors: Dict[str, str]):
        self.logs_data = deque(maxlen=500)
        self.filter_level = "INFO"
        
        super().__init__(parent, colors, "System Logs")
        self._create_components()
    
    def _create_components(self):
        """Create log display components"""
        # Filter controls
        filter_frame = ttk.Frame(self.frame)
        filter_frame.grid(row=0, column=0, sticky='ew', padx=5, pady=2)
        
        ttk.Label(filter_frame, text="Filter:").grid(row=0, column=0, padx=5)
        
        self.filter_var = tk.StringVar(value=self.filter_level)
        filter_combo = ttk.Combobox(filter_frame, textvariable=self.filter_var,
                                  values=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
                                  state='readonly', width=10)
        filter_combo.grid(row=0, column=1, padx=5)
        filter_combo.bind('<<ComboboxSelected>>', self._on_filter_change)
        
        # Clear button
        clear_btn = ttk.Button(filter_frame, text="Clear", command=self._clear_logs)
        clear_btn.grid(row=0, column=2, padx=5)
        
        # Log display
        self.log_text = scrolledtext.ScrolledText(self.frame, height=8, width=80,
                                                bg=self.colors['background'],
                                                fg=self.colors['text'],
                                                insertbackground=self.colors['text'])
        self.log_text.grid(row=1, column=0, sticky='nsew', padx=5, pady=5)
        
        # Configure grid
        self.frame.grid_rowconfigure(1, weight=1)
        self.frame.grid_columnconfigure(0, weight=1)
    
    def update_logs(self, logs: List[Dict[str, Any]]):
        """Update log display"""
        try:
            # Store logs
            for log in logs:
                if log not in self.logs_data:
                    self.logs_data.append(log)
            
            # Filter and display
            self._refresh_log_display()
            self.update_performance_metric()
            
        except Exception as e:
            print(f"Error updating logs: {e}")
    
    def _refresh_log_display(self):
        """Refresh log display with current filter"""
        try:
            # Clear display
            self.log_text.delete(1.0, tk.END)
            
            # Filter logs
            filtered_logs = []
            filter_levels = ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']
            min_level_index = filter_levels.index(self.filter_level)
            
            for log in list(self.logs_data)[-100:]:  # Show last 100 logs
                log_level = log.get('level', 'INFO')
                if log_level in filter_levels:
                    log_level_index = filter_levels.index(log_level)
                    if log_level_index >= min_level_index:
                        filtered_logs.append(log)
            
            # Display filtered logs
            for log in filtered_logs[-50:]:  # Show last 50 filtered logs
                timestamp = log.get('timestamp', '')
                level = log.get('level', 'INFO')
                module = log.get('module', '')
                message = log.get('message', '')
                
                # Format timestamp
                try:
                    dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
                    time_str = dt.strftime('%H:%M:%S')
                except:
                    time_str = timestamp[:8] if len(timestamp) >= 8 else timestamp
                
                # Color code by level
                if level == 'ERROR' or level == 'CRITICAL':
                    color = self.colors['danger']
                elif level == 'WARNING':
                    color = self.colors['warning']
                else:
                    color = self.colors['text']
                
                # Format log entry
                log_entry = f"[{time_str}] {level:8} {module:15} | {message}\n"
                
                # Insert with color
                self.log_text.insert(tk.END, log_entry)
                
                # Tag for color (simplified - would need more complex tagging for full color support)
                if level in ['ERROR', 'CRITICAL', 'WARNING']:
                    start_line = self.log_text.index(f"{tk.END}-1c linestart")
                    end_line = self.log_text.index(f"{tk.END}-1c lineend")
                    tag_name = f"{level}_tag"
                    
                    if not tag_name in self.log_text.tag_names():
                        self.log_text.tag_config(tag_name, foreground=color)
                    
                    self.log_text.tag_add(tag_name, start_line, end_line)
            
            # Auto-scroll to bottom
            self.log_text.see(tk.END)
            
        except Exception as e:
            print(f"Error refreshing log display: {e}")
    
    def _on_filter_change(self, event):
        """Handle filter level change"""
        self.filter_level = self.filter_var.get()
        self._refresh_log_display()
    
    def _clear_logs(self):
        """Clear log display"""
        self.logs_data.clear()
        self.log_text.delete(1.0, tk.END)

# Module testing
if __name__ == "__main__":
    # Create test window
    root = tk.Tk()
    root.title("Dashboard Widgets Test")
    root.geometry("800x600")
    
    colors = {
        'background': '#2B2B2B',
        'text': '#FFFFFF',
        'accent': '#00FF88',
        'warning': '#FFA500',
        'danger': '#FF4444',
        'success': '#00CC44'
    }
    
    # Test signal monitor
    signal_widget = SignalMonitorWidget(root, colors)
    signal_widget.grid(row=0, column=0, sticky='nsew', padx=5, pady=5)
    
    # Add test signals
    test_signals = [
        {
            'symbol': 'EURUSD',
            'type': 'BUY',
            'confidence': 0.85,
            'timestamp': datetime.now().isoformat()
        }
    ]
    
    signal_widget.update_signals(test_signals)
    
    root.mainloop()


# <!-- @GENESIS_MODULE_END: dashboard_widgets -->