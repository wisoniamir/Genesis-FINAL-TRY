# -*- coding: utf-8 -*-
# <!-- @GENESIS_MODULE_START: genesis_compliance_core -->

"""
🔹 Name: GenesisComplianceCore
🔁 EventBus Bindings: execution:placed, mt5:update → compliance:breach, compliance:ok
📡 Telemetry: daily_loss, max_drawdown, trade_count, hedging_attempts, slippage_reports
🧪 MT5 Tests: breach execute, real-time PnL aggregation, hedge detection
🪵 Error Handling: logged, escalated
⚙️ Performance: <50ms latency, real-time monitoring
🗃️ Registry ID: genesis_compliance_core_v1.0.0
⚖️ Compliance Score: A
📌 Status: active
📅 Last Modified: 2025-06-18
📝 Author(s): GENESIS Architect Agent
🔗 Dependencies: EventBus, ExecutionSupervisor, Dashboard
"""

import json
import threading
import time
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
import pandas as pd
import logging
from pathlib import Path

class GenesisComplianceCore:
    """
    GENESIS Compliance Engine - Phase 83
    
    🎯 CORE FEATURES:
    - Tracks all trades and PnL from execution_log.json
    - Compares to FTMO thresholds (daily limit: $10k, max DD: $20k)
    - Blocks further execution if limits are reached
    - Triggers visual alert in GUI
    - Logs compliance snapshots in /compliance/compliance_log.json
    """
    
    def __init__(self):
        self.module_id = "genesis_compliance_core"
        self.version = "1.0.0"
        self.session_id = str(uuid.uuid4())[:8]
        self.is_running = False
        self.monitoring_thread = None
        
        # FTMO Compliance Thresholds
        self.daily_loss_limit = 10000.0  # $10k daily loss limit
        self.max_drawdown_limit = 20000.0  # $20k max drawdown
        self.max_daily_trades = 50  # Maximum trades per day
        
        # Current Metrics
        self.current_daily_pnl = 0.0
        self.current_drawdown = 0.0
        self.current_trade_count = 0
        self.account_starting_balance = 100000.0  # FTMO account size
        self.account_current_balance = self.account_starting_balance
        self.account_peak_balance = self.account_starting_balance
        
        # Compliance Status
        self.compliance_status = "OK"
        self.breach_reasons = []
        self.is_trading_blocked = False
        
        # Telemetry Counters
        self.hedging_attempts = 0
        self.slippage_violations = 0
        self.total_trades_processed = 0
        self.compliance_checks_performed = 0
        
        # File Paths
        self.execution_log_path = Path("execution_log.json")
        self.event_bus_path = Path("event_bus.json")
        self.telemetry_path = Path("telemetry.json")
        self.compliance_dir = Path("compliance")
        self.compliance_log_path = self.compliance_dir / "compliance_log.json"
        
        # Ensure compliance directory exists
        self.compliance_dir.mkdir(exist_ok=True)
        
        # Trade tracking
        self.daily_trades = []
        self.position_tracking = {}  # Track open positions for hedge detection
        
        # Setup logging
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(f"GENESIS.{self.module_id}")
        
        self.logger.info(f"🔧 GenesisComplianceCore v{self.version} initialized - Session: {self.session_id}")
        
        # Initialize with existing data
        self._load_existing_data()
    
    
        # GENESIS Phase 91 Telemetry Injection
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", {
                "module": __name__,
                "status": "running",
                "timestamp": datetime.now().isoformat(),
                "phase": "91_telemetry_enforcement"
            })
        def start_monitoring(self):
        """Start the compliance monitoring thread"""
        if self.is_running:
            self.logger.warning("⚠️ GenesisComplianceCore is already running")
            return
        
        self.is_running = True
        self.monitoring_thread = threading.Thread(target=self._monitoring_loop, daemon=True)
        self.monitoring_thread.start()
        
        self.logger.info("🚀 GenesisComplianceCore monitoring started")
        self._emit_event("system:compliance_monitoring_started", {
            "session_id": self.session_id,
            "timestamp": datetime.now().isoformat()
        })
    
    def stop_monitoring(self):
        """Stop the compliance monitoring"""
        self.is_running = False
        if self.monitoring_thread:
            self.monitoring_thread.join(timeout=5.0)
        
        self.logger.info("🛑 GenesisComplianceCore monitoring stopped")
        self._emit_event("system:compliance_monitoring_stopped", {
            "session_id": self.session_id,
            "timestamp": datetime.now().isoformat()
        })
    
    def _monitoring_loop(self):
        """Main compliance monitoring loop"""
        last_check = datetime.now()
        
        while self.is_running:
            try:
                # Check for new execution events
                self._check_execution_events()
                
                # Check for MT5 update events
                self._check_mt5_update_events()
                
                # Perform compliance checks every 10 seconds
                if (datetime.now() - last_check).seconds >= 10:
                    self._perform_compliance_checks()
                    self._emit_telemetry()
                    last_check = datetime.now()
                
                time.sleep(0.05)  # 50ms polling interval
                
            except Exception as e:
                self.logger.error(f"❌ Compliance monitoring error: {str(e)}")
                time.sleep(1.0)
    
    def _load_existing_data(self):
        """Load existing execution data and compliance state"""
        try:
            # Load execution log
            if self.execution_log_path.exists():
                with open(self.execution_log_path, 'r') as f:
                    execution_data = json.load(f)
                
                # Process existing trades for today
                today = datetime.now().date()
                for trade in execution_data:
                    trade_date = datetime.fromisoformat(trade['timestamp']).date()
                    if trade_date == today:
                        self._process_trade_for_compliance(trade)
            
            # Load previous compliance state
            if self.compliance_log_path.exists():
                with open(self.compliance_log_path, 'r') as f:
                    compliance_data = json.load(f)
                
                # Get latest compliance snapshot
                if compliance_data and len(compliance_data) > 0:
                    latest = compliance_data[-1]
                    self.account_current_balance = latest.get('account_balance', self.account_starting_balance)
                    self.account_peak_balance = latest.get('peak_balance', self.account_starting_balance)
            
            self.logger.info(f"📊 Loaded existing data - Balance: ${self.account_current_balance}, Daily PnL: ${self.current_daily_pnl}")
            
        except Exception as e:
            self.logger.error(f"❌ Error loading existing data: {str(e)}")
    
    def _check_execution_events(self):
        """Check for new execution:placed events"""
        try:
            if not self.event_bus_path.exists():
                return
            
            with open(self.event_bus_path, 'r') as f:
                event_data = json.load(f)
            
            # Look for unprocessed execution:placed events
            for event in event_data.get('events', []):
                if (event.get('type') == 'execution:placed' and 
                    not event.get('processed_by_compliance_core', False)):
                    
                    self._handle_execution_event(event)
                    
                    # Mark as processed
                    event['processed_by_compliance_core'] = True
            
            # Save updated event bus
            with open(self.event_bus_path, 'w') as f:
                json.dump(event_data, f, indent=2)
                
        except Exception as e:
            self.logger.error(f"❌ Error checking execution events: {str(e)}")
    
    def _check_mt5_update_events(self):
        """Check for MT5 update events"""
        try:
            if not self.event_bus_path.exists():
                return
            
            with open(self.event_bus_path, 'r') as f:
                event_data = json.load(f)
            
            # Look for unprocessed mt5:update events
            for event in event_data.get('events', []):
                if (event.get('type') == 'mt5:update' and 
                    not event.get('processed_by_compliance_core', False)):
                    
                    self._handle_mt5_update_event(event)
                    
                    # Mark as processed
                    event['processed_by_compliance_core'] = True
            
            # Save updated event bus
            with open(self.event_bus_path, 'w') as f:
                json.dump(event_data, f, indent=2)
                
        except Exception as e:
            self.logger.error(f"❌ Error checking MT5 update events: {str(e)}")
    
    def _handle_execution_event(self, event: Dict[str, Any]):
        """Handle an execution:placed event"""
        try:
            execution_data = event.get('data', {})
            
            self.logger.info(f"📥 Processing execution: {execution_data.get('signal_id')}")
            
            # Process the trade for compliance
            self._process_trade_for_compliance(execution_data)
            
            # Check for hedging
            self._check_for_hedging(execution_data)
            
            # Perform immediate compliance check
            self._perform_compliance_checks()
            
            self.total_trades_processed += 1
            
        except Exception as e:
            self.logger.error(f"❌ Error handling execution event: {str(e)}")
    
    def _handle_mt5_update_event(self, event: Dict[str, Any]):
        """Handle an MT5 update event"""
        try:
            mt5_data = event.get('data', {})
            
            # Update account balance if provided
            if 'balance' in mt5_data:
                old_balance = self.account_current_balance
                self.account_current_balance = float(mt5_data['balance'])
                
                # Update peak balance
                if self.account_current_balance > self.account_peak_balance:
                    self.account_peak_balance = self.account_current_balance
                
                # Calculate daily PnL and drawdown
                self._update_risk_metrics()
                
                self.logger.info(f"💰 Balance updated: ${old_balance} → ${self.account_current_balance}")
            
        except Exception as e:
            self.logger.error(f"❌ Error handling MT5 update event: {str(e)}")
    
    def _process_trade_for_compliance(self, trade_data: Dict[str, Any]):
        """Process a trade for compliance tracking"""
        try:
            # Add to daily trades
            today = datetime.now().date()
            trade_date = datetime.fromisoformat(trade_data['timestamp']).date()
            
            if trade_date == today:
                self.daily_trades.append(trade_data)
                self.current_trade_count = len(self.daily_trades)
            
            # Update position tracking for hedge detection
            symbol = trade_data.get('symbol')
            action = trade_data.get('action', '').upper()
            lot_size = float(trade_data.get('lot_size', 0))
            
            if symbol:
                if symbol not in self.position_tracking:
                    self.position_tracking[symbol] = {'BUY': 0.0, 'SELL': 0.0}
                
                if action in ['BUY', 'SELL']:
                    self.position_tracking[symbol][action] += lot_size
            
            # Calculate estimated PnL impact (simplified)
            # This would be more accurate with real-time price data
            entry_price = float(trade_data.get('entry_price', 0))
            current_price = entry_price  # Simplified - would use real MT5 data
            
            if action == 'BUY':
                pnl_impact = (current_price - entry_price) * lot_size * 100000
            else:
                pnl_impact = (entry_price - current_price) * lot_size * 100000
            
            self.current_daily_pnl += pnl_impact
            
        except Exception as e:
            self.logger.error(f"❌ Error processing trade for compliance: {str(e)}")
    
    def _check_for_hedging(self, trade_data: Dict[str, Any]):
        """Check for potential hedging violations"""
        try:
            symbol = trade_data.get('symbol')
            if not symbol or symbol not in self.position_tracking:
                return
            
            positions = self.position_tracking[symbol]
            
            # Check if we have both BUY and SELL positions
            if positions['BUY'] > 0 and positions['SELL'] > 0:
                self.hedging_attempts += 1
                self.logger.warning(f"⚠️ Potential hedging detected on {symbol}: BUY {positions['BUY']}, SELL {positions['SELL']}")
                
                # Log hedging violation
                hedging_violation = {
                    "symbol": symbol,
                    "buy_lots": positions['BUY'],
                    "sell_lots": positions['SELL'],
                    "timestamp": datetime.now().isoformat(),
                    "trade_id": trade_data.get('signal_id')
                }
                
                self._emit_event("compliance:hedging_detected", hedging_violation)
            
        except Exception as e:
            self.logger.error(f"❌ Error checking for hedging: {str(e)}")
    
    def _update_risk_metrics(self):
        """Update risk metrics based on current account state"""
        try:
            # Calculate drawdown from peak
            self.current_drawdown = max(0, self.account_peak_balance - self.account_current_balance)
            
            # Calculate daily PnL (from starting balance of the day)
            # This is simplified - should track actual start-of-day balance
            daily_start_balance = self.account_starting_balance  # Simplified
            self.current_daily_pnl = self.account_current_balance - daily_start_balance
            
        except Exception as e:
            self.logger.error(f"❌ Error updating risk metrics: {str(e)}")
    
    def _perform_compliance_checks(self):
        """Perform comprehensive compliance checks"""
        try:
            self.compliance_checks_performed += 1
            previous_status = self.compliance_status
            self.breach_reasons = []
            
            # Check daily loss limit
            if self.current_daily_pnl < -self.daily_loss_limit:
                self.breach_reasons.append(f"Daily loss limit exceeded: ${abs(self.current_daily_pnl):.2f} > ${self.daily_loss_limit}")
            
            # Check max drawdown
            if self.current_drawdown > self.max_drawdown_limit:
                self.breach_reasons.append(f"Max drawdown exceeded: ${self.current_drawdown:.2f} > ${self.max_drawdown_limit}")
            
            # Check daily trade count
            if self.current_trade_count > self.max_daily_trades:
                self.breach_reasons.append(f"Daily trade limit exceeded: {self.current_trade_count} > {self.max_daily_trades}")
            
            # Update compliance status
            if self.breach_reasons:
                self.compliance_status = "BREACH"
                self.is_trading_blocked = True
                
                # Emit breach event
                self._emit_event("compliance:breach", {
                    "reasons": self.breach_reasons,
                    "daily_pnl": self.current_daily_pnl,
                    "drawdown": self.current_drawdown,
                    "trade_count": self.current_trade_count,
                    "timestamp": datetime.now().isoformat()
                })
                
                if previous_status != "BREACH":
                    self.logger.critical(f"🚨 COMPLIANCE BREACH DETECTED: {', '.join(self.breach_reasons)}")
                
            else:
                self.compliance_status = "OK"
                self.is_trading_blocked = False
                
                # Emit OK event if we recovered from breach
                if previous_status == "BREACH":
                    self._emit_event("compliance:ok", {
                        "message": "Compliance status restored",
                        "timestamp": datetime.now().isoformat()
                    })
                    self.logger.info("✅ Compliance status restored")
            
            # Log compliance snapshot
            self._log_compliance_snapshot()
            
        except Exception as e:
            self.logger.error(f"❌ Error performing compliance checks: {str(e)}")
    
    def _log_compliance_snapshot(self):
        """Log a compliance snapshot"""
        try:
            snapshot = {
                "timestamp": datetime.now().isoformat(),
                "session_id": self.session_id,
                "compliance_status": self.compliance_status,
                "is_trading_blocked": self.is_trading_blocked,
                "breach_reasons": self.breach_reasons,
                "account_balance": self.account_current_balance,
                "peak_balance": self.account_peak_balance,
                "daily_pnl": self.current_daily_pnl,
                "drawdown": self.current_drawdown,
                "trade_count": self.current_trade_count,
                "daily_loss_limit": self.daily_loss_limit,
                "max_drawdown_limit": self.max_drawdown_limit,
                "hedging_attempts": self.hedging_attempts,
                "total_trades_processed": self.total_trades_processed
            }
            
            # Load existing log
            compliance_log = []
            if self.compliance_log_path.exists():
                with open(self.compliance_log_path, 'r') as f:
                    compliance_log = json.load(f)
            
            compliance_log.append(snapshot)
            
            # Keep only last 10000 entries
            if len(compliance_log) > 10000:
                compliance_log = compliance_log[-10000:]
            
            # Save updated log
            with open(self.compliance_log_path, 'w') as f:
                json.dump(compliance_log, f, indent=2)
                
        except Exception as e:
            self.logger.error(f"❌ Error logging compliance snapshot: {str(e)}")
    
    def _emit_event(self, event_type: str, data: Dict[str, Any]):
        """Emit an event to the EventBus"""
        try:
            event = {
                "type": event_type,
                "timestamp": datetime.now().isoformat(),
                "source": "GenesisComplianceCore",
                "session_id": self.session_id,
                "data": data
            }
            
            events = {"events": []}
            if self.event_bus_path.exists():
                with open(self.event_bus_path, 'r') as f:
                    events = json.load(f)
            
            events["events"].append(event)
            
            with open(self.event_bus_path, 'w') as f:
                json.dump(events, f, indent=2)
                
        except Exception as e:
            self.logger.error(f"❌ Error emitting event: {str(e)}")
    
    def _emit_telemetry(self):
        """Emit telemetry data"""
        try:
            telemetry_data = {
                "module": self.module_id,
                "timestamp": datetime.now().isoformat(),
                "session_id": self.session_id,
                "metrics": {
                    "daily_loss": abs(min(0, self.current_daily_pnl)),
                    "max_drawdown": self.current_drawdown,
                    "trade_count": self.current_trade_count,
                    "hedging_attempts": self.hedging_attempts,
                    "slippage_violations": self.slippage_violations,
                    "compliance_status": self.compliance_status,
                    "is_trading_blocked": self.is_trading_blocked,
                    "breach_count": len(self.breach_reasons),
                    "compliance_checks_performed": self.compliance_checks_performed,
                    "account_balance": self.account_current_balance,
                    "peak_balance": self.account_peak_balance
                }
            }
            
            # Load existing telemetry
            telemetry = {"telemetry": []}
            if self.telemetry_path.exists():
                with open(self.telemetry_path, 'r') as f:
                    telemetry = json.load(f)
            
            telemetry["telemetry"].append(telemetry_data)
            
            # Keep only last 1000 entries
            if len(telemetry["telemetry"]) > 1000:
                telemetry["telemetry"] = telemetry["telemetry"][-1000:]
            
            with open(self.telemetry_path, 'w') as f:
                json.dump(telemetry, f, indent=2)
                
        except Exception as e:
            self.logger.error(f"❌ Error emitting telemetry: {str(e)}")
    
    def get_compliance_status(self) -> Dict[str, Any]:
        """Get current compliance status"""
        return {
            "module_id": self.module_id,
            "version": self.version,
            "session_id": self.session_id,
            "is_running": self.is_running,
            "compliance_status": self.compliance_status,
            "is_trading_blocked": self.is_trading_blocked,
            "breach_reasons": self.breach_reasons,
            "account_balance": self.account_current_balance,
            "peak_balance": self.account_peak_balance,
            "daily_pnl": self.current_daily_pnl,
            "drawdown": self.current_drawdown,
            "trade_count": self.current_trade_count,
            "daily_loss_limit": self.daily_loss_limit,
            "max_drawdown_limit": self.max_drawdown_limit,
            "hedging_attempts": self.hedging_attempts,
            "total_trades_processed": self.total_trades_processed
        }
    
    def force_breach_simulation(self, breach_type: str = "daily_loss"):
        """Force a compliance breach for testing"""
        self.logger.warning(f"🧪 execute compliance breach: {breach_type}")
        
        if breach_type == "daily_loss":
            self.current_daily_pnl = -self.daily_loss_limit - 1000
        elif breach_type == "max_drawdown":
            self.current_drawdown = self.max_drawdown_limit + 1000
        elif breach_type == "trade_count":
            self.current_trade_count = self.max_daily_trades + 10
        
        # Trigger compliance check
        self._perform_compliance_checks()
    
    def reset_daily_metrics(self):
        """Reset daily metrics for new trading day"""
        self.logger.info("🔄 Resetting daily metrics for new trading day")
        
        self.current_daily_pnl = 0.0
        self.current_trade_count = 0
        self.daily_trades = []
        self.hedging_attempts = 0
        self.slippage_violations = 0
        self.position_tracking = {}
        
        # Reset compliance status
        self.compliance_status = "OK"
        self.breach_reasons = []
        self.is_trading_blocked = False
        
        self._emit_event("compliance:daily_reset", {
            "timestamp": datetime.now().isoformat(),
            "message": "Daily metrics reset"
        })


# Test and Validation Functions
def test_breach_simulation():
    """Test breach execute"""
    compliance = GenesisComplianceCore()
    
    # Test daily loss breach
    initial_status = compliance.compliance_status
    compliance.force_breach_simulation("daily_loss")
    assert compliance.compliance_status == "BREACH"
    assert compliance.is_trading_blocked == True
    
    # Reset and test drawdown breach
    compliance.reset_daily_metrics()
    compliance.force_breach_simulation("max_drawdown")
    assert compliance.compliance_status == "BREACH"
    
    print("✅ Breach execute test passed")


def test_real_time_pnl_aggregation():
    """Test real-time PnL aggregation"""
    compliance = GenesisComplianceCore()
    
    # execute a trade
    trade_data = {
        "signal_id": "TEST_001",
        "symbol": "EURUSD",
        "action": "BUY",
        "lot_size": 0.1,
        "entry_price": 1.1000,
        "timestamp": datetime.now().isoformat()
    }
    
    initial_count = compliance.current_trade_count
    compliance._process_trade_for_compliance(trade_data)
    
    assert compliance.current_trade_count == initial_count + 1
    print("✅ Real-time PnL aggregation test passed")


def test_hedge_detection():
    """Test hedge detection"""
    compliance = GenesisComplianceCore()
    
    # execute buy trade
    buy_trade = {
        "signal_id": "TEST_BUY",
        "symbol": "EURUSD",
        "action": "BUY",
        "lot_size": 0.1,
        "entry_price": 1.1000,
        "timestamp": datetime.now().isoformat()
    }
    
    # execute sell trade on same symbol
    sell_trade = {
        "signal_id": "TEST_SELL",
        "symbol": "EURUSD",
        "action": "SELL",
        "lot_size": 0.1,
        "entry_price": 1.1000,
        "timestamp": datetime.now().isoformat()
    }
    
    initial_hedging = compliance.hedging_attempts
    compliance._process_trade_for_compliance(buy_trade)
    compliance._check_for_hedging(buy_trade)
    compliance._process_trade_for_compliance(sell_trade)
    compliance._check_for_hedging(sell_trade)
    
    assert compliance.hedging_attempts > initial_hedging
    print("✅ Hedge detection test passed")


def main():
    """Main execution function"""
    try:
        # Run tests
        test_breach_simulation()
        test_real_time_pnl_aggregation()
        test_hedge_detection()
        
        # Initialize compliance core
        compliance = GenesisComplianceCore()
        compliance.start_monitoring()
        
        print(f"🚀 GENESIS GenesisComplianceCore v{compliance.version} is running...")
        print("📊 Status:", compliance.get_compliance_status())
        
        # Keep running
        try:
            while True:
                time.sleep(60)  # Status update every minute
                status = compliance.get_compliance_status()
                print(f"📊 Compliance: {status['compliance_status']}, "
                      f"PnL: ${status['daily_pnl']:.2f}, "
                      f"Drawdown: ${status['drawdown']:.2f}, "
                      f"Trades: {status['trade_count']}")
                
        except KeyboardInterrupt:
            print("\n🛑 Shutting down GenesisComplianceCore...")
            compliance.stop_monitoring()
            
    except Exception as e:
        print(f"❌ GenesisComplianceCore error: {str(e)}")
        raise


if __name__ == "__main__":
    main()

# <!-- @GENESIS_MODULE_END: genesis_compliance_core -->

    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        