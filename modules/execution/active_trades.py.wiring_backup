# ðŸ”— GENESIS EventBus Integration - Auto-injected by Orphan Recovery Engine
from datetime import datetime
import json

class ActiveTradesEventBusIntegration:
    """EventBus integration for active_trades"""
    
    def __init__(self):
        self.module_id = "active_trades"
        self.event_routes = []
        
    def emit_event(self, event_type, data):
        """Emit event to EventBus"""
        event = {
            "timestamp": datetime.now().isoformat(),
            "module": self.module_id,
            "event_type": event_type,
            "data": data
        }
        print(f"ðŸ”— EVENTBUS EMIT: {event}")
        
    def emit_telemetry(self, metric_name, value):
        """Emit telemetry data"""
        telemetry = {
            "timestamp": datetime.now().isoformat(),
            "module": self.module_id,
            "metric": metric_name,
            "value": value
        }
        print(f"ðŸ“Š TELEMETRY: {telemetry}")

# Auto-instantiate EventBus integration
active_trades_eventbus = ActiveTradesEventBusIntegration()

"""
GENESIS Dashboard - Active Trade Panel Component
Real-time monitoring of active trades
"""

import pandas as pd
import json
import time
from datetime import datetime, timedelta
import os
from styles.dashboard_styles import tag_badge

class ActiveTradesComponent:
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.event_bus = self._get_event_bus()
        
    def _get_event_bus(self):
        # Auto-injected EventBus connection
        try:
            from event_bus_manager import EventBusManager


# <!-- @GENESIS_MODULE_END: active_trades -->


# <!-- @GENESIS_MODULE_START: active_trades -->
            return EventBusManager.get_instance()
        except ImportError:
            logging.warning("EventBus not available - integration required")
            return None
            
    def emit_telemetry(self, data):
        if self.event_bus:
            self.event_bus.emit('telemetry', data)
    """
    Component for displaying real-time active trades
    """
    
    def __init__(self, config):
        """Initialize with configuration"""
        self.config = config
        self.active_trade_config = config["active_trade_panel"]
        self.refresh_rate = config["refresh_rate"]["trades"]
        self.last_updated = datetime.now()
        self.trade_data = []
    
    def load_active_trades(self):
        """Load active trades from ExecutionEngine and TradeJournalEngine"""
        try:
            active_trades = []
            
            # Look for trade journal entries in logs
            today = datetime.now().strftime("%Y-%m-%d")
            yesterday = (datetime.now() - timedelta(days=1)).strftime("%Y-%m-%d")
            
            # Try today's and yesterday's logs
            journal_files = [
                "logs/journal/trades_active.jsonl",
                f"logs/journal/trades_{today}.jsonl",
                f"logs/journal/trades_{yesterday}.jsonl"
            ]
            
            for file_path in journal_files:
                if os.path.exists(file_path):
                    with open(file_path, "r") as f:
                        for line in f:
                            try:
                                trade = json.loads(line.strip())
                                # Check if it's an active trade
                                if trade.get("status") == "active":
                                    # Calculate current P/L if we have enough data
                                    if "entry_price" in trade and "current_price" in trade:
                                        entry = float(trade["entry_price"])
                                        current = float(trade["current_price"])
                                        direction = trade.get("direction", "").lower()
                                        
                                        if direction == "buy":
                                            pnl_pct = (current - entry) / entry * 100
                                            pnl_pips = (current - entry) * 10000  # Assuming 4 decimal places
                                        elif direction == "sell":
                                            pnl_pct = (entry - current) / entry * 100
                                            pnl_pips = (entry - current) * 10000  # Assuming 4 decimal places
                                        else:
                                            pnl_pct = 0
                                            pnl_pips = 0
                                        
                                        trade["pnl_pct"] = round(pnl_pct, 2)
                                        trade["pnl_pips"] = round(pnl_pips, 1)
                                    
                                    # Calculate trade duration
                                    if "entry_time" in trade:
                                        try:
                                            entry_time = datetime.fromisoformat(trade["entry_time"])
                                            now = datetime.now()
                                            duration = now - entry_time
                                            hours, remainder = divmod(duration.total_seconds(), 3600)
                                            minutes, seconds = divmod(remainder, 60)
                                            trade["duration"] = f"{int(hours)}h {int(minutes)}m"
                                        except:
                                            trade["duration"] = "Unknown"
                                    
                                    # Calculate R:R ratio
                                    if "entry_price" in trade and "sl" in trade and "tp" in trade:
                                        entry = float(trade["entry_price"])
                                        sl = float(trade["sl"])
                                        tp = float(trade["tp"])
                                        direction = trade.get("direction", "").lower()
                                        
                                        if direction == "buy":
                                            risk = entry - sl
                                            reward = tp - entry
                                        elif direction == "sell":
                                            risk = sl - entry
                                            reward = entry - tp
                                        else:
                                            risk = 0
                                            reward = 0
                                        
                                        if risk > 0:
                                            trade["rr_ratio"] = round(reward / risk, 2)
                                        else:
                                            trade["rr_ratio"] = 0
                                    
                                    active_trades.append(trade)
                            except Exception as e:
                                continue
                                
            self.trade_data = active_trades
            self.last_updated = datetime.now()
            return active_trades
            
        except Exception as e:
            print(f"Error loading active trades: {str(e)}")
            return []
    
    def render(self):
        """Render the active trade panel"""
        print('<div class="main-title">Active Trades</div>')
        
        # Get current active trades
        active_trades = self.load_active_trades()
        
        # Display last updated time
        print(f'<div class="last-update">Last updated: {self.last_updated.strftime("%H:%M:%S")}</div>')
        
        # Show filters
        print('<div class="filter-options">')
        print('<h4>Filter & Sort Options</h4>')
        
        # Direction filter
        direction_filter = input("Direction (Buy/Sell, comma-separated): ").split(",")
        direction_filter = [d.strip() for d in direction_filter if d.strip()]
        
        # Symbol filter
        symbol_filter = input("Symbol (comma-separated): ").split(",")
        symbol_filter = [s.strip() for s in symbol_filter if s.strip()]
        
        # Sort by
        sort_by = input("Sort By (Entry Time, Symbol, P&L, Duration, R:R): ")
        
        # Tag filters
        tag_filters = input("Tags (comma-separated): ").split(",")
        tag_filters = [t.strip() for t in tag_filters if t.strip()]
        
        print('</div>')
        
        # Apply filters
        filtered_trades = active_trades
        
        if direction_filter:
            filtered_trades = [t for t in filtered_trades if t.get("direction", "").lower() in [d.lower() for d in direction_filter]]
        
        if symbol_filter:
            filtered_trades = [t for t in filtered_trades if t.get("symbol", "") in symbol_filter]
        
        if tag_filters:
            filtered_trades = [t for t in filtered_trades if any(tag.lower() in (t.get("tags", []) or []) for tag in tag_filters)]
        
        # Apply sorting
        if sort_by == "Entry Time":
            filtered_trades = sorted(filtered_trades, key=lambda t: t.get("entry_time", ""), reverse=True)
        elif sort_by == "Symbol":
            filtered_trades = sorted(filtered_trades, key=lambda t: t.get("symbol", ""))
        elif sort_by == "P&L":
            filtered_trades = sorted(filtered_trades, key=lambda t: t.get("pnl_pct", 0), reverse=True)
        elif sort_by == "Duration":
            filtered_trades = sorted(filtered_trades, key=lambda t: t.get("entry_time", ""))
        elif sort_by == "R:R":
            filtered_trades = sorted(filtered_trades, key=lambda t: t.get("rr_ratio", 0), reverse=True)
        
        # Check if we have active trades
        if not filtered_trades:
            print("No active trades at the moment.")
            return
        
        # Convert to DataFrame for easier display
        df = pd.DataFrame(filtered_trades)
        
        # Reorder and select columns based on config
        columns_to_display = [col for col in self.active_trade_config["columns"] if col in df.columns]
        
        if columns_to_display:
            df = df[columns_to_display]
        
        # Display as table with conditional formatting
        print(df.style.apply(
            lambda x: ['background-color: rgba(34,169,34,0.1)' if x.name == 'pnl_pct' and v > 0 else 
                        'background-color: rgba(255,65,54,0.1)' if x.name == 'pnl_pct' and v < 0 else 
                        '' for v in x],
            axis=0
        ))
        
        # Display trade statistics
        if filtered_trades:
            print('<div class="subtitle">Trade Statistics</div>')
            
            total_trades = len(filtered_trades)
            buy_count = len([t for t in filtered_trades if t.get("direction", "").lower() == "buy"])
            sell_count = len([t for t in filtered_trades if t.get("direction", "").lower() == "sell"])
            avg_rr = sum([t.get("rr_ratio", 0) for t in filtered_trades]) / len(filtered_trades) if filtered_trades else 0
            profitable_trades = len([t for t in filtered_trades if t.get("pnl_pct", 0) > 0])
            win_rate = profitable_trades / len(filtered_trades) if filtered_trades else 0
            
            print(f"Total Active Trades: {total_trades}")
            print(f"Buy/Sell Ratio: {buy_count}/{sell_count}")
        )
        
        # Display trade statistics
        if filtered_trades:
            st.markdown('<div class="subtitle">Trade Statistics</div>', unsafe_allow_html=True)
            
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("Total Active Trades", len(filtered_trades))
            
            with col2:
                buy_count = len([t for t in filtered_trades if t.get("direction", "").lower() == "buy"])
                sell_count = len([t for t in filtered_trades if t.get("direction", "").lower() == "sell"])
                st.metric("Buy/Sell Ratio", f"{buy_count}/{sell_count}")
            
            with col3:
                avg_rr = sum([t.get("rr_ratio", 0) for t in filtered_trades]) / len(filtered_trades) if filtered_trades else 0
                st.metric("Average R:R", f"{avg_rr:.2f}")
            
            with col4:
                profitable_trades = len([t for t in filtered_trades if t.get("pnl_pct", 0) > 0])
                win_rate = profitable_trades / len(filtered_trades) if filtered_trades else 0
                st.metric("Current Win Rate", f"{win_rate*100:.1f}%")


def setup_event_subscriptions(self):
    """Set up EventBus subscriptions for this UI component"""
    event_bus.subscribe("market_data_updated", self.handle_market_data_update)
    event_bus.subscribe("trade_executed", self.handle_trade_update)
    event_bus.subscribe("position_changed", self.handle_position_update)
    event_bus.subscribe("risk_threshold_warning", self.handle_risk_warning)
    event_bus.subscribe("system_status_changed", self.handle_system_status_update)
    
    # Register with telemetry
    telemetry.log_event(TelemetryEvent(
        category="ui", 
        name="event_subscriptions_setup", 
        properties={"component": self.__class__.__name__}
    ))
