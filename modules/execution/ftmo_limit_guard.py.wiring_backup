#!/usr/bin/env python3
"""
╔═══════════════════════════════════════════════════════════════════════════════╗
║                 🏦 GENESIS FTMO LIMIT GUARD v2.0                             ║
║                  INSTITUTIONAL FTMO COMPLIANCE ENFORCER                       ║
╚═══════════════════════════════════════════════════════════════════════════════╝

🎯 OBJECTIVE:
Enforce strict FTMO challenge and funded account rules
- Daily loss limits monitoring
- Maximum drawdown protection
- Trading time restrictions
- Risk per trade validation
- News trading restrictions

🏦 FTMO RULES ENFORCED:
1. Daily Loss Limit: 5% (challenge) / 5% (funded)
2. Maximum Drawdown: 10% (challenge) / 5% (funded)
3. Minimum Trading Days: 10 (challenge)
4. Profit Target: 8% (challenge phase 1) / 5% (phase 2)
5. No weekend gap trading
6. No high-impact news trading

🔗 EventBus Integration: Real-time monitoring
📊 Telemetry: All violations logged
✅ ARCHITECT MODE v3.0 COMPLIANT
"""

import json
import logging
from datetime import datetime, timedelta, time
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum


# <!-- @GENESIS_MODULE_END: ftmo_limit_guard -->


# <!-- @GENESIS_MODULE_START: ftmo_limit_guard -->

class FTMOAccountType(Enum):
    """FTMO account types"""
    CHALLENGE_PHASE_1 = "CHALLENGE_PHASE_1"
    CHALLENGE_PHASE_2 = "CHALLENGE_PHASE_2"
    FUNDED_ACCOUNT = "FUNDED_ACCOUNT"

class FTMOViolationType(Enum):
    """FTMO violation types"""
    DAILY_LOSS_EXCEEDED = "DAILY_LOSS_EXCEEDED"
    MAX_DRAWDOWN_EXCEEDED = "MAX_DRAWDOWN_EXCEEDED"
    INSUFFICIENT_TRADING_DAYS = "INSUFFICIENT_TRADING_DAYS"
    NEWS_TRADING_VIOLATION = "NEWS_TRADING_VIOLATION"
    WEEKEND_GAP_TRADING = "WEEKEND_GAP_TRADING"
    RISK_PER_TRADE_EXCEEDED = "RISK_PER_TRADE_EXCEEDED"
    PROFIT_TARGET_NOT_MET = "PROFIT_TARGET_NOT_MET"

@dataclass
class FTMOLimits:
    """FTMO account limits"""
    account_type: FTMOAccountType
    account_size: float
    daily_loss_limit: float  # As percentage of account
    max_drawdown: float     # As percentage of account
    profit_target: float    # As percentage of account
    min_trading_days: int
    max_risk_per_trade: float  # As percentage of account
    
class GenesisftmoLimitGuard:
    """
    🏦 GENESIS FTMO Limit Guard
    
    Enforces all FTMO compliance rules with real-time monitoring
    - Account limit tracking
    - Violation detection  
    - Risk calculation
    - News filtering
    """
    
    def __init__(self, account_type: FTMOAccountType, account_size: float, event_bus=None):
        self.event_bus = event_bus
        self.account_type = account_type
        self.account_size = account_size
        
        # Initialize FTMO limits based on account type
        self.limits = self._initialize_ftmo_limits()
        
        # Trading metrics
        self.daily_pnl = 0.0
        self.total_pnl = 0.0
        self.max_drawdown_reached = 0.0
        self.trading_days_count = 0
        self.today_trades = 0
        
        # State tracking
        self.current_equity = account_size
        self.daily_start_equity = account_size
        self.account_start_equity = account_size
        self.last_trading_day = None
        
        # News and time restrictions
        self.news_events = []
        self.restricted_trading_times = []
        
        # Violation tracking
        self.violations = []
        self.warnings = []
        
        self._initialize_eventbus_hooks()
        self._emit_telemetry("FTMO_GUARD_INITIALIZED", {
            "account_type": account_type.value,
            "account_size": account_size,
            "limits": self._get_limits_dict()
        })
    
    def _initialize_ftmo_limits(self) -> FTMOLimits:
        """Initialize FTMO limits based on account type"""
        if self.account_type == FTMOAccountType.CHALLENGE_PHASE_1:
            return FTMOLimits(
                account_type=self.account_type,
                account_size=self.account_size,
                daily_loss_limit=0.05,  # 5%
                max_drawdown=0.10,      # 10%
                profit_target=0.08,     # 8%
                min_trading_days=10,
                max_risk_per_trade=0.02 # 2%
            )
        elif self.account_type == FTMOAccountType.CHALLENGE_PHASE_2:
            return FTMOLimits(
                account_type=self.account_type,
                account_size=self.account_size,
                daily_loss_limit=0.05,  # 5%
                max_drawdown=0.10,      # 10%
                profit_target=0.05,     # 5%
                min_trading_days=10,
                max_risk_per_trade=0.02 # 2%
            )
        else:  # FUNDED_ACCOUNT
            return FTMOLimits(
                account_type=self.account_type,
                account_size=self.account_size,
                daily_loss_limit=0.05,  # 5%
                max_drawdown=0.05,      # 5%
                profit_target=0.0,      # No target for funded
                min_trading_days=0,      # No minimum for funded
                max_risk_per_trade=0.02  # 2%
            )
    
    def _initialize_eventbus_hooks(self):
        """Initialize EventBus subscriptions"""
        if self.event_bus:
            self.event_bus.subscribe("TradeExecutionRequest", self._validate_trade_request)
            self.event_bus.subscribe("TradeCompleted", self._track_trade_completion)
            self.event_bus.subscribe("EquityUpdate", self._update_equity)
            self.event_bus.subscribe("NewsEventScheduled", self._handle_news_event)
            self.event_bus.subscribe("TradingDayEnd", self._handle_day_end)
            self.event_bus.subscribe("NewTradingDay", self._handle_new_day)
    
    def validate_trade_request(self, trade_request: Dict[str, Any]) -> Tuple[bool, List[str], List[str]]:
        """
        🔍 Validate trade request against FTMO rules
        
        Returns:
            (is_valid: bool, violations: List[str], warnings: List[str])
        """
        violations = []
        warnings = []
        
        # Extract trade details
        risk_amount = trade_request.get('risk_amount', 0.0)
        trade_time = datetime.fromisoformat(trade_request.get('timestamp', datetime.now().isoformat()))
        
        # Check daily loss limit
        projected_daily_pnl = self.daily_pnl - risk_amount
        daily_loss_limit_amount = self.daily_start_equity * self.limits.daily_loss_limit
        
        if projected_daily_pnl < -daily_loss_limit_amount:
            violations.append(f"Daily loss limit would be exceeded: {projected_daily_pnl:.2f} < -{daily_loss_limit_amount:.2f}")
        
        # Check maximum drawdown
        projected_equity = self.current_equity - risk_amount
        max_drawdown_amount = self.account_start_equity * self.limits.max_drawdown
        drawdown_level = self.account_start_equity - projected_equity
        
        if drawdown_level > max_drawdown_amount:
            violations.append(f"Maximum drawdown would be exceeded: {drawdown_level:.2f} > {max_drawdown_amount:.2f}")
        
        # Check risk per trade
        max_risk_per_trade_amount = self.current_equity * self.limits.max_risk_per_trade
        if risk_amount > max_risk_per_trade_amount:
            violations.append(f"Risk per trade exceeded: {risk_amount:.2f} > {max_risk_per_trade_amount:.2f}")
        
        # Check news trading restrictions
        if self._is_news_restricted_time(trade_time):
            violations.append("Trading restricted due to high-impact news event")
        
        # Check weekend gap trading
        if self._is_weekend_gap_time(trade_time):
            violations.append("Weekend gap trading not allowed")
        
        # Warnings for approaching limits
        if projected_daily_pnl < -daily_loss_limit_amount * 0.8:
            warnings.append("Approaching daily loss limit (80% used)")
        
        if drawdown_level > max_drawdown_amount * 0.8:
            warnings.append("Approaching maximum drawdown (80% used)")
        
        # Log validation result
        self._emit_telemetry("TRADE_REQUEST_VALIDATED", {
            "trade_id": trade_request.get('id', 'unknown'),
            "is_valid": len(violations) == 0,
            "violations_count": len(violations),
            "warnings_count": len(warnings),
            "risk_amount": risk_amount,
            "projected_daily_pnl": projected_daily_pnl,
            "current_drawdown": drawdown_level
        })
        
        return len(violations) == 0, violations, warnings
    
    def track_trade_completion(self, trade_result: Dict[str, Any]):
        """Track completed trade and update metrics"""
        pnl = trade_result.get('pnl', 0.0)
        trade_time = datetime.fromisoformat(trade_result.get('timestamp', datetime.now().isoformat()))
        
        # Update metrics
        self.daily_pnl += pnl
        self.total_pnl += pnl
        self.current_equity += pnl
        self.today_trades += 1
        
        # Update drawdown tracking
        current_drawdown = self.account_start_equity - self.current_equity
        if current_drawdown > self.max_drawdown_reached:
            self.max_drawdown_reached = current_drawdown
        
        # Check for violations after trade completion
        self._check_post_trade_violations()
        
        # Check if this is a new trading day
        if self.last_trading_day != trade_time.date():
            if self.last_trading_day is not None:
                self.trading_days_count += 1
            self.last_trading_day = trade_time.date()
        
        self._emit_telemetry("TRADE_COMPLETION_TRACKED", {
            "trade_id": trade_result.get('id', 'unknown'),
            "pnl": pnl,
            "daily_pnl": self.daily_pnl,
            "total_pnl": self.total_pnl,
            "current_equity": self.current_equity,
            "current_drawdown": current_drawdown,
            "trading_days": self.trading_days_count
        })
    
    def _check_post_trade_violations(self):
        """Check for FTMO violations after trade completion"""
        violations = []
        
        # Check daily loss limit
        daily_loss_limit_amount = self.daily_start_equity * self.limits.daily_loss_limit
        if self.daily_pnl < -daily_loss_limit_amount:
            violations.append({
                "type": FTMOViolationType.DAILY_LOSS_EXCEEDED,
                "message": f"Daily loss limit exceeded: {self.daily_pnl:.2f} < -{daily_loss_limit_amount:.2f}",
                "severity": "CRITICAL"
            })
        
        # Check maximum drawdown
        max_drawdown_amount = self.account_start_equity * self.limits.max_drawdown
        current_drawdown = self.account_start_equity - self.current_equity
        if current_drawdown > max_drawdown_amount:
            violations.append({
                "type": FTMOViolationType.MAX_DRAWDOWN_EXCEEDED,
                "message": f"Maximum drawdown exceeded: {current_drawdown:.2f} > {max_drawdown_amount:.2f}",
                "severity": "CRITICAL"
            })
        
        # Process violations
        for violation in violations:
            self.violations.append(violation)
            
            # Emit violation event
            if self.event_bus:
                self.event_bus.emit("FTMOViolation", violation)
            
            self._emit_telemetry("FTMO_VIOLATION", violation)
    
    def _is_news_restricted_time(self, trade_time: datetime) -> bool:
        """Check if trading is restricted due to news"""
        for news_event in self.news_events:
            event_time = datetime.fromisoformat(news_event['time'])
            restriction_start = event_time - timedelta(minutes=news_event.get('before_minutes', 15))
            restriction_end = event_time + timedelta(minutes=news_event.get('after_minutes', 15))
            
            if restriction_start <= trade_time <= restriction_end:
                return True
        
        return False
    
    def _is_weekend_gap_time(self, trade_time: datetime) -> bool:
        """Check if trading time falls within weekend gap restrictions"""
        # Weekend gap typically Friday 21:00 GMT to Sunday 21:00 GMT
        weekday = trade_time.weekday()
        hour = trade_time.hour
        
        # Friday after 21:00 GMT
        if weekday == 4 and hour >= 21:
            return True
        
        # Saturday (all day)
        if weekday == 5:
            return True
        
        # Sunday before 21:00 GMT
        if weekday == 6 and hour < 21:
            return True
        
        return False
    
    def get_account_status(self) -> Dict[str, Any]:
        """Get comprehensive account status"""
        daily_loss_limit_amount = self.daily_start_equity * self.limits.daily_loss_limit
        max_drawdown_amount = self.account_start_equity * self.limits.max_drawdown
        current_drawdown = self.account_start_equity - self.current_equity
        
        return {
            "account_type": self.account_type.value,
            "account_size": self.account_size,
            "current_equity": self.current_equity,
            "daily_pnl": self.daily_pnl,
            "total_pnl": self.total_pnl,
            "trading_days_count": self.trading_days_count,
            "today_trades": self.today_trades,
            "limits": {
                "daily_loss_limit": daily_loss_limit_amount,
                "daily_loss_used": abs(min(0, self.daily_pnl)),
                "daily_loss_remaining": daily_loss_limit_amount + min(0, self.daily_pnl),
                "max_drawdown_limit": max_drawdown_amount,
                "current_drawdown": current_drawdown,
                "drawdown_remaining": max_drawdown_amount - current_drawdown,
                "profit_target": self.account_start_equity * self.limits.profit_target,
                "profit_progress": self.total_pnl
            },
            "violations": len(self.violations),
            "warnings": len(self.warnings),
            "is_compliant": len(self.violations) == 0
        }
    
    def _get_limits_dict(self) -> Dict[str, Any]:
        """Get limits as dictionary"""
        return {
            "daily_loss_limit_pct": self.limits.daily_loss_limit * 100,
            "max_drawdown_pct": self.limits.max_drawdown * 100,
            "profit_target_pct": self.limits.profit_target * 100,
            "min_trading_days": self.limits.min_trading_days,
            "max_risk_per_trade_pct": self.limits.max_risk_per_trade * 100
        }
    
    def _validate_trade_request(self, event_data: Dict[str, Any]):
        """EventBus handler for trade validation"""
        is_valid, violations, warnings = self.validate_trade_request(event_data)
        
        if self.event_bus:
            self.event_bus.emit("FTMOValidationResult", {
                "trade_id": event_data.get('id', 'unknown'),
                "is_valid": is_valid,
                "violations": violations,
                "warnings": warnings
            })
    
    def _track_trade_completion(self, event_data: Dict[str, Any]):
        """EventBus handler for trade completion"""
        self.track_trade_completion(event_data)
    
    def _update_equity(self, event_data: Dict[str, Any]):
        """EventBus handler for equity updates"""
        new_equity = event_data.get('equity', self.current_equity)
        self.current_equity = new_equity
        
        self._emit_telemetry("EQUITY_UPDATED", {
            "new_equity": new_equity,
            "change": new_equity - self.current_equity
        })
    
    def _handle_news_event(self, event_data: Dict[str, Any]):
        """EventBus handler for news events"""
        if event_data.get('impact', '') in ['HIGH', 'CRITICAL']:
            self.news_events.append(event_data)
            
            self._emit_telemetry("HIGH_IMPACT_NEWS_SCHEDULED", {
                "event_time": event_data.get('time'),
                "impact": event_data.get('impact'),
                "currency": event_data.get('currency')
            })
    
    def _handle_day_end(self, event_data: Dict[str, Any]):
        """EventBus handler for trading day end"""
        self._emit_telemetry("TRADING_DAY_END", {
            "daily_pnl": self.daily_pnl,
            "trades_today": self.today_trades,
            "trading_days_total": self.trading_days_count
        })
    
    def _handle_new_day(self, event_data: Dict[str, Any]):
        """EventBus handler for new trading day"""
        # Reset daily metrics
        self.daily_pnl = 0.0
        self.today_trades = 0
        self.daily_start_equity = self.current_equity
        
        # Clear expired news events
        current_time = datetime.now()
        self.news_events = [
            event for event in self.news_events 
            if datetime.fromisoformat(event['time']) > current_time - timedelta(hours=24)
        ]
        
        self._emit_telemetry("NEW_TRADING_DAY", {
            "daily_start_equity": self.daily_start_equity,
            "trading_days_count": self.trading_days_count
        })
    
    def _emit_telemetry(self, event_type: str, data: Dict[str, Any]):
        """Emit telemetry event"""
        telemetry_data = {
            "module": "ftmo_limit_guard",
            "event_type": event_type,
            "timestamp": datetime.now().isoformat(),
            "data": data
        }
        
        if self.event_bus:
            self.event_bus.emit("telemetry", telemetry_data)
        
        logging.info(f"🏦 FTMO-GUARD {event_type}: {data}")

if __name__ == "__main__":
    # Test FTMO limit guard
    print("🏦 Testing GENESIS FTMO Limit Guard")
    
    guard = GenesisftmoLimitGuard(
        FTMOAccountType.CHALLENGE_PHASE_1,
        10000.0  # $10k challenge account
    )
    
    # Test normal trade
    test_trade = {
        'id': 'TEST_001',
        'risk_amount': 150.0,  # 1.5% risk
        'timestamp': datetime.now().isoformat()
    }
    
    is_valid, violations, warnings = guard.validate_trade_request(test_trade)
    print(f"Normal trade valid: {is_valid}")
    print(f"Violations: {violations}")
    print(f"Warnings: {warnings}")
    
    # Test high risk trade
    high_risk_trade = {
        'id': 'TEST_002',
        'risk_amount': 300.0,  # 3% risk (too high)
        'timestamp': datetime.now().isoformat()
    }
    
    is_valid, violations, warnings = guard.validate_trade_request(high_risk_trade)
    print(f"High risk trade valid: {is_valid}")
    print(f"Violations: {violations}")
    
    print(f"Account status: {guard.get_account_status()}")
