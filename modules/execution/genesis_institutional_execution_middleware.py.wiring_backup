#!/usr/bin/env python3
"""
üß† GENESIS INSTITUTIONAL EXECUTION MIDDLEWARE - LIMIT-ONLY ORDER STRUCTURING
============================================================================

@GENESIS_CATEGORY: INSTITUTIONAL.EXECUTION
@GENESIS_TELEMETRY: ENABLED
@GENESIS_EVENTBUS: EMIT+CONSUME

OBJECTIVE: Advanced execution middleware with limit-only order management
- Institutional-grade order structuring (no market orders)
- Smart limit order placement with slippage protection
- Multi-stage execution for large positions
- Latency-optimized order routing (<10ms execution)
- FTMO-compliant execution controls
- Advanced order types (iceberg, TWAP, hidden liquidity)
- Real-time execution monitoring and adjustment

EXECUTION FEATURES:
- Limit-only entry and exit orders
- Dynamic price improvement seeking
- Partial fill management
- Order book analysis for optimal placement
- Time-weighted average price (TWAP) execution
- Volume-weighted average price (VWAP) execution
- Iceberg orders for large positions
- Hidden liquidity detection and utilization

COMPLIANCE: ARCHITECT MODE v3.0 ENFORCED
============================================================================
"""

import numpy as np
import pandas as pd
import threading
import time
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple, NamedTuple
from collections import defaultdict, deque
from dataclasses import dataclass, asdict
from enum import Enum
import uuid
import asyncio
from decimal import Decimal, ROUND_DOWN

# GENESIS EventBus Integration
try:
    from hardened_event_bus import get_event_bus, emit_event, subscribe_to_event, register_route
except ImportError:
    from event_bus import get_event_bus, emit_event, subscribe_to_event, register_route


# <!-- @GENESIS_MODULE_END: genesis_institutional_execution_middleware -->


# <!-- @GENESIS_MODULE_START: genesis_institutional_execution_middleware -->

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(levelname)s | GENESIS-EXECUTION | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger("genesis_execution_middleware")

class OrderType(Enum):
    """Order type enumeration"""
    LIMIT = "limit"
    STOP_LIMIT = "stop_limit"
    ICEBERG = "iceberg"
    TWAP = "twap"
    VWAP = "vwap"
    HIDDEN = "hidden"

class OrderStatus(Enum):
    """Order status enumeration"""
    PENDING = "pending"
    PLACED = "placed"
    PARTIALLY_FILLED = "partially_filled"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"
    EXPIRED = "expired"

class ExecutionStrategy(Enum):
    """Execution strategy enumeration"""
    IMMEDIATE = "immediate"
    PASSIVE = "passive"
    AGGRESSIVE = "aggressive"
    STEALTH = "stealth"
    ICEBERG = "iceberg"
    TIME_WEIGHTED = "time_weighted"

class OrderSide(Enum):
    """Order side enumeration"""
    BUY = "buy"
    SELL = "sell"

@dataclass
class MarketData:
    """Real-time market data"""
    symbol: str
    bid: float
    ask: float
    spread: float
    bid_size: float
    ask_size: float
    last_price: float
    volume: float
    timestamp: str
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

@dataclass
class OrderBookLevel:
    """Order book level data"""
    price: float
    size: float
    orders: int
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

@dataclass
class OrderBook:
    """Complete order book data"""
    symbol: str
    bids: List[OrderBookLevel]
    asks: List[OrderBookLevel]
    timestamp: str
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "symbol": self.symbol,
            "bids": [level.to_dict() for level in self.bids],
            "asks": [level.to_dict() for level in self.asks],
            "timestamp": self.timestamp
        }

@dataclass
class LimitOrder:
    """Limit order structure"""
    order_id: str
    symbol: str
    side: OrderSide
    size: float
    price: float
    order_type: OrderType
    execution_strategy: ExecutionStrategy
    
    # Timing constraints
    time_in_force: str  # GTC, IOC, FOK, GTD
    expiry_time: Optional[str]
    
    # Advanced parameters
    iceberg_size: Optional[float]  # For iceberg orders
    min_fill_size: Optional[float]  # Minimum fill size
    max_slippage: float  # Maximum allowed slippage
    hidden_size: Optional[float]  # Hidden liquidity size
    
    # TWAP/VWAP parameters
    execution_duration: Optional[int]  # Duration in seconds
    slice_size: Optional[float]  # Size per slice
    slice_interval: Optional[int]  # Interval between slices
    
    # Status and tracking
    status: OrderStatus
    filled_size: float
    avg_fill_price: float
    remaining_size: float
    
    # Metadata
    parent_strategy_id: Optional[str]
    risk_approved: bool
    created_time: str
    updated_time: str
    
    def to_dict(self) -> Dict[str, Any]:
        result = asdict(self)
        result['side'] = self.side.value
        result['order_type'] = self.order_type.value
        result['execution_strategy'] = self.execution_strategy.value
        result['status'] = self.status.value
        return result

@dataclass
class ExecutionResult:
    """Execution result data"""
    order_id: str
    symbol: str
    side: str
    executed_size: float
    execution_price: float
    execution_time: str
    execution_latency_ms: float
    slippage_pips: float
    commission: float
    
    # Quality metrics
    price_improvement: float
    liquidity_consumed: float
    market_impact: float
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

class GenesisInstitutionalExecutionMiddleware:
    """
    GENESIS Institutional Execution Middleware
    
    Advanced limit-only order execution with institutional features
    """
    
    def __init__(self, config_path: Optional[str] = None):
        """Initialize execution middleware"""
        self.config = self._load_config(config_path)
        self.running = False
        self.lock = threading.Lock()
        
        # Order management
        self.active_orders = {}  # order_id -> LimitOrder
        self.order_history = deque(maxlen=1000)
        self.execution_queue = deque()
        
        # Market data
        self.market_data = {}  # symbol -> MarketData
        self.order_books = {}  # symbol -> OrderBook
        self.price_history = defaultdict(lambda: deque(maxlen=100))
        
        # Execution tracking
        self.execution_results = []
        self.performance_metrics = {
            'orders_processed': 0,
            'orders_filled': 0,
            'orders_cancelled': 0,
            'total_volume_executed': 0.0,
            'average_execution_latency_ms': 0.0,
            'average_slippage_pips': 0.0,
            'price_improvement_total': 0.0,
            'fill_rate': 0.0,
            'execution_success_rate': 0.0
        }
        
        # Threading
        self.executor_threads = {}
        
        # EventBus registration
        self._register_event_routes()
        
        logger.info("üß† GENESIS Institutional Execution Middleware initialized")

    def _load_config(self, config_path: Optional[str]) -> Dict[str, Any]:
        """Load execution middleware configuration"""
        default_config = {
            'symbols': ['EURUSD', 'GBPUSD', 'USDJPY', 'AUDUSD'],
            'max_slippage_pips': 2.0,
            'default_time_in_force': 'GTC',
            'order_timeout_seconds': 300,
            'min_order_size': 0.01,
            'max_order_size': 10.0,
            'iceberg_min_size': 1.0,
            'twap_min_duration': 60,  # seconds
            'vwap_min_duration': 300,  # seconds
            'price_improvement_threshold': 0.1,  # pips
            'hidden_liquidity_threshold': 0.5,
            'execution_monitoring_interval': 1,  # seconds
            'order_book_depth': 10,
            'latency_target_ms': 10,
            'retry_attempts': 3,
            'retry_delay_ms': 100,
            'telemetry_interval': 60
        }
        
        if config_path:
            try:
                with open(config_path, 'r') as f:
                    config = json.load(f)
                default_config.update(config)
            except Exception as e:
                logger.warning(f"Failed to load config from {config_path}: {e}")
        
        return default_config

    def _register_event_routes(self):
        """Register EventBus routes for institutional compliance"""
        try:
            # Input routes
            register_route("MT5TickData", "MT5Connector", "ExecutionMiddleware")
            register_route("RiskDecision", "RiskEngine", "ExecutionMiddleware")
            register_route("ExecutionRequest", "StrategyEngine", "ExecutionMiddleware")
            register_route("OrderBookUpdate", "MT5Connector", "ExecutionMiddleware")
            register_route("CancelOrderRequest", "*", "ExecutionMiddleware")
            
            # Output routes  
            register_route("OrderPlaced", "ExecutionMiddleware", "RiskEngine")
            register_route("OrderFilled", "ExecutionMiddleware", "RiskEngine")
            register_route("OrderCancelled", "ExecutionMiddleware", "RiskEngine")
            register_route("ExecutionTelemetry", "ExecutionMiddleware", "TelemetryEngine")
            register_route("ExecutionError", "ExecutionMiddleware", "TelemetryEngine")
            
            # Subscribe to events
            subscribe_to_event("MT5TickData", self._handle_market_data)
            subscribe_to_event("RiskDecision", self._handle_risk_decision)
            subscribe_to_event("ExecutionRequest", self._handle_execution_request)
            subscribe_to_event("OrderBookUpdate", self._handle_order_book_update)
            subscribe_to_event("CancelOrderRequest", self._handle_cancel_request)
            subscribe_to_event("EmergencyShutdown", self._handle_emergency_shutdown)
            
            logger.info("‚úÖ Execution Middleware EventBus routes registered")
            
        except Exception as e:
            logger.error(f"‚ùå Failed to register EventBus routes: {e}")

    def start(self) -> bool:
        """Start execution middleware"""
        try:
            self.running = True
            
            # Start execution processing thread
            execution_thread = threading.Thread(
                target=self._execution_processing_loop,
                name="ExecutionMiddleware-Processing",
                daemon=True
            )
            execution_thread.start()
            self.executor_threads['processing'] = execution_thread
            
            # Start order monitoring thread
            monitoring_thread = threading.Thread(
                target=self._order_monitoring_loop,
                name="ExecutionMiddleware-Monitoring", 
                daemon=True
            )
            monitoring_thread.start()
            self.executor_threads['monitoring'] = monitoring_thread
            
            # Start telemetry thread
            telemetry_thread = threading.Thread(
                target=self._telemetry_loop,
                name="ExecutionMiddleware-Telemetry",
                daemon=True
            )
            telemetry_thread.start()
            self.executor_threads['telemetry'] = telemetry_thread
            
            logger.info("üöÄ GENESIS Execution Middleware started")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Failed to start execution middleware: {e}")
            return False

    def _execution_processing_loop(self):
        """Main execution processing loop"""
        while self.running:
            try:
                start_time = time.perf_counter()
                
                # Process execution queue
                self._process_execution_queue()
                
                # Update active orders
                self._update_active_orders()
                
                # Check for order timeouts
                self._check_order_timeouts()
                
                # Control loop frequency
                processing_time = (time.perf_counter() - start_time) * 1000
                if processing_time < self.config.get('execution_monitoring_interval', 1) * 1000:
                    sleep_time = (self.config.get('execution_monitoring_interval', 1) * 1000 - processing_time) / 1000
                    time.sleep(max(0, sleep_time))
                    
            except Exception as e:
                logger.error(f"‚ùå Error in execution processing loop: {e}")
                time.sleep(1)

    def _process_execution_queue(self):
        """Process pending execution requests"""
        while self.execution_queue and self.running:
            try:
                execution_request = self.execution_queue.popleft()
                self._execute_order_request(execution_request)
                
            except Exception as e:
                logger.error(f"‚ùå Error processing execution queue: {e}")

    def _execute_order_request(self, request: Dict[str, Any]):
        """Execute an order request"""
        try:
            start_time = time.perf_counter()
              # Extract request details
            symbol = request.get('symbol', '')
            side = OrderSide(request.get('side', 'buy'))
            size = float(request.get('size', 0.0))
            execution_strategy = ExecutionStrategy(request.get('execution_strategy', 'passive'))
            max_slippage = request.get('max_slippage', self.config.get('max_slippage_pips', 2.0))
            
            # Get current market data
            if symbol not in self.market_data:
                logger.error(f"‚ùå No market data available for {symbol}")
                return
            
            market = self.market_data[symbol]
            
            # Determine optimal execution method
            if execution_strategy == ExecutionStrategy.ICEBERG:
                self._execute_iceberg_order(request, market)
            elif execution_strategy == ExecutionStrategy.TIME_WEIGHTED:
                self._execute_twap_order(request, market)
            elif execution_strategy == ExecutionStrategy.STEALTH:
                self._execute_hidden_order(request, market)
            else:
                self._execute_standard_limit_order(request, market)
            
            # Track execution latency
            execution_latency = (time.perf_counter() - start_time) * 1000
            self._update_latency_metrics(execution_latency)
            
        except Exception as e:
            logger.error(f"‚ùå Error executing order request: {e}")
            self._emit_execution_error(request, str(e))

    def _execute_standard_limit_order(self, request: Dict[str, Any], market: MarketData):
        """Execute standard limit order"""
        try:
            symbol = request.get('symbol')
            side = OrderSide(request.get('side'))
            size = request.get('size')
            
            # Calculate optimal limit price
            optimal_price = self._calculate_optimal_limit_price(symbol, side, request)
            
            # Create limit order
            order = LimitOrder(
                order_id=str(uuid.uuid4()),
                symbol=symbol,
                side=side,
                size=size,
                price=optimal_price,
                order_type=OrderType.LIMIT,
                execution_strategy=ExecutionStrategy(request.get('execution_strategy', 'passive')),
                time_in_force=request.get('time_in_force', self.config.get('default_time_in_force', 'GTC')),
                expiry_time=self._calculate_expiry_time(request),
                iceberg_size=None,
                min_fill_size=request.get('min_fill_size'),
                max_slippage=request.get('max_slippage', self.config.get('max_slippage_pips', 2.0)),
                hidden_size=None,
                execution_duration=None,
                slice_size=None,
                slice_interval=None,
                status=OrderStatus.PENDING,
                filled_size=0.0,
                avg_fill_price=0.0,
                remaining_size=size,
                parent_strategy_id=request.get('strategy_id'),
                risk_approved=request.get('risk_approved', False),
                created_time=datetime.now().isoformat(),
                updated_time=datetime.now().isoformat()
            )
            
            # Place order
            if self._place_limit_order(order):
                logger.info(f"üìä Limit order placed: {symbol} {side.value} {size} @ {optimal_price}")
            else:
                logger.error(f"‚ùå Failed to place limit order: {symbol}")
                
        except Exception as e:
            logger.error(f"‚ùå Error executing standard limit order: {e}")

    def _execute_iceberg_order(self, request: Dict[str, Any], market: MarketData):
        """Execute iceberg order (large order broken into smaller pieces)"""
        try:
            symbol = request.get('symbol')
            side = OrderSide(request.get('side'))
            total_size = request.get('size')
            iceberg_size = request.get('iceberg_size', self.config.get('iceberg_min_size', 1.0))
            
            # Calculate number of slices
            num_slices = int(np.ceil(total_size / iceberg_size))
            
            logger.info(f"üßä Executing iceberg order: {symbol} {side.value} {total_size} "
                       f"in {num_slices} slices of {iceberg_size}")
            
            # Create parent iceberg order
            parent_order = LimitOrder(
                order_id=str(uuid.uuid4()),
                symbol=symbol,
                side=side,
                size=total_size,
                price=self._calculate_optimal_limit_price(symbol, side, request),
                order_type=OrderType.ICEBERG,
                execution_strategy=ExecutionStrategy.ICEBERG,
                time_in_force=request.get('time_in_force', 'GTC'),
                expiry_time=self._calculate_expiry_time(request),
                iceberg_size=iceberg_size,
                min_fill_size=request.get('min_fill_size'),
                max_slippage=request.get('max_slippage', 2.0),
                hidden_size=None,
                execution_duration=None,
                slice_size=iceberg_size,
                slice_interval=request.get('slice_interval', 30),
                status=OrderStatus.PENDING,
                filled_size=0.0,
                avg_fill_price=0.0,
                remaining_size=total_size,
                parent_strategy_id=request.get('strategy_id'),
                risk_approved=request.get('risk_approved', False),
                created_time=datetime.now().isoformat(),
                updated_time=datetime.now().isoformat()
            )
            
            # Store parent order
            with self.lock:
                self.active_orders[parent_order.order_id] = parent_order
            
            # Start iceberg execution in separate thread
            iceberg_thread = threading.Thread(
                target=self._execute_iceberg_slices,
                args=(parent_order,),
                name=f"Iceberg-{parent_order.order_id[:8]}",
                daemon=True
            )
            iceberg_thread.start()
            
        except Exception as e:
            logger.error(f"‚ùå Error executing iceberg order: {e}")

    def _execute_iceberg_slices(self, parent_order: LimitOrder):
        """Execute iceberg order slices"""
        try:
            while parent_order.remaining_size > 0 and self.running:
                # Calculate slice size
                slice_size = min(parent_order.iceberg_size, parent_order.remaining_size)
                
                # Create slice order
                slice_order = LimitOrder(
                    order_id=str(uuid.uuid4()),
                    symbol=parent_order.symbol,
                    side=parent_order.side,
                    size=slice_size,
                    price=self._calculate_optimal_limit_price(parent_order.symbol, parent_order.side, {}),
                    order_type=OrderType.LIMIT,
                    execution_strategy=ExecutionStrategy.PASSIVE,
                    time_in_force=parent_order.time_in_force,
                    expiry_time=parent_order.expiry_time,
                    iceberg_size=None,
                    min_fill_size=None,
                    max_slippage=parent_order.max_slippage,
                    hidden_size=None,
                    execution_duration=None,
                    slice_size=None,
                    slice_interval=None,
                    status=OrderStatus.PENDING,
                    filled_size=0.0,
                    avg_fill_price=0.0,
                    remaining_size=slice_size,
                    parent_strategy_id=parent_order.order_id,  # Link to parent
                    risk_approved=True,
                    created_time=datetime.now().isoformat(),
                    updated_time=datetime.now().isoformat()
                )
                
                # Place slice order
                if self._place_limit_order(slice_order):
                    logger.info(f"üßä Iceberg slice placed: {slice_order.symbol} {slice_size} @ {slice_order.price}")
                    
                    # Wait for slice to fill or timeout
                    self._wait_for_slice_completion(slice_order, parent_order)
                
                # Wait before next slice
                if parent_order.slice_interval:
                    time.sleep(parent_order.slice_interval)
                    
        except Exception as e:
            logger.error(f"‚ùå Error executing iceberg slices: {e}")

    def _execute_twap_order(self, request: Dict[str, Any], market: MarketData):
        """Execute Time-Weighted Average Price (TWAP) order"""
        try:
            symbol = request.get('symbol')
            side = OrderSide(request.get('side'))
            total_size = request.get('size')
            duration = request.get('execution_duration', self.config.get('twap_min_duration', 60))
            
            # Calculate slice parameters
            num_slices = max(1, duration // 30)  # 30-second intervals
            slice_size = total_size / num_slices
            slice_interval = duration / num_slices
            
            logger.info(f"‚è±Ô∏è Executing TWAP order: {symbol} {side.value} {total_size} "
                       f"over {duration}s in {num_slices} slices")
            
            # Create TWAP parent order
            twap_order = LimitOrder(
                order_id=str(uuid.uuid4()),
                symbol=symbol,
                side=side,
                size=total_size,
                price=0.0,  # Price will be determined for each slice
                order_type=OrderType.TWAP,
                execution_strategy=ExecutionStrategy.TIME_WEIGHTED,
                time_in_force='IOC',  # Immediate or Cancel for TWAP slices
                expiry_time=self._calculate_expiry_time(request),
                iceberg_size=None,
                min_fill_size=None,
                max_slippage=request.get('max_slippage', 2.0),
                hidden_size=None,
                execution_duration=duration,
                slice_size=slice_size,
                slice_interval=slice_interval,
                status=OrderStatus.PENDING,
                filled_size=0.0,
                avg_fill_price=0.0,
                remaining_size=total_size,
                parent_strategy_id=request.get('strategy_id'),
                risk_approved=request.get('risk_approved', False),
                created_time=datetime.now().isoformat(),
                updated_time=datetime.now().isoformat()
            )
            
            # Store parent order
            with self.lock:
                self.active_orders[twap_order.order_id] = twap_order
            
            # Start TWAP execution in separate thread
            twap_thread = threading.Thread(
                target=self._execute_twap_slices,
                args=(twap_order,),
                name=f"TWAP-{twap_order.order_id[:8]}",
                daemon=True
            )
            twap_thread.start()
            
        except Exception as e:
            logger.error(f"‚ùå Error executing TWAP order: {e}")

    def _execute_twap_slices(self, twap_order: LimitOrder):
        """Execute TWAP order slices"""
        try:
            start_time = time.time()
            slice_count = 0
            max_slices = int(twap_order.execution_duration / twap_order.slice_interval)
            
            while (twap_order.remaining_size > 0 and 
                   slice_count < max_slices and 
                   self.running):
                
                # Calculate current slice size
                remaining_slices = max_slices - slice_count
                slice_size = min(twap_order.slice_size, twap_order.remaining_size / remaining_slices)
                
                # Get current market price
                current_price = self._get_current_market_price(twap_order.symbol, twap_order.side)
                
                # Create slice order
                slice_order = LimitOrder(
                    order_id=str(uuid.uuid4()),
                    symbol=twap_order.symbol,
                    side=twap_order.side,
                    size=slice_size,
                    price=current_price,
                    order_type=OrderType.LIMIT,
                    execution_strategy=ExecutionStrategy.PASSIVE,
                    time_in_force='IOC',
                    expiry_time=None,
                    iceberg_size=None,
                    min_fill_size=None,
                    max_slippage=twap_order.max_slippage,
                    hidden_size=None,
                    execution_duration=None,
                    slice_size=None,
                    slice_interval=None,
                    status=OrderStatus.PENDING,
                    filled_size=0.0,
                    avg_fill_price=0.0,
                    remaining_size=slice_size,
                    parent_strategy_id=twap_order.order_id,
                    risk_approved=True,
                    created_time=datetime.now().isoformat(),
                    updated_time=datetime.now().isoformat()
                )
                
                # Place slice order
                if self._place_limit_order(slice_order):
                    logger.info(f"‚è±Ô∏è TWAP slice {slice_count + 1}/{max_slices}: "
                               f"{slice_order.symbol} {slice_size} @ {current_price}")
                
                slice_count += 1
                
                # Wait for next slice interval
                if slice_count < max_slices:
                    time.sleep(twap_order.slice_interval)
                    
        except Exception as e:
            logger.error(f"‚ùå Error executing TWAP slices: {e}")

    def _execute_hidden_order(self, request: Dict[str, Any], market: MarketData):
        """Execute hidden liquidity order"""
        try:
            symbol = request.get('symbol')
            side = OrderSide(request.get('side'))
            size = request.get('size')
            hidden_size = request.get('hidden_size', size * 0.1)  # Hide 90% of order
            
            # Create hidden order
            hidden_order = LimitOrder(
                order_id=str(uuid.uuid4()),
                symbol=symbol,
                side=side,
                size=size,
                price=self._calculate_hidden_price(symbol, side),
                order_type=OrderType.HIDDEN,
                execution_strategy=ExecutionStrategy.STEALTH,
                time_in_force=request.get('time_in_force', 'GTC'),
                expiry_time=self._calculate_expiry_time(request),
                iceberg_size=None,
                min_fill_size=None,
                max_slippage=request.get('max_slippage', 1.0),
                hidden_size=hidden_size,
                execution_duration=None,
                slice_size=None,
                slice_interval=None,
                status=OrderStatus.PENDING,
                filled_size=0.0,
                avg_fill_price=0.0,
                remaining_size=size,
                parent_strategy_id=request.get('strategy_id'),
                risk_approved=request.get('risk_approved', False),
                created_time=datetime.now().isoformat(),
                updated_time=datetime.now().isoformat()
            )
            
            # Place hidden order with special parameters
            if self._place_hidden_order(hidden_order):
                logger.info(f"ü•∑ Hidden order placed: {symbol} {side.value} {size} "
                           f"(showing {hidden_size})")
                
        except Exception as e:
            logger.error(f"‚ùå Error executing hidden order: {e}")

    def _calculate_optimal_limit_price(self, symbol: str, side: OrderSide, request: Dict[str, Any]) -> float:
        """Calculate optimal limit price for order"""
        try:
            if symbol not in self.market_data:
                return 0.0
            
            market = self.market_data[symbol]
            
            # Get execution strategy
            strategy = ExecutionStrategy(request.get('execution_strategy', 'passive'))
            
            if side == OrderSide.BUY:
                if strategy == ExecutionStrategy.AGGRESSIVE:
                    # Aggressive: Use ask price (immediate execution)
                    return market.ask
                elif strategy == ExecutionStrategy.PASSIVE:
                    # Passive: Use bid price (wait for price improvement)
                    return market.bid
                else:
                    # Default: Mid price with slight bias toward bid
                    mid_price = (market.bid + market.ask) / 2
                    return mid_price - (market.spread * 0.25)
            else:  # SELL
                if strategy == ExecutionStrategy.AGGRESSIVE:
                    # Aggressive: Use bid price (immediate execution)
                    return market.bid
                elif strategy == ExecutionStrategy.PASSIVE:
                    # Passive: Use ask price (wait for price improvement)
                    return market.ask
                else:
                    # Default: Mid price with slight bias toward ask
                    mid_price = (market.bid + market.ask) / 2
                    return mid_price + (market.spread * 0.25)
                    
        except Exception as e:
            logger.error(f"‚ùå Error calculating optimal limit price: {e}")
            return 0.0

    def _calculate_hidden_price(self, symbol: str, side: OrderSide) -> float:
        """Calculate price for hidden order (typically better than current market)"""
        try:
            if symbol not in self.market_data:
                return 0.0
            
            market = self.market_data[symbol]
            improvement_pips = self.config.get('price_improvement_threshold', 0.1)
            
            if side == OrderSide.BUY:
                # Hidden buy: Slightly above bid to get filled faster
                return market.bid + improvement_pips
            else:
                # Hidden sell: Slightly below ask to get filled faster  
                return market.ask - improvement_pips
                
        except Exception as e:
            logger.error(f"‚ùå Error calculating hidden price: {e}")
            return 0.0

    def _get_current_market_price(self, symbol: str, side: OrderSide) -> float:
        """Get current market price for side"""
        try:
            if symbol not in self.market_data:
                return 0.0
            
            market = self.market_data[symbol]
            
            if side == OrderSide.BUY:
                return market.ask
            else:
                return market.bid
                
        except Exception as e:
            logger.error(f"‚ùå Error getting current market price: {e}")
            return 0.0

    def _calculate_expiry_time(self, request: Dict[str, Any]) -> Optional[str]:
        """Calculate order expiry time"""
        try:
            time_in_force = request.get('time_in_force', 'GTC')
            
            if time_in_force == 'GTD':  # Good Till Date
                expiry_seconds = request.get('expiry_seconds', self.config.get('order_timeout_seconds', 300))
                expiry_time = datetime.now() + timedelta(seconds=expiry_seconds)
                return expiry_time.isoformat()
            else:
                return None
                
        except Exception as e:
            logger.error(f"‚ùå Error calculating expiry time: {e}")
            return None

    def _place_limit_order(self, order: LimitOrder) -> bool:
        """Place limit order with broker/exchange"""
        try:
            # Simulate order placement (in production, this would interface with MT5/broker API)
            logger.info(f"üìã Placing limit order: {order.order_id[:8]} "
                       f"{order.symbol} {order.side.value} {order.size} @ {order.price}")
            
            # Update order status
            order.status = OrderStatus.PLACED
            order.updated_time = datetime.now().isoformat()
            
            # Store in active orders
            with self.lock:
                self.active_orders[order.order_id] = order
            
            # Emit order placed event
            emit_event("OrderPlaced", {
                "order": order.to_dict(),
                "timestamp": datetime.now().isoformat()
            })
            
            # Simulate random fill (in production, this would come from broker)
            self._simulate_order_fill(order)
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error placing limit order: {e}")
            order.status = OrderStatus.REJECTED
            return False

    def _place_hidden_order(self, order: LimitOrder) -> bool:
        """Place hidden order with special parameters"""
        try:
            # Hidden orders require special handling
            logger.info(f"ü•∑ Placing hidden order: {order.order_id[:8]} "
                       f"{order.symbol} size={order.size} hidden={order.hidden_size}")
            
            order.status = OrderStatus.PLACED
            order.updated_time = datetime.now().isoformat()
            
            with self.lock:
                self.active_orders[order.order_id] = order
            
            emit_event("OrderPlaced", {
                "order": order.to_dict(),
                "order_type": "hidden",
                "timestamp": datetime.now().isoformat()
            })
            
            # Simulate hidden order behavior
            self._simulate_hidden_order_fill(order)
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error placing hidden order: {e}")
            return False

    def _simulate_order_fill(self, order: LimitOrder):
        """Simulate order fill (for testing - replace with real broker integration)"""
        try:
            # This is a simulation - in production, fills come from broker events
            def fill_order():
                time.sleep(np.random.uniform(1, 10))  # Random fill delay
                
                if order.order_id in self.active_orders and order.status == OrderStatus.PLACED:
                    # Simulate partial or full fill
                    fill_size = order.remaining_size * np.random.uniform(0.3, 1.0)
                    fill_price = order.price + np.random.uniform(-0.5, 0.5)  # Small price variation
                    
                    self._process_order_fill(order.order_id, fill_size, fill_price)
            
            # Start fill simulation in background
            fill_thread = threading.Thread(target=fill_order, daemon=True)
            fill_thread.start()
            
        except Exception as e:
            logger.error(f"‚ùå Error simulating order fill: {e}")

    def _simulate_hidden_order_fill(self, order: LimitOrder):
        """Simulate hidden order fill behavior"""
        try:
            # Hidden orders typically get better fills over time
            def fill_hidden_order():
                filled_amount = 0.0
                
                while filled_amount < order.size and order.order_id in self.active_orders:
                    # Random fill size (smaller chunks for hidden orders)
                    chunk_size = min(order.hidden_size, order.size - filled_amount) * np.random.uniform(0.1, 0.5)
                    fill_price = order.price + np.random.uniform(-0.2, 0.2)  # Better fill prices
                    
                    self._process_order_fill(order.order_id, chunk_size, fill_price)
                    filled_amount += chunk_size
                    
                    # Wait between fills
                    time.sleep(np.random.uniform(5, 15))
            
            fill_thread = threading.Thread(target=fill_hidden_order, daemon=True)
            fill_thread.start()
            
        except Exception as e:
            logger.error(f"‚ùå Error simulating hidden order fill: {e}")

    def _process_order_fill(self, order_id: str, fill_size: float, fill_price: float):
        """Process order fill event"""
        try:
            if order_id not in self.active_orders:
                return
            
            order = self.active_orders[order_id]
            execution_time = datetime.now()
            
            # Update order
            order.filled_size += fill_size
            order.remaining_size = max(0, order.remaining_size - fill_size)
            
            # Calculate average fill price
            if order.filled_size > 0:
                total_value = (order.avg_fill_price * (order.filled_size - fill_size)) + (fill_price * fill_size)
                order.avg_fill_price = total_value / order.filled_size
            else:
                order.avg_fill_price = fill_price
            
            # Update status
            if order.remaining_size <= 0.01:  # Consider fully filled
                order.status = OrderStatus.FILLED
            else:
                order.status = OrderStatus.PARTIALLY_FILLED
            
            order.updated_time = execution_time.isoformat()
            
            # Calculate execution metrics
            execution_latency = 50.0  # Simulated latency
            slippage = abs(fill_price - order.price)
            
            # Create execution result
            execution_result = ExecutionResult(
                order_id=order_id,
                symbol=order.symbol,
                side=order.side.value,
                executed_size=fill_size,
                execution_price=fill_price,
                execution_time=execution_time.isoformat(),
                execution_latency_ms=execution_latency,
                slippage_pips=slippage,
                commission=0.0,  # Simplified
                price_improvement=max(0, order.price - fill_price) if order.side == OrderSide.BUY else max(0, fill_price - order.price),
                liquidity_consumed=fill_size,
                market_impact=slippage / fill_size if fill_size > 0 else 0
            )
            
            # Store execution result
            self.execution_results.append(execution_result)
            if len(self.execution_results) > 1000:
                self.execution_results = self.execution_results[-1000:]
            
            # Update performance metrics
            self._update_performance_metrics(execution_result)
            
            # Emit order filled event
            emit_event("OrderFilled", {
                "order": order.to_dict(),
                "execution": execution_result.to_dict(),
                "timestamp": execution_time.isoformat()
            })
            
            # Remove from active orders if fully filled
            if order.status == OrderStatus.FILLED:
                with self.lock:
                    if order_id in self.active_orders:
                        del self.active_orders[order_id]
                        self.order_history.append(order)
            
            logger.info(f"‚úÖ Order fill: {order.symbol} {fill_size} @ {fill_price} "
                       f"(total: {order.filled_size}/{order.size})")
            
        except Exception as e:
            logger.error(f"‚ùå Error processing order fill: {e}")

    def _update_performance_metrics(self, execution: ExecutionResult):
        """Update execution performance metrics"""
        try:
            with self.lock:
                self.performance_metrics['orders_processed'] += 1
                self.performance_metrics['total_volume_executed'] += execution.executed_size
                
                # Update averages
                n = self.performance_metrics['orders_processed']
                old_avg_latency = self.performance_metrics['average_execution_latency_ms']
                self.performance_metrics['average_execution_latency_ms'] = (
                    (old_avg_latency * (n - 1) + execution.execution_latency_ms) / n
                )
                
                old_avg_slippage = self.performance_metrics['average_slippage_pips']
                self.performance_metrics['average_slippage_pips'] = (
                    (old_avg_slippage * (n - 1) + execution.slippage_pips) / n
                )
                
                self.performance_metrics['price_improvement_total'] += execution.price_improvement
                
                # Calculate fill rate and success rate
                filled_orders = len([o for o in self.order_history if o.status == OrderStatus.FILLED])
                self.performance_metrics['orders_filled'] = filled_orders
                
                if self.performance_metrics['orders_processed'] > 0:
                    self.performance_metrics['fill_rate'] = (
                        filled_orders / self.performance_metrics['orders_processed']
                    )
                    self.performance_metrics['execution_success_rate'] = (
                        filled_orders / self.performance_metrics['orders_processed']
                    )
                    
        except Exception as e:
            logger.error(f"‚ùå Error updating performance metrics: {e}")

    def _update_latency_metrics(self, latency_ms: float):
        """Update latency tracking"""
        target_latency = self.config.get('latency_target_ms', 10)
        
        if latency_ms > target_latency:
            logger.warning(f"‚ö†Ô∏è High execution latency: {latency_ms:.2f}ms (target: {target_latency}ms)")

    def _wait_for_slice_completion(self, slice_order: LimitOrder, parent_order: LimitOrder):
        """Wait for iceberg slice to complete"""
        try:
            timeout = 60  # 1 minute timeout per slice
            start_time = time.time()
            
            while (slice_order.status not in [OrderStatus.FILLED, OrderStatus.CANCELLED] and
                   time.time() - start_time < timeout and
                   self.running):
                time.sleep(1)
            
            # Update parent order
            if slice_order.status == OrderStatus.FILLED:
                parent_order.filled_size += slice_order.filled_size
                parent_order.remaining_size -= slice_order.filled_size
                
                if parent_order.filled_size > 0:
                    # Update average fill price
                    total_value = (parent_order.avg_fill_price * (parent_order.filled_size - slice_order.filled_size) + 
                                 slice_order.avg_fill_price * slice_order.filled_size)
                    parent_order.avg_fill_price = total_value / parent_order.filled_size
            
        except Exception as e:
            logger.error(f"‚ùå Error waiting for slice completion: {e}")

    def _update_active_orders(self):
        """Update status of active orders"""
        try:
            current_time = datetime.now()
            expired_orders = []
            
            for order_id, order in self.active_orders.items():
                # Check for expiry
                if order.expiry_time:
                    expiry_time = datetime.fromisoformat(order.expiry_time)
                    if current_time >= expiry_time:
                        expired_orders.append(order_id)
                        continue
                
                # Update order based on current market conditions
                self._update_order_price(order)
            
            # Process expired orders
            for order_id in expired_orders:
                self._cancel_order(order_id, "expired")
                
        except Exception as e:
            logger.error(f"‚ùå Error updating active orders: {e}")

    def _update_order_price(self, order: LimitOrder):
        """Update order price based on current market conditions"""
        try:
            if order.order_type in [OrderType.ICEBERG, OrderType.TWAP, OrderType.HIDDEN]:
                return  # These order types handle their own pricing
            
            # For standard limit orders, check if price adjustment is needed
            if order.symbol in self.market_data:
                market = self.market_data[order.symbol]
                
                # Simple price improvement logic
                if order.side == OrderSide.BUY and order.price < market.bid - 0.5:
                    # Our buy order is too far from market, move closer
                    new_price = market.bid - 0.1
                    if new_price != order.price:
                        self._modify_order_price(order, new_price)
                        
                elif order.side == OrderSide.SELL and order.price > market.ask + 0.5:
                    # Our sell order is too far from market, move closer
                    new_price = market.ask + 0.1
                    if new_price != order.price:
                        self._modify_order_price(order, new_price)
            
        except Exception as e:
            logger.error(f"‚ùå Error updating order price: {e}")

    def _modify_order_price(self, order: LimitOrder, new_price: float):
        """Modify order price"""
        try:
            old_price = order.price
            order.price = new_price
            order.updated_time = datetime.now().isoformat()
            
            logger.info(f"üìù Order price modified: {order.order_id[:8]} "
                       f"{order.symbol} {old_price} -> {new_price}")
            
            # In production, this would send a modify request to the broker
            
        except Exception as e:
            logger.error(f"‚ùå Error modifying order price: {e}")

    def _check_order_timeouts(self):
        """Check for order timeouts"""
        try:
            timeout_seconds = self.config.get('order_timeout_seconds', 300)
            current_time = datetime.now()
            timeout_orders = []
            
            for order_id, order in self.active_orders.items():
                created_time = datetime.fromisoformat(order.created_time)
                if (current_time - created_time).total_seconds() > timeout_seconds:
                    if order.status == OrderStatus.PLACED and order.filled_size == 0:
                        timeout_orders.append(order_id)
            
            # Cancel timed out orders
            for order_id in timeout_orders:
                self._cancel_order(order_id, "timeout")
                
        except Exception as e:
            logger.error(f"‚ùå Error checking order timeouts: {e}")

    def _cancel_order(self, order_id: str, reason: str = "user_request"):
        """Cancel an order"""
        try:
            if order_id not in self.active_orders:
                logger.warning(f"‚ö†Ô∏è Cannot cancel order {order_id}: not found")
                return False
            
            order = self.active_orders[order_id]
            order.status = OrderStatus.CANCELLED
            order.updated_time = datetime.now().isoformat()
            
            # Remove from active orders
            with self.lock:
                del self.active_orders[order_id]
                self.order_history.append(order)
                self.performance_metrics['orders_cancelled'] += 1
            
            # Emit cancellation event
            emit_event("OrderCancelled", {
                "order": order.to_dict(),
                "reason": reason,
                "timestamp": datetime.now().isoformat()
            })
            
            logger.info(f"‚ùå Order cancelled: {order.order_id[:8]} {order.symbol} - {reason}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error cancelling order: {e}")
            return False

    def _order_monitoring_loop(self):
        """Monitor active orders"""
        while self.running:
            try:
                # Monitor order status and performance
                self._monitor_order_performance()
                self._check_risk_limits()
                
                time.sleep(5)  # Monitor every 5 seconds
                
            except Exception as e:
                logger.error(f"‚ùå Error in order monitoring loop: {e}")
                time.sleep(10)

    def _monitor_order_performance(self):
        """Monitor order execution performance"""
        try:
            # Track fill rates, slippage, latency
            if len(self.execution_results) >= 10:
                recent_executions = self.execution_results[-10:]
                
                avg_latency = np.mean([e.execution_latency_ms for e in recent_executions])
                avg_slippage = np.mean([e.slippage_pips for e in recent_executions])
                
                # Alert on poor performance
                if avg_latency > self.config.get('latency_target_ms', 10) * 2:
                    logger.warning(f"‚ö†Ô∏è High average latency: {avg_latency:.2f}ms")
                
                if avg_slippage > self.config.get('max_slippage_pips', 2.0):
                    logger.warning(f"‚ö†Ô∏è High average slippage: {avg_slippage:.2f} pips")
                    
        except Exception as e:
            logger.error(f"‚ùå Error monitoring order performance: {e}")

    def _check_risk_limits(self):
        """Check execution risk limits"""
        try:
            # Check total exposure from active orders
            total_exposure = sum(order.size * order.price for order in self.active_orders.values())
            
            # Check order count limits
            if len(self.active_orders) > 50:  # Example limit
                logger.warning(f"‚ö†Ô∏è High number of active orders: {len(self.active_orders)}")
            
            # Check if too many orders are unfilled
            unfilled_orders = [o for o in self.active_orders.values() if o.filled_size == 0]
            if len(unfilled_orders) > 20:
                logger.warning(f"‚ö†Ô∏è Many unfilled orders: {len(unfilled_orders)}")
                
        except Exception as e:
            logger.error(f"‚ùå Error checking risk limits: {e}")

    def _handle_market_data(self, event_data):
        """Handle incoming market data"""
        try:
            data = event_data.get("data", {})
            symbol = data.get("symbol")
            tick_data = data.get("tick_data", {})
            
            if symbol and tick_data:
                # Update market data
                market_data = MarketData(
                    symbol=symbol,
                    bid=tick_data.get("bid", 0.0),
                    ask=tick_data.get("ask", 0.0),
                    spread=tick_data.get("spread", 0.0),
                    bid_size=tick_data.get("volume", 1000.0),
                    ask_size=tick_data.get("volume", 1000.0),
                    last_price=(tick_data.get("bid", 0.0) + tick_data.get("ask", 0.0)) / 2,
                    volume=tick_data.get("volume", 0.0),
                    timestamp=tick_data.get("timestamp", datetime.now().isoformat())
                )
                
                self.market_data[symbol] = market_data
                
                # Update price history
                self.price_history[symbol].append(market_data.last_price)
                
        except Exception as e:
            logger.error(f"‚ùå Error handling market data: {e}")

    def _handle_risk_decision(self, event_data):
        """Handle risk decisions"""
        try:
            data = event_data.get("data", {})
            decision = data.get("decision", {})
            
            if decision.get("approved", False):
                # Create execution request from approved risk decision
                execution_request = {
                    "symbol": decision.get("symbol", ""),
                    "side": decision.get("side", ""),
                    "size": decision.get("position_size_approved", 0.0),
                    "execution_strategy": "passive",
                    "max_slippage": 2.0,
                    "risk_approved": True,
                    "strategy_id": data.get("request_id", "")
                }
                
                # Add to execution queue
                self.execution_queue.append(execution_request)
                
                logger.info(f"‚úÖ Risk approved trade added to execution queue: "
                           f"{execution_request['symbol']} {execution_request['side']} "
                           f"{execution_request['size']}")
            else:
                logger.info(f"‚ùå Trade rejected by risk engine: {decision.get('violations', [])}")
                
        except Exception as e:
            logger.error(f"‚ùå Error handling risk decision: {e}")

    def _handle_execution_request(self, event_data):
        """Handle execution requests"""
        try:
            data = event_data.get("data", {})
            
            # Validate request
            required_fields = ["symbol", "side", "size"]
            if not all(field in data for field in required_fields):
                logger.error(f"‚ùå Invalid execution request: missing fields")
                return
            
            # Add to execution queue
            self.execution_queue.append(data)
            
            logger.info(f"üì• Execution request received: {data.get('symbol')} "
                       f"{data.get('side')} {data.get('size')}")
            
        except Exception as e:
            logger.error(f"‚ùå Error handling execution request: {e}")

    def _handle_order_book_update(self, event_data):
        """Handle order book updates"""
        try:
            data = event_data.get("data", {})
            symbol = data.get("symbol")
            
            if symbol:
                # Create order book from data
                order_book = OrderBook(
                    symbol=symbol,
                    bids=[OrderBookLevel(price=level[0], size=level[1], orders=1) 
                          for level in data.get("bids", [])],
                    asks=[OrderBookLevel(price=level[0], size=level[1], orders=1) 
                          for level in data.get("asks", [])],
                    timestamp=data.get("timestamp", datetime.now().isoformat())
                )
                
                self.order_books[symbol] = order_book
                
        except Exception as e:
            logger.error(f"‚ùå Error handling order book update: {e}")

    def _handle_cancel_request(self, event_data):
        """Handle order cancellation requests"""
        try:
            data = event_data.get("data", {})
            order_id = data.get("order_id")
            reason = data.get("reason", "user_request")
            
            if order_id:
                self._cancel_order(order_id, reason)
            
        except Exception as e:
            logger.error(f"‚ùå Error handling cancel request: {e}")

    def _handle_emergency_shutdown(self, event_data):
        """Handle emergency shutdown"""
        logger.warning("üö® Emergency shutdown received - cancelling all orders")
        
        # Cancel all active orders
        order_ids = list(self.active_orders.keys())
        for order_id in order_ids:
            self._cancel_order(order_id, "emergency_shutdown")
        
        # Stop execution
        self.stop()

    def _emit_execution_error(self, request: Dict[str, Any], error: str):
        """Emit execution error event"""
        try:
            emit_event("ExecutionError", {
                "request": request,
                "error": error,
                "timestamp": datetime.now().isoformat()
            })
            
        except Exception as e:
            logger.error(f"‚ùå Error emitting execution error: {e}")

    def _telemetry_loop(self):
        """Emit telemetry data"""
        while self.running:
            try:
                time.sleep(self.config.get('telemetry_interval', 60))
                self._emit_telemetry()
            except Exception as e:
                logger.error(f"‚ùå Error in telemetry loop: {e}")

    def _emit_telemetry(self):
        """Emit comprehensive execution telemetry"""
        try:
            telemetry_data = {
                "execution_middleware_status": "running" if self.running else "stopped",
                "active_orders": len(self.active_orders),
                "execution_queue_size": len(self.execution_queue),
                "performance_metrics": self.performance_metrics,
                "recent_executions": [e.to_dict() for e in self.execution_results[-10:]],
                "market_data_symbols": list(self.market_data.keys()),
                "order_types_active": {
                    ot.value: len([o for o in self.active_orders.values() if o.order_type == ot])
                    for ot in OrderType
                },
                "timestamp": datetime.now().isoformat()
            }
            
            emit_event("ExecutionTelemetry", telemetry_data)
            
        except Exception as e:
            logger.error(f"‚ùå Error emitting telemetry: {e}")

    def stop(self):
        """Stop execution middleware"""
        logger.info("üõë Stopping GENESIS Execution Middleware...")
        self.running = False
        
        # Cancel all active orders
        order_ids = list(self.active_orders.keys())
        for order_id in order_ids:
            self._cancel_order(order_id, "system_shutdown")
        
        logger.info("‚úÖ GENESIS Execution Middleware stopped")

def initialize_execution_middleware(config_path: Optional[str] = None) -> GenesisInstitutionalExecutionMiddleware:
    """Initialize and return execution middleware instance"""
    middleware = GenesisInstitutionalExecutionMiddleware(config_path)
    
    # Store reference for access by other modules
    globals()['_execution_middleware_instance'] = middleware
    
    logger.info("üèõÔ∏è GENESIS Institutional Execution Middleware ready")
    return middleware

def get_execution_middleware() -> Optional[GenesisInstitutionalExecutionMiddleware]:
    """Get current execution middleware instance"""
    return globals().get('_execution_middleware_instance')

def main():
    """Main execution for testing"""
    logger.info("üß† GENESIS Institutional Execution Middleware - Test Mode")
    
    # Initialize middleware
    middleware = initialize_execution_middleware()
    
    try:
        # Start middleware
        if middleware.start():
            logger.info("‚úÖ Execution middleware started successfully")
            
            # Keep running
            while True:
                time.sleep(60)
                # Print stats every minute
                logger.info(f"üìä Active orders: {len(middleware.active_orders)} "
                           f"Queue: {len(middleware.execution_queue)}")
        else:
            logger.error("‚ùå Failed to start execution middleware")
            
    except KeyboardInterrupt:
        logger.info("üõë Stopping execution middleware...")
    finally:
        middleware.stop()

if __name__ == "__main__":
    main()


def detect_divergence(price_data: list, indicator_data: list, window: int = 10) -> Dict:
    """
    Detect regular and hidden divergences between price and indicator
    
    Args:
        price_data: List of price values (closing prices)
        indicator_data: List of indicator values (e.g., RSI, MACD)
        window: Number of periods to check for divergence
        
    Returns:
        Dictionary with divergence information
    """
    result = {
        "regular_bullish": False,
        "regular_bearish": False,
        "hidden_bullish": False,
        "hidden_bearish": False,
        "strength": 0.0
    }
    
    # Need at least window + 1 periods of data
    if len(price_data) < window + 1 or len(indicator_data) < window + 1:
        return result
        
    # Get the current and historical points
    current_price = price_data[-1]
    previous_price = min(price_data[-window:-1]) if price_data[-1] > price_data[-2] else max(price_data[-window:-1])
    previous_price_idx = price_data[-window:-1].index(previous_price) + len(price_data) - window
    
    current_indicator = indicator_data[-1]
    previous_indicator = indicator_data[previous_price_idx]
    
    # Check for regular divergences
    # Bullish - Lower price lows but higher indicator lows
    if current_price < previous_price and current_indicator > previous_indicator:
        result["regular_bullish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
        
    # Bearish - Higher price highs but lower indicator highs
    elif current_price > previous_price and current_indicator < previous_indicator:
        result["regular_bearish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
    
    # Check for hidden divergences
    # Bullish - Higher price lows but lower indicator lows
    elif current_price > previous_price and current_indicator < previous_indicator:
        result["hidden_bullish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
        
    # Bearish - Lower price highs but higher indicator highs
    elif current_price < previous_price and current_indicator > previous_indicator:
        result["hidden_bearish"] = True
        result["strength"] = abs((current_indicator - previous_indicator) / previous_indicator)
    
    # Emit divergence event if detected
    if any([result["regular_bullish"], result["regular_bearish"], 
            result["hidden_bullish"], result["hidden_bearish"]]):
        emit_event("divergence_detected", {
            "type": next(k for k, v in result.items() if v is True and k != "strength"),
            "strength": result["strength"],
            "symbol": price_data.symbol if hasattr(price_data, "symbol") else "unknown",
            "timestamp": datetime.now().isoformat()
        })
        
    return result


def monitor_drawdown(max_drawdown_percent: float = 5.0, daily_limit_percent: float = 5.0) -> Dict:
    """
    Monitor account drawdown against FTMO limits
    
    Args:
        max_drawdown_percent: Maximum allowed drawdown percentage
        daily_limit_percent: Maximum allowed daily loss percentage
        
    Returns:
        Dictionary with drawdown status information
    """
    try:
        # Get account info
        account_info = mt5.account_info()
        if account_info is None:
            logging.error("Failed to get account info")
            return {"status": "error", "message": "Failed to get account info"}
        
        # Calculate current drawdown
        balance = account_info.balance
        equity = account_info.equity
        
        current_drawdown = (balance - equity) / balance * 100 if balance > 0 else 0
        
        # Get daily high balance
        from_date = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        positions = mt5.history_deals_get(from_date, datetime.now())
        
        daily_starting_balance = balance - sum([deal.profit for deal in positions])
        daily_loss_percent = (daily_starting_balance - equity) / daily_starting_balance * 100 if daily_starting_balance > 0 else 0
        
        # Prepare result
        result = {
            "status": "ok",
            "current_drawdown_percent": current_drawdown,
            "max_drawdown_percent": max_drawdown_percent,
            "drawdown_level": current_drawdown / max_drawdown_percent,  # 0.0 to 1.0+
            "daily_loss_percent": daily_loss_percent,
            "daily_limit_percent": daily_limit_percent,
            "daily_loss_level": daily_loss_percent / daily_limit_percent,  # 0.0 to 1.0+
            "warnings": []
        }
        
        # Check drawdown thresholds
        if current_drawdown > max_drawdown_percent * 0.7:
            result["warnings"].append(f"Drawdown at {current_drawdown:.2f}% approaching maximum of {max_drawdown_percent:.2f}%")
            result["status"] = "warning"
            
        if current_drawdown > max_drawdown_percent:
            result["warnings"].append(f"CRITICAL: Drawdown of {current_drawdown:.2f}% exceeds maximum of {max_drawdown_percent:.2f}%")
            result["status"] = "critical"
            
        # Check daily loss thresholds
        if daily_loss_percent > daily_limit_percent * 0.7:
            result["warnings"].append(f"Daily loss at {daily_loss_percent:.2f}% approaching limit of {daily_limit_percent:.2f}%")
            result["status"] = "warning"
            
        if daily_loss_percent > daily_limit_percent:
            result["warnings"].append(f"CRITICAL: Daily loss of {daily_loss_percent:.2f}% exceeds limit of {daily_limit_percent:.2f}%")
            result["status"] = "critical"
        
        # Emit events for warnings
        if result["status"] in ["warning", "critical"]:
            emit_event("risk_threshold_warning", {
                "status": result["status"],
                "warnings": result["warnings"],
                "timestamp": datetime.now().isoformat()
            })
            
        return result
        
    except Exception as e:
        logging.error(f"Error monitoring drawdown: {str(e)}")
        return {"status": "error", "message": str(e)}
