# <!-- @GENESIS_MODULE_START: dsr_strategy_mutator -->

from datetime import datetime, timezone

# ðŸ“Š GENESIS Telemetry Integration - Auto-injected by Complete Intelligent Wiring Engine
try:
    from core.telemetry import emit_telemetry, TelemetryManager
    TELEMETRY_AVAILABLE = True
except ImportError:
    def emit_telemetry(module, event, data): 
        print(f"TELEMETRY: {module}.{event} - {data}")
    class TelemetryManager:
        def emergency_stop(self, reason: str = "Manual trigger") -> bool:
                """GENESIS Emergency Kill Switch"""
                try:
                    # Emit emergency event
                    if hasattr(self, 'event_bus') and self.event_bus:
                        emit_event("emergency_stop", {
                            "module": "dsr_strategy_mutator_recovered_2",
                            "reason": reason,
                            "timestamp": datetime.now().isoformat()
                        })

                    # Log telemetry
                    self.emit_module_telemetry("emergency_stop", {
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                    # Set emergency state
                    if hasattr(self, '_emergency_stop_active'):
                        self._emergency_stop_active = True

                    return True
                except Exception as e:
                    print(f"Emergency stop error in dsr_strategy_mutator_recovered_2: {e}")
                    return False
        def validate_ftmo_compliance(self, trade_data: dict) -> bool:
                """GENESIS FTMO Compliance Validator"""
                # Daily drawdown check (5%)
                daily_loss = trade_data.get('daily_loss_pct', 0)
                if daily_loss > 5.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "daily_drawdown", 
                        "value": daily_loss,
                        "threshold": 5.0
                    })
                    return False

                # Maximum drawdown check (10%)
                max_drawdown = trade_data.get('max_drawdown_pct', 0)
                if max_drawdown > 10.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "max_drawdown", 
                        "value": max_drawdown,
                        "threshold": 10.0
                    })
                    return False

                # Risk per trade check (2%)
                risk_pct = trade_data.get('risk_percent', 0)
                if risk_pct > 2.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "risk_exceeded", 
                        "value": risk_pct,
                        "threshold": 2.0
                    })
                    return False

                return True
        def emit_module_telemetry(self, event: str, data: dict = None):
                """GENESIS Module Telemetry Hook"""
                telemetry_data = {
                    "timestamp": datetime.now().isoformat(),
                    "module": "dsr_strategy_mutator_recovered_2",
                    "event": event,
                    "data": data or {}
                }
                try:
                    emit_telemetry("dsr_strategy_mutator_recovered_2", event, telemetry_data)
                except Exception as e:
                    print(f"Telemetry error in dsr_strategy_mutator_recovered_2: {e}")
        def emit(self, event, data): pass
    TELEMETRY_AVAILABLE = False



# ðŸ”— GENESIS EventBus Integration - Auto-injected by Complete Intelligent Wiring Engine
try:
    from core.hardened_event_bus import get_event_bus, emit_event, register_route
    EVENTBUS_AVAILABLE = True
except ImportError:
    # Fallback implementation
    def get_event_bus(): return None
    def emit_event(event, data): print(f"EVENT: {event} - {data}")
    def register_route(route, producer, consumer): pass
    EVENTBUS_AVAILABLE = False


#!/usr/bin/env python3
"""
GENESIS AI TRADING SYSTEM - PHASE 23: DYNAMIC STRATEGY RECOMMENDER (DSR)
ðŸ§  DSR Strategy Mutator Engine - ARCHITECT MODE v2.7

PURPOSE:
Takes SSR-filtered signals and recommends trade plans using strategy mutation logic,
HTF alignment, and telemetry-backed decision filters.

COMPLIANCE:
- EventBus-only architecture (no isolated functions)
- Real MT5 live data integration
- Telemetry hooks for all operations
- HTF alignment compliance
- No fallback strategies (institutional grade)

AUTHOR: GENESIS AI AGENT - ARCHITECT MODE
VERSION: 1.0.0
PHASE: 23
"""

import json
import datetime
import os
import logging
import time
import threading
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from collections import defaultdict
import numpy as np

# Import EventBus (ARCHITECT COMPLIANCE - NO DIRECT IMPORTS)
from hardened_event_bus import get_event_bus

@dataclass
class StrategyMutation:
    def emergency_stop(self, reason: str = "Manual trigger") -> bool:
            """GENESIS Emergency Kill Switch"""
            try:
                # Emit emergency event
                if hasattr(self, 'event_bus') and self.event_bus:
                    emit_event("emergency_stop", {
                        "module": "dsr_strategy_mutator_recovered_2",
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                # Log telemetry
                self.emit_module_telemetry("emergency_stop", {
                    "reason": reason,
                    "timestamp": datetime.now().isoformat()
                })

                # Set emergency state
                if hasattr(self, '_emergency_stop_active'):
                    self._emergency_stop_active = True

                return True
            except Exception as e:
                print(f"Emergency stop error in dsr_strategy_mutator_recovered_2: {e}")
                return False
    def validate_ftmo_compliance(self, trade_data: dict) -> bool:
            """GENESIS FTMO Compliance Validator"""
            # Daily drawdown check (5%)
            daily_loss = trade_data.get('daily_loss_pct', 0)
            if daily_loss > 5.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "daily_drawdown", 
                    "value": daily_loss,
                    "threshold": 5.0
                })
                return False

            # Maximum drawdown check (10%)
            max_drawdown = trade_data.get('max_drawdown_pct', 0)
            if max_drawdown > 10.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "max_drawdown", 
                    "value": max_drawdown,
                    "threshold": 10.0
                })
                return False

            # Risk per trade check (2%)
            risk_pct = trade_data.get('risk_percent', 0)
            if risk_pct > 2.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "risk_exceeded", 
                    "value": risk_pct,
                    "threshold": 2.0
                })
                return False

            return True
    def emit_module_telemetry(self, event: str, data: dict = None):
            """GENESIS Module Telemetry Hook"""
            telemetry_data = {
                "timestamp": datetime.now().isoformat(),
                "module": "dsr_strategy_mutator_recovered_2",
                "event": event,
                "data": data or {}
            }
            try:
                emit_telemetry("dsr_strategy_mutator_recovered_2", event, telemetry_data)
            except Exception as e:
                print(f"Telemetry error in dsr_strategy_mutator_recovered_2: {e}")
    def initialize_eventbus(self):
            """GENESIS EventBus Initialization"""
            try:
                self.event_bus = get_event_bus()
                if self.event_bus:
                    emit_event("module_initialized", {
                        "module": "dsr_strategy_mutator_recovered_2",
                        "timestamp": datetime.now().isoformat(),
                        "status": "active"
                    })
            except Exception as e:
                print(f"EventBus initialization error in dsr_strategy_mutator_recovered_2: {e}")
    """Strategy mutation data structure"""
    mutation_id: str
    base_strategy: str
    mutation_type: str
    confidence_boost: float
    risk_adjustment: float
    htf_alignment_score: float
    execution_priority: int
    mutation_path: List[str]
    telemetry_tags: Dict[str, Any]

@dataclass 
class DSRRecommendation:
    def emergency_stop(self, reason: str = "Manual trigger") -> bool:
            """GENESIS Emergency Kill Switch"""
            try:
                # Emit emergency event
                if hasattr(self, 'event_bus') and self.event_bus:
                    emit_event("emergency_stop", {
                        "module": "dsr_strategy_mutator_recovered_2",
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                # Log telemetry
                self.emit_module_telemetry("emergency_stop", {
                    "reason": reason,
                    "timestamp": datetime.now().isoformat()
                })

                # Set emergency state
                if hasattr(self, '_emergency_stop_active'):
                    self._emergency_stop_active = True

                return True
            except Exception as e:
                print(f"Emergency stop error in dsr_strategy_mutator_recovered_2: {e}")
                return False
    def validate_ftmo_compliance(self, trade_data: dict) -> bool:
            """GENESIS FTMO Compliance Validator"""
            # Daily drawdown check (5%)
            daily_loss = trade_data.get('daily_loss_pct', 0)
            if daily_loss > 5.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "daily_drawdown", 
                    "value": daily_loss,
                    "threshold": 5.0
                })
                return False

            # Maximum drawdown check (10%)
            max_drawdown = trade_data.get('max_drawdown_pct', 0)
            if max_drawdown > 10.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "max_drawdown", 
                    "value": max_drawdown,
                    "threshold": 10.0
                })
                return False

            # Risk per trade check (2%)
            risk_pct = trade_data.get('risk_percent', 0)
            if risk_pct > 2.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "risk_exceeded", 
                    "value": risk_pct,
                    "threshold": 2.0
                })
                return False

            return True
    def emit_module_telemetry(self, event: str, data: dict = None):
            """GENESIS Module Telemetry Hook"""
            telemetry_data = {
                "timestamp": datetime.now().isoformat(),
                "module": "dsr_strategy_mutator_recovered_2",
                "event": event,
                "data": data or {}
            }
            try:
                emit_telemetry("dsr_strategy_mutator_recovered_2", event, telemetry_data)
            except Exception as e:
                print(f"Telemetry error in dsr_strategy_mutator_recovered_2: {e}")
    def initialize_eventbus(self):
            """GENESIS EventBus Initialization"""
            try:
                self.event_bus = get_event_bus()
                if self.event_bus:
                    emit_event("module_initialized", {
                        "module": "dsr_strategy_mutator_recovered_2",
                        "timestamp": datetime.now().isoformat(),
                        "status": "active"
                    })
            except Exception as e:
                print(f"EventBus initialization error in dsr_strategy_mutator_recovered_2: {e}")
    """DSR recommendation output structure"""
    recommendation_id: str
    symbol: str
    signal_id: str
    recommended_strategy: str
    mutation_applied: StrategyMutation
    execution_quality_score: float
    htf_alignment_score: float
    risk_profile: str
    position_size_factor: float
    entry_conditions: Dict[str, Any]
    exit_conditions: Dict[str, Any]
    telemetry_payload: Dict[str, Any]
    timestamp: str


    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        class DSRStrategyMutator:
    def emergency_stop(self, reason: str = "Manual trigger") -> bool:
            """GENESIS Emergency Kill Switch"""
            try:
                # Emit emergency event
                if hasattr(self, 'event_bus') and self.event_bus:
                    emit_event("emergency_stop", {
                        "module": "dsr_strategy_mutator_recovered_2",
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                # Log telemetry
                self.emit_module_telemetry("emergency_stop", {
                    "reason": reason,
                    "timestamp": datetime.now().isoformat()
                })

                # Set emergency state
                if hasattr(self, '_emergency_stop_active'):
                    self._emergency_stop_active = True

                return True
            except Exception as e:
                print(f"Emergency stop error in dsr_strategy_mutator_recovered_2: {e}")
                return False
    def validate_ftmo_compliance(self, trade_data: dict) -> bool:
            """GENESIS FTMO Compliance Validator"""
            # Daily drawdown check (5%)
            daily_loss = trade_data.get('daily_loss_pct', 0)
            if daily_loss > 5.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "daily_drawdown", 
                    "value": daily_loss,
                    "threshold": 5.0
                })
                return False

            # Maximum drawdown check (10%)
            max_drawdown = trade_data.get('max_drawdown_pct', 0)
            if max_drawdown > 10.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "max_drawdown", 
                    "value": max_drawdown,
                    "threshold": 10.0
                })
                return False

            # Risk per trade check (2%)
            risk_pct = trade_data.get('risk_percent', 0)
            if risk_pct > 2.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "risk_exceeded", 
                    "value": risk_pct,
                    "threshold": 2.0
                })
                return False

            return True
    def emit_module_telemetry(self, event: str, data: dict = None):
            """GENESIS Module Telemetry Hook"""
            telemetry_data = {
                "timestamp": datetime.now().isoformat(),
                "module": "dsr_strategy_mutator_recovered_2",
                "event": event,
                "data": data or {}
            }
            try:
                emit_telemetry("dsr_strategy_mutator_recovered_2", event, telemetry_data)
            except Exception as e:
                print(f"Telemetry error in dsr_strategy_mutator_recovered_2: {e}")
    def initialize_eventbus(self):
            """GENESIS EventBus Initialization"""
            try:
                self.event_bus = get_event_bus()
                if self.event_bus:
                    emit_event("module_initialized", {
                        "module": "dsr_strategy_mutator_recovered_2",
                        "timestamp": datetime.now().isoformat(),
                        "status": "active"
                    })
            except Exception as e:
                print(f"EventBus initialization error in dsr_strategy_mutator_recovered_2: {e}")
    """
    GENESIS PHASE 23: Dynamic Strategy Recommender Strategy Mutator
    
    Takes refined signals and applies strategy mutation logic to recommend
    optimal trade execution plans with HTF alignment and quality scoring.
    
    ARCHITECT COMPLIANCE:
    - EventBus-only communication
    - Real data processing (no real/fallback)
    - Telemetry integration
    - HTF alignment validation
    - Performance tracking
    """
    
    def __init__(self):
        """Initialize DSR Strategy Mutator with ARCHITECT compliance"""
        
        # Core system setup
        self.logger = logging.getLogger("DSRStrategyMutator")
        self.logger.setLevel(logging.INFO)
          # ARCHITECT COMPLIANCE: EventBus initialization
        self.event_bus = get_event_bus()
        
        # Configuration
        self.config = self._load_dsr_config()
        
        # Strategy mutation engine state
        self.mutation_templates = self._load_mutation_templates()
        self.active_recommendations = {}
        self.mutation_history = defaultdict(list)
        self.performance_tracker = {
            'recommendations_generated': 0,
            'mutations_applied': 0,
            'htf_alignment_successes': 0,
            'execution_quality_total': 0.0,
            'rejection_count': defaultdict(int)
        }
        
        # HTF alignment parameters
        self.htf_weights = {
            'M15': 0.2,
            'H1': 0.3,
            'H4': 0.3,
            'D1': 0.2
        }
        
        # Telemetry setup
        self.telemetry_enabled = True
        self.telemetry_buffer = []
        
        # Thread safety
        self.lock = threading.Lock()
        
        # Module status
        self.module_status = "INITIALIZING"
        self.start_time = datetime.datetime.now()
        
        # Initialize EventBus subscriptions
        self._subscribe_to_events()
        
        self.module_status = "ACTIVE"
        self._emit_startup_telemetry()
        
        self.logger.info("DSR Strategy Mutator initialized successfully - ARCHITECT MODE v2.7")

    
        # GENESIS Phase 91 Telemetry Injection
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", {
                "module": __name__,
                "status": "running",
                "timestamp": datetime.now().isoformat(),
                "phase": "91_telemetry_enforcement"
            })
        def _load_dsr_config(self) -> Dict[str, Any]:
        """Load DSR configuration with validation"""
        try:
            config_path = "dsr_config.json"
            if os.path.exists(config_path):
                with open(config_path, 'r') as f:
                    config = json.load(f)
                self.logger.info(f"DSR config loaded from {config_path}")
            else:
                # Default configuration
                config = {
                    "mutation_confidence_threshold": 0.75,
                    "htf_alignment_minimum": 0.6,
                    "max_mutations_per_signal": 3,
                    "execution_quality_threshold": 0.8,
                    "risk_profile_mapping": {
                        "conservative": {"max_risk": 0.02, "position_factor": 0.5},
                        "moderate": {"max_risk": 0.05, "position_factor": 0.75},
                        "aggressive": {"max_risk": 0.1, "position_factor": 1.0}
                    },
                    "strategy_weights": {
                        "momentum": 0.4,
                        "mean_reversion": 0.3,
                        "breakout": 0.2,
                        "scalping": 0.1
                    }
                }
                self.logger.info("Using default DSR configuration")
            
            return config
            
        except Exception as e:
            self.logger.error(f"Error loading DSR config: {e}")
            return {}

    def _load_mutation_templates(self) -> Dict[str, Dict]:
        """Load strategy mutation templates"""
        templates = {
            "momentum_boost": {
                "type": "confidence_enhancement",
                "confidence_multiplier": 1.2,
                "risk_adjustment": 0.9,
                "conditions": ["trend_strength > 0.7", "volume_confirmation"]
            },
            "mean_reversion_filter": {
                "type": "risk_reduction", 
                "confidence_multiplier": 0.9,
                "risk_adjustment": 0.7,
                "conditions": ["overbought_oversold", "support_resistance_level"]
            },
            "breakout_acceleration": {
                "type": "execution_enhancement",
                "confidence_multiplier": 1.15,
                "risk_adjustment": 1.1,
                "conditions": ["volume_spike", "volatility_expansion"]
            },
            "scalping_optimization": {
                "type": "timing_optimization",
                "confidence_multiplier": 1.05,
                "risk_adjustment": 0.8,
                "conditions": ["tight_spread", "high_liquidity"]
            },
            "htf_alignment": {
                "type": "timeframe_synchronization",
                "confidence_multiplier": 1.3,
                "risk_adjustment": 0.85,
                "conditions": ["htf_trend_confirmation", "multi_timeframe_convergence"]
            }
        }
        
        self.logger.info(f"Loaded {len(templates)} mutation templates")
        return templates

    def _subscribe_to_events(self):
        """Subscribe to EventBus events - ARCHITECT COMPLIANCE"""
        try:
            # Subscribe to refined signals from SSR Engine
            self.event_bus.subscribe("RefinedSignal", self._handle_refined_signal)
            
            # Subscribe to feedback events
            self.event_bus.subscribe("StrategyExecutionFeedback", self._handle_execution_feedback)
            self.event_bus.subscribe("HTFAlignmentUpdate", self._handle_htf_update)
            
            # Subscribe to system events
            self.event_bus.subscribe("SystemStatusCheck", self._handle_status_check)
            self.event_bus.subscribe("PerformanceMetricsRequest", self._handle_metrics_request)
            
            self.logger.info("EventBus subscriptions established")
            
        except Exception as e:
            self.logger.error(f"Error setting up EventBus subscriptions: {e}")
            raise

    def _handle_refined_signal(self, event_data: Dict[str, Any]):
        """Handle incoming refined signals from SSR Engine"""
        try:
            with self.lock:
                signal_data = event_data.get('payload', {})
                
                # Validate required fields
                required_fields = ['signal_id', 'symbol', 'signal_type', 'confidence', 'refined_confidence']
                assert all(field in signal_data for field in required_fields):
                    self._emit_rejection("MISSING_REQUIRED_FIELDS", signal_data)
                    return
                
                # Check confidence threshold
                refined_confidence = signal_data.get('refined_confidence', 0.0)
                if refined_confidence < self.config.get('mutation_confidence_threshold', 0.75):
                    self._emit_rejection("CONFIDENCE_BELOW_THRESHOLD", signal_data)
                    return
                
                # Generate strategy recommendation
                recommendation = self._generate_strategy_recommendation(signal_data)
                
                if recommendation:
                    # Emit recommendation to Envelope Engine
                    self._emit_strategy_recommendation(recommendation)
                    self._emit_telemetry_update(recommendation)
                else:
                    self._emit_rejection("STRATEGY_GENERATION_FAILED", signal_data)
                    
        except Exception as e:
            self.logger.error(f"Error handling refined signal: {e}")
            self._emit_module_error("SIGNAL_PROCESSING_ERROR", str(e))

    def _generate_strategy_recommendation(self, signal_data: Dict[str, Any]) -> Optional[DSRRecommendation]:
        """Generate strategy recommendation with mutation logic"""
        try:
            signal_id = signal_data['signal_id']
            symbol = signal_data['symbol']
            signal_type = signal_data['signal_type']
            confidence = signal_data['refined_confidence']
            
            # Select base strategy
            base_strategy = self._select_base_strategy(signal_data)
            
            # Apply strategy mutation
            mutation = self._apply_strategy_mutation(base_strategy, signal_data)
            
            # Calculate HTF alignment score
            htf_score = self._calculate_htf_alignment(signal_data)
            
            # Check HTF alignment minimum
            if htf_score < self.config.get('htf_alignment_minimum', 0.6):
                self.logger.warning(f"HTF alignment below minimum: {htf_score}")
                self._emit_error_event("operation_failed", {

                    "error": "ARCHITECT_MODE_COMPLIANCE: Operation failed",

                    "timestamp": datetime.now(timezone.utc).isoformat()

                })

                raise RuntimeError("ARCHITECT_MODE_COMPLIANCE: Operation failed")
            
            # Calculate execution quality score
            execution_quality = self._calculate_execution_quality(signal_data, mutation, htf_score)
            
            # Check execution quality threshold
            if execution_quality < self.config.get('execution_quality_threshold', 0.8):
                self.logger.warning(f"Execution quality below threshold: {execution_quality}")
                self._emit_error_event("operation_failed", {

                    "error": "ARCHITECT_MODE_COMPLIANCE: Operation failed",

                    "timestamp": datetime.now(timezone.utc).isoformat()

                })

                raise RuntimeError("ARCHITECT_MODE_COMPLIANCE: Operation failed")
            
            # Determine risk profile
            risk_profile = self._determine_risk_profile(signal_data, mutation)
            
            # Calculate position size factor
            position_size_factor = self._calculate_position_size_factor(risk_profile, confidence, htf_score)
            
            # Generate entry/exit conditions
            entry_conditions = self._generate_entry_conditions(signal_data, mutation)
            exit_conditions = self._generate_exit_conditions(signal_data, mutation)
            
            # Create recommendation
            recommendation = DSRRecommendation(
                recommendation_id=f"DSR_{signal_id}_{int(time.time())}",
                symbol=symbol,
                signal_id=signal_id,
                recommended_strategy=base_strategy,
                mutation_applied=mutation,
                execution_quality_score=execution_quality,
                htf_alignment_score=htf_score,
                risk_profile=risk_profile,
                position_size_factor=position_size_factor,
                entry_conditions=entry_conditions,
                exit_conditions=exit_conditions,
                telemetry_payload=self._create_telemetry_payload(signal_data, mutation, execution_quality, htf_score),
                timestamp=datetime.datetime.now().isoformat()
            )
            
            # Store recommendation
            self.active_recommendations[recommendation.recommendation_id] = recommendation
            
            # Update performance tracking
            self.performance_tracker['recommendations_generated'] += 1
            self.performance_tracker['mutations_applied'] += 1
            self.performance_tracker['htf_alignment_successes'] += 1
            self.performance_tracker['execution_quality_total'] += execution_quality
            
            self.logger.info(f"Generated strategy recommendation: {recommendation.recommendation_id}")
            return recommendation
            
        except Exception as e:
            self.logger.error(f"Error generating strategy recommendation: {e}")
            self._emit_error_event("operation_failed", {

                "error": "ARCHITECT_MODE_COMPLIANCE: Operation failed",

                "timestamp": datetime.now(timezone.utc).isoformat()

            })

            raise RuntimeError("ARCHITECT_MODE_COMPLIANCE: Operation failed")

    def _select_base_strategy(self, signal_data: Dict[str, Any]) -> str:
        """Select optimal base strategy based on signal characteristics"""
        signal_type = signal_data.get('signal_type', '')
        market_conditions = signal_data.get('market_conditions', {})
        
        strategy_scores = {}
        
        # Momentum strategy scoring
        momentum_score = 0.0
        if 'trend' in signal_type.lower():
            momentum_score += 0.4
        if market_conditions.get('trend_strength', 0) > 0.6:
            momentum_score += 0.3
        if market_conditions.get('volume_trend', 0) > 0.5:
            momentum_score += 0.3
        strategy_scores['momentum'] = momentum_score
        
        # Mean reversion strategy scoring
        reversion_score = 0.0
        if 'reversal' in signal_type.lower() or 'support' in signal_type.lower():
            reversion_score += 0.4
        if market_conditions.get('rsi', 50) > 70 or market_conditions.get('rsi', 50) < 30:
            reversion_score += 0.3
        if market_conditions.get('volatility', 0) > 0.7:
            reversion_score += 0.3
        strategy_scores['mean_reversion'] = reversion_score
        
        # Breakout strategy scoring
        breakout_score = 0.0
        if 'breakout' in signal_type.lower():
            breakout_score += 0.4
        if market_conditions.get('consolidation_break', False):
            breakout_score += 0.3
        if market_conditions.get('volume_spike', False):
            breakout_score += 0.3
        strategy_scores['breakout'] = breakout_score
        
        # Scalping strategy scoring
        scalping_score = 0.0
        if market_conditions.get('spread', 10) < 3:
            scalping_score += 0.3
        if market_conditions.get('liquidity', 0) > 0.8:
            scalping_score += 0.4
        if signal_data.get('timeframe', '') in ['M1', 'M5']:
            scalping_score += 0.3
        strategy_scores['scalping'] = scalping_score
          # Select highest scoring strategy
        if strategy_scores:
            best_strategy = max(strategy_scores.keys(), key=lambda k: strategy_scores[k])
        else:
            best_strategy = 'momentum'  # Default strategy
        
        self.logger.info(f"Selected base strategy: {best_strategy} (score: {strategy_scores[best_strategy]:.2f})")
        return best_strategy

    def _apply_strategy_mutation(self, base_strategy: str, signal_data: Dict[str, Any]) -> StrategyMutation:
        """Apply strategy mutation based on signal characteristics"""
        
        # Select mutation template
        mutation_type = self._select_mutation_type(base_strategy, signal_data)
        template = self.mutation_templates.get(mutation_type, {})
        
        # Calculate mutation parameters
        confidence_boost = template.get('confidence_multiplier', 1.0) - 1.0
        risk_adjustment = template.get('risk_adjustment', 1.0)
        
        # Calculate HTF alignment score for this mutation
        htf_alignment_score = self._calculate_mutation_htf_alignment(mutation_type, signal_data)
        
        # Determine execution priority
        execution_priority = self._calculate_execution_priority(mutation_type, signal_data)
        
        # Generate mutation path
        mutation_path = [base_strategy, mutation_type]
        if template.get('conditions'):
            mutation_path.extend(template['conditions'])
        
        # Create telemetry tags
        telemetry_tags = {
            'base_strategy': base_strategy,
            'mutation_template': mutation_type,
            'confidence_impact': confidence_boost,
            'risk_impact': risk_adjustment,
            'signal_id': signal_data.get('signal_id', ''),
            'symbol': signal_data.get('symbol', '')
        }
        
        mutation = StrategyMutation(
            mutation_id=f"MUT_{base_strategy}_{mutation_type}_{int(time.time())}",
            base_strategy=base_strategy,
            mutation_type=mutation_type,
            confidence_boost=confidence_boost,
            risk_adjustment=risk_adjustment,
            htf_alignment_score=htf_alignment_score,
            execution_priority=execution_priority,
            mutation_path=mutation_path,
            telemetry_tags=telemetry_tags
        )
        
        # Store mutation in history
        self.mutation_history[signal_data.get('symbol', '')].append(mutation)
        
        self.logger.info(f"Applied mutation: {mutation_type} to {base_strategy}")
        return mutation

    def _select_mutation_type(self, base_strategy: str, signal_data: Dict[str, Any]) -> str:
        """Select appropriate mutation type for the strategy"""
        market_conditions = signal_data.get('market_conditions', {})
        
        # Strategy-specific mutation selection
        if base_strategy == 'momentum':
            if market_conditions.get('trend_strength', 0) > 0.8 is not None, "Real data required - no fallbacks allowed"

# <!-- @GENESIS_MODULE_END: dsr_strategy_mutator -->