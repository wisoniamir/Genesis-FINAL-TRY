
# üìä GENESIS Telemetry Integration - Auto-injected by Complete Intelligent Wiring Engine
try:
    from core.telemetry import emit_telemetry, TelemetryManager
    TELEMETRY_AVAILABLE = True
except ImportError:
    def emit_telemetry(module, event, data): 
        print(f"TELEMETRY: {module}.{event} - {data}")
    class TelemetryManager:
        def validate_ftmo_compliance(self, trade_data: dict) -> bool:
                """GENESIS FTMO Compliance Validator"""
                # Daily drawdown check (5%)
                daily_loss = trade_data.get('daily_loss_pct', 0)
                if daily_loss > 5.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "daily_drawdown", 
                        "value": daily_loss,
                        "threshold": 5.0
                    })
                    return False

                # Maximum drawdown check (10%)
                max_drawdown = trade_data.get('max_drawdown_pct', 0)
                if max_drawdown > 10.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "max_drawdown", 
                        "value": max_drawdown,
                        "threshold": 10.0
                    })
                    return False

                # Risk per trade check (2%)
                risk_pct = trade_data.get('risk_percent', 0)
                if risk_pct > 2.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "risk_exceeded", 
                        "value": risk_pct,
                        "threshold": 2.0
                    })
                    return False

                return True
        def emit_module_telemetry(self, event: str, data: dict = None):
                """GENESIS Module Telemetry Hook"""
                telemetry_data = {
                    "timestamp": datetime.now().isoformat(),
                    "module": "validate_phase35_completion_recovered_2",
                    "event": event,
                    "data": data or {}
                }
                try:
                    emit_telemetry("validate_phase35_completion_recovered_2", event, telemetry_data)
                except Exception as e:
                    print(f"Telemetry error in validate_phase35_completion_recovered_2: {e}")
        def emit(self, event, data): pass
    TELEMETRY_AVAILABLE = False



# üîó GENESIS EventBus Integration - Auto-injected by Complete Intelligent Wiring Engine
try:
    from core.hardened_event_bus import get_event_bus, emit_event, register_route
    EVENTBUS_AVAILABLE = True
except ImportError:
    # Fallback implementation
    def get_event_bus(): return None
    def emit_event(event, data): print(f"EVENT: {event} - {data}")
    def register_route(route, producer, consumer): pass
    EVENTBUS_AVAILABLE = False


# <!-- @GENESIS_MODULE_START: validate_phase35_completion -->

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GENESIS PHASE 35 - FINAL VALIDATION SCRIPT
==========================================
Architect Mode v3.1 Compliance Verification

This script validates that all Phase 35 components are properly integrated
and comply with architect mode requirements:

‚úÖ Strategic Signal Orchestrator operational
‚úÖ Enhanced telemetry dashboard integration  
‚úÖ Architect-compliant test suites created
‚úÖ Phase 34 broker discovery corrections applied
‚úÖ System tree and module registry updated
‚úÖ EventBus routes properly configured
‚úÖ Real MT5 data compliance verified
"""

import os
import json
import logging
import time
from datetime import datetime
from pathlib import Path

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class Phase35Validator:
    def validate_ftmo_compliance(self, trade_data: dict) -> bool:
            """GENESIS FTMO Compliance Validator"""
            # Daily drawdown check (5%)
            daily_loss = trade_data.get('daily_loss_pct', 0)
            if daily_loss > 5.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "daily_drawdown", 
                    "value": daily_loss,
                    "threshold": 5.0
                })
                return False

            # Maximum drawdown check (10%)
            max_drawdown = trade_data.get('max_drawdown_pct', 0)
            if max_drawdown > 10.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "max_drawdown", 
                    "value": max_drawdown,
                    "threshold": 10.0
                })
                return False

            # Risk per trade check (2%)
            risk_pct = trade_data.get('risk_percent', 0)
            if risk_pct > 2.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "risk_exceeded", 
                    "value": risk_pct,
                    "threshold": 2.0
                })
                return False

            return True
    def emit_module_telemetry(self, event: str, data: dict = None):
            """GENESIS Module Telemetry Hook"""
            telemetry_data = {
                "timestamp": datetime.now().isoformat(),
                "module": "validate_phase35_completion_recovered_2",
                "event": event,
                "data": data or {}
            }
            try:
                emit_telemetry("validate_phase35_completion_recovered_2", event, telemetry_data)
            except Exception as e:
                print(f"Telemetry error in validate_phase35_completion_recovered_2: {e}")
    def initialize_eventbus(self):
            """GENESIS EventBus Initialization"""
            try:
                self.event_bus = get_event_bus()
                if self.event_bus:
                    emit_event("module_initialized", {
                        "module": "validate_phase35_completion_recovered_2",
                        "timestamp": datetime.now().isoformat(),
                        "status": "active"
                    })
            except Exception as e:
                print(f"EventBus initialization error in validate_phase35_completion_recovered_2: {e}")
    """Phase 35 Strategic Signal Orchestrator validation"""
    
    def __init__(self):
        self.validation_results = {
            "phase": 35,
            "validation_timestamp": datetime.utcnow().isoformat(),
            "architect_mode_version": "3.1",
            "components_validated": [],
            "validation_passed": True,
            "details": {}
        }
        
    
        # GENESIS Phase 91 Telemetry Injection
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", {
                "module": __name__,
                "status": "running",
                "timestamp": datetime.now().isoformat(),
                "phase": "91_telemetry_enforcement"
            })
        def validate_strategic_signal_orchestrator(self):
        """Validate Strategic Signal Orchestrator module"""
        logger.info("üîç Validating Strategic Signal Orchestrator...")
        
        # Check if module exists
        orchestrator_file = Path("strategic_signal_orchestrator.py")
        if not orchestrator_file.exists():
            self.validation_results["validation_passed"] = False
            self.validation_results["details"]["orchestrator_missing"] = True
            logger.error("‚ùå strategic_signal_orchestrator.py not found")
            return False
            
        # Check file size (should be substantial)
        file_size = orchestrator_file.stat().st_size
        if file_size < 10000:  # Less than 10KB indicates incomplete
            self.validation_results["validation_passed"] = False
            logger.error(f"‚ùå Strategic Signal Orchestrator too small: {file_size} bytes")
            return False
            
        logger.info(f"‚úÖ Strategic Signal Orchestrator validated: {file_size} bytes")
        self.validation_results["details"]["orchestrator_size"] = file_size
        return True
        
    def validate_orchestration_config(self):
        """Validate orchestration rules configuration"""
        logger.info("üîç Validating Orchestration Configuration...")
        
        config_file = Path("orchestration_rules_config.json")
        if not config_file.exists():
            self.validation_results["validation_passed"] = False
            logger.error("‚ùå orchestration_rules_config.json not found")
            return False
            
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
                
            # Check required sections
            required_sections = ["priority_rules", "kill_switch_overrides", "volatility_thresholds", "suppression_logic"]
            missing_sections = [section for section in required_sections if section not in config]
            
            if missing_sections:
                self.validation_results["validation_passed"] = False
                logger.error(f"‚ùå Missing config sections: {missing_sections}")
                return False
                
            logger.info(f"‚úÖ Orchestration config validated: {len(config.get('priority_rules', []))} rules")
            self.validation_results["details"]["config_rules_count"] = len(config.get('priority_rules', []))
            return True
            
        except json.JSONDecodeError as e:
            self.validation_results["validation_passed"] = False
            logger.error(f"‚ùå Invalid JSON in config file: {e}")
            return False
            
    def validate_test_suites(self):
        """Validate architect-compliant test suites"""
        logger.info("üîç Validating Test Suites...")
        
        test_files = [
            "test_strategic_signal_orchestrator_v2.py",
            "test_architect_compliant_broker_discovery.py"
        ]
        
        validated_tests = 0
        
        for test_file in test_files:
            if Path(test_file).exists():
                # Check for real usage (should be none)
                with open(test_file, 'r') as f:
                    content = f.read()
                    
                if "from unittest.real import" in content or "import real" in content:
                    self.validation_results["validation_passed"] = False
                    logger.error(f"‚ùå {test_file} contains real usage - architect violation")
                else:
                    logger.info(f"‚úÖ {test_file} is architect-compliant")
                    validated_tests += 1
            else:
                logger.warning(f"‚ö†Ô∏è {test_file} not found")
                
        self.validation_results["details"]["architect_compliant_tests"] = validated_tests
        return validated_tests > 0
        
    def validate_telemetry_dashboard_enhancements(self):
        """Validate telemetry dashboard Phase 35 enhancements"""
        logger.info("üîç Validating Telemetry Dashboard Enhancements...")
        
        dashboard_file = Path("telemetry_dashboard.py")
        if not dashboard_file.exists():
            self.validation_results["validation_passed"] = False
            logger.error("‚ùå telemetry_dashboard.py not found")
            return False
            
        with open(dashboard_file, 'r') as f:
            content = f.read()
            
        # Check for Phase 35 fields
        phase35_fields = [
            "signal_priority_queue",
            "suppression_flags", 
            "execution_latency",
            "rule_profile_active",
            "account_type_detected",
            "override_mode_enabled"
        ]
        
        missing_fields = []
        for field in phase35_fields:
            if field not in content:
                missing_fields.append(field)
                
        if missing_fields:
            self.validation_results["validation_passed"] = False
            logger.error(f"‚ùå Missing telemetry fields: {missing_fields}")
            return False
            
        logger.info("‚úÖ Telemetry dashboard Phase 35 enhancements validated")
        self.validation_results["details"]["telemetry_fields_validated"] = len(phase35_fields)
        return True
        
    def validate_system_registration(self):
        """Validate system tree and module registry updates"""
        logger.info("üîç Validating System Registration...")
        
        # Check build status
        if Path("build_status.json").exists():
            with open("build_status.json", 'r') as f:
                build_status = json.load(f)
                
            if build_status.get("phase_35") == "complete":
                logger.info("‚úÖ Phase 35 marked complete in build status")
                self.validation_results["details"]["build_status_updated"] = True
            else:
                logger.warning("‚ö†Ô∏è Phase 35 not marked complete in build status")
                
        # Check system tree
        if Path("system_tree.json").exists():
            with open("system_tree.json", 'r') as f:
                system_tree = json.load(f)
                
            metadata = system_tree.get("metadata", {})
            if metadata.get("phase_35_strategic_signal_orchestrator_integrated"):
                logger.info("‚úÖ Strategic Signal Orchestrator registered in system tree")
                self.validation_results["details"]["system_tree_updated"] = True
            else:
                logger.warning("‚ö†Ô∏è Strategic Signal Orchestrator not found in system tree")
                
        return True
        
    def validate_eventbus_routes(self):
        """Validate EventBus route configuration"""
        logger.info("üîç Validating EventBus Routes...")
        
        if not Path("event_bus.json").exists():
            self.validation_results["validation_passed"] = False
            logger.error("‚ùå event_bus.json not found")
            return False
            
        with open("event_bus.json", 'r') as f:
            event_bus = json.load(f)
            
        metadata = event_bus.get("metadata", {})
        if metadata.get("phase_35_strategic_signal_orchestrator_routes_added"):
            logger.info("‚úÖ Phase 35 EventBus routes validated")
            self.validation_results["details"]["eventbus_routes_updated"] = True
            return True
        else:
            logger.warning("‚ö†Ô∏è Phase 35 EventBus routes not confirmed")
            return False
            
    def run_validation(self):
        """Run complete Phase 35 validation"""
        logger.info("üöÄ STARTING PHASE 35 STRATEGIC SIGNAL ORCHESTRATOR VALIDATION")
        logger.info("="*80)
        
        validation_steps = [
            ("Strategic Signal Orchestrator", self.validate_strategic_signal_orchestrator),
            ("Orchestration Configuration", self.validate_orchestration_config),
            ("Test Suites", self.validate_test_suites),
            ("Telemetry Dashboard", self.validate_telemetry_dashboard_enhancements),
            ("System Registration", self.validate_system_registration),
            ("EventBus Routes", self.validate_eventbus_routes)
        ]
        
        for step_name, validation_func in validation_steps:
            try:
                result = validation_func()
                self.validation_results["components_validated"].append({
                    "component": step_name,
                    "validated": result,
                    "timestamp": datetime.utcnow().isoformat()
                })
            except Exception as e:
                logger.error(f"‚ùå Validation failed for {step_name}: {e}")
                self.validation_results["validation_passed"] = False
                self.validation_results["components_validated"].append({
                    "component": step_name,
                    "validated": False,
                    "error": str(e),
                    "timestamp": datetime.utcnow().isoformat()
                })
                
        # Final results
        logger.info("="*80)
        if self.validation_results["validation_passed"]:
            logger.info("‚úÖ PHASE 35 VALIDATION SUCCESSFUL")
            logger.info("üéØ Strategic Signal Orchestrator is operational and compliant")
        else:
            logger.error("‚ùå PHASE 35 VALIDATION FAILED")
            logger.error("üîß Review validation details and fix issues")
            
        # Save results
        results_file = f"phase35_validation_results_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.json"
        with open(results_file, 'w') as f:
            json.dump(self.validation_results, f, indent=2)
            
        logger.info(f"üìÑ Validation results saved to: {results_file}")
        return self.validation_results

def main():
    """Main validation execution"""
    validator = Phase35Validator()
    results = validator.run_validation()
    
    # Print summary
    print("\\n" + "="*80)
    print("PHASE 35 STRATEGIC SIGNAL ORCHESTRATOR VALIDATION SUMMARY")
    print("="*80)
    print(f"Validation Status: {'‚úÖ PASSED' if results['validation_passed'] else '‚ùå FAILED'}")
    print(f"Components Validated: {len(results['components_validated'])}")
    print(f"Architect Mode Version: {results['architect_mode_version']}")
    print(f"Validation Timestamp: {results['validation_timestamp']}")
    print("="*80)
    
    return results['validation_passed']

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)

    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        

# <!-- @GENESIS_MODULE_END: validate_phase35_completion -->