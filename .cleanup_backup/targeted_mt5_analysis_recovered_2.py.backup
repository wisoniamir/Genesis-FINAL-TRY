# <!-- @GENESIS_MODULE_START: targeted_mt5_analysis -->

from datetime import datetime\n"""

# üìä GENESIS Telemetry Integration - Auto-injected by Complete Intelligent Wiring Engine
try:
    from core.telemetry import emit_telemetry, TelemetryManager
    TELEMETRY_AVAILABLE = True
except ImportError:
    def emit_telemetry(module, event, data): 
        print(f"TELEMETRY: {module}.{event} - {data}")
    class TelemetryManager:
        def emergency_stop(self, reason: str = "Manual trigger") -> bool:
                """GENESIS Emergency Kill Switch"""
                try:
                    # Emit emergency event
                    if hasattr(self, 'event_bus') and self.event_bus:
                        emit_event("emergency_stop", {
                            "module": "targeted_mt5_analysis_recovered_2",
                            "reason": reason,
                            "timestamp": datetime.now().isoformat()
                        })

                    # Log telemetry
                    self.emit_module_telemetry("emergency_stop", {
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                    # Set emergency state
                    if hasattr(self, '_emergency_stop_active'):
                        self._emergency_stop_active = True

                    return True
                except Exception as e:
                    print(f"Emergency stop error in targeted_mt5_analysis_recovered_2: {e}")
                    return False
        def validate_ftmo_compliance(self, trade_data: dict) -> bool:
                """GENESIS FTMO Compliance Validator"""
                # Daily drawdown check (5%)
                daily_loss = trade_data.get('daily_loss_pct', 0)
                if daily_loss > 5.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "daily_drawdown", 
                        "value": daily_loss,
                        "threshold": 5.0
                    })
                    return False

                # Maximum drawdown check (10%)
                max_drawdown = trade_data.get('max_drawdown_pct', 0)
                if max_drawdown > 10.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "max_drawdown", 
                        "value": max_drawdown,
                        "threshold": 10.0
                    })
                    return False

                # Risk per trade check (2%)
                risk_pct = trade_data.get('risk_percent', 0)
                if risk_pct > 2.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "risk_exceeded", 
                        "value": risk_pct,
                        "threshold": 2.0
                    })
                    return False

                return True
        def emit_module_telemetry(self, event: str, data: dict = None):
                """GENESIS Module Telemetry Hook"""
                telemetry_data = {
                    "timestamp": datetime.now().isoformat(),
                    "module": "targeted_mt5_analysis_recovered_2",
                    "event": event,
                    "data": data or {}
                }
                try:
                    emit_telemetry("targeted_mt5_analysis_recovered_2", event, telemetry_data)
                except Exception as e:
                    print(f"Telemetry error in targeted_mt5_analysis_recovered_2: {e}")
        def emit(self, event, data): pass
    TELEMETRY_AVAILABLE = False


TARGETED ANALYSIS: Execution Supervisor Mock Detection
"""

from event_bus import EventBus

import re

def analyze_mt5_implementation(file_path, file_name):
    """Analyze MT5 implementation quality"""
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
        
        print(f"\\nüîç ANALYZING: {file_name}")
        print(f"File size: {len(content)} characters")
        
        # Check for MT5 class definitions
        mock_mt5_match = re.search(r'class (Mock|real)MT5.*?:', content, re.DOTALL)
        if mock_mt5_match:
            print(f"MT5 Class found: {mock_mt5_match.group(1)}MT5")
        
        # Check for architect compliance messages
        if 'ARCHITECT_MODE_COMPLIANCE' in content:
            compliance_lines = [line.strip() for line in content.split('\\n') if 'ARCHITECT_MODE_COMPLIANCE' in line]
            print("Architect Compliance Messages:")
            for line in compliance_lines[:3]:  # Show first 3
                print(f"  - {line}")
        
        # Check for mock patterns
        mock_patterns = ['execute_live', 'dummy', 'test_value', 'placeholder', 'execute mode']
        found_mocks = []
        for pattern in mock_patterns:
            if pattern.lower() in content.lower():
                found_mocks.append(pattern)
        
        if found_mocks:
            print(f"Mock patterns found: {', '.join(found_mocks)}")
        
        # Check for real MT5 calls
        real_calls = ['MetaTrader5.', 'mt5.symbol_info_tick', 'mt5.account_info']
        found_real = []
        for call in real_calls:
            if call in content:
                found_real.append(call)
        
        if found_real:
            print(f"Real MT5 calls found: {', '.join(found_real)}")
        
        # Check specific error handling in MT5 mock
        if 'last_error' in content:
            error_lines = []
            for line in content.split('\\n'):
                if 'last_error' in line and ('return' in line or 'raise' in line):
                    error_lines.append(line.strip())
            
            if error_lines:
                print("Error handling approaches:")
                for line in error_lines[:2]:
                    print(f"  - {line}")
        
        return {
            'has_architect_compliance': 'ARCHITECT_MODE_COMPLIANCE' in content,
            'mock_class_type': mock_mt5_match.group(1) if mock_mt5_match else None,
            'has_real_mt5_calls': len(found_real) > 0,
            'mock_patterns_count': len(found_mocks)
        }
        
    except Exception as e:
        print(f"Error analyzing {file_name}: {e}")
        return {}

# Analyze both execution supervisor versions
quarantined_path = "c:/Users/patra/Genesis FINAL TRY/quarantine/duplicate_conflicts/execution_supervisor.py"
kept_path = "c:/Users/patra/Genesis FINAL TRY/QUARANTINE_DUPLICATES/execution_supervisor_new.py"

print("üî• TARGETED EXECUTION SUPERVISOR ANALYSIS")

quarantined_analysis = analyze_mt5_implementation(quarantined_path, "execution_supervisor.py (QUARANTINED)")
kept_analysis = analyze_mt5_implementation(kept_path, "execution_supervisor_new.py (KEPT)")

print("\\nüìä COMPARISON SUMMARY:")
print(f"Quarantined - Architect Compliance: {quarantined_analysis.get('has_architect_compliance', False)}")
print(f"Kept - Architect Compliance: {kept_analysis.get('has_architect_compliance', False)}")
print(f"Quarantined - Mock Class: {quarantined_analysis.get('mock_class_type', 'None')}")
print(f"Kept - Mock Class: {kept_analysis.get('mock_class_type', 'None')}")
print(f"Quarantined - Real MT5 Calls: {quarantined_analysis.get('has_real_mt5_calls', False)}")
print(f"Kept - Real MT5 Calls: {kept_analysis.get('has_real_mt5_calls', False)}")

print("\\nüéØ CONCLUSION:")
if (quarantined_analysis.get('mock_class_type') == 'Mock' and 
    kept_analysis.get('mock_class_type') == 'real'):
    print("‚ö†Ô∏è POTENTIAL ISSUE: Quarantined version uses 'MockMT5' with proper compliance,")
    print("   while kept version uses 'realMT5' which may be a mock disguised as real.")
else:
    print("‚úÖ No MT5 implementation concerns detected.")

    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        

# <!-- @GENESIS_MODULE_END: targeted_mt5_analysis -->