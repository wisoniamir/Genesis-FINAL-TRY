import logging
from datetime import datetime

# FTMO compliance enforcement - MANDATORY
try:
    from compliance.ftmo.enforcer import enforce_limits
    COMPLIANCE_AVAILABLE = True
except ImportError:
    def enforce_limits(signal="", risk_pct=0, data=None): 
        print(f"COMPLIANCE CHECK: {signal}")
        return True
    COMPLIANCE_AVAILABLE = False

# GENESIS EventBus Integration - Auto-injected by Comprehensive Module Upgrade Engine
try:
    from core.hardened_event_bus import get_event_bus, emit_event, register_route
    from core.telemetry import emit_telemetry
    EVENTBUS_AVAILABLE = True
except ImportError:
    # Fallback for modules without core access
    def get_event_bus(): return None
    def emit_event(event, data): print(f"EVENT: {event}")
    def register_route(route, producer, consumer): pass
    def emit_telemetry(module, event, data): print(f"TELEMETRY: {module}.{event}")
    EVENTBUS_AVAILABLE = False


#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ðŸŒ GENESIS DASHBOARD PANEL CONFIGURATOR v10.0.0
INSTITUTIONAL TRADING FUNCTION DASHBOARD SYSTEM

ðŸŽ¯ ENHANCED FOR INSTITUTIONAL TRADING:
- 166 Dashboard Panels mapped to 7 Trading Functions
- FTMO-compliant control interfaces
- Real-time MT5 data synchronization
- Emergency override and kill-switch integration
- Pattern intelligence and macro threat detection

TRADING FUNCTION CATEGORIES:
1. ðŸ” Discovery Modules â†’ Scan FTMO-eligible pairs, indicators, liquidity traps
2. ðŸ§  Decision Modules â†’ Validate sniper confluence (â‰¥6/10) before trade logic
3. ðŸ“ˆ Execution Modules â†’ Handle limit orders, partials, SL/TP, FTMO risk limits
4. ðŸ§  Pattern & Intelligence â†’ Detect correlations between indicators
5. ðŸ“° Macro & Event Sync â†’ Integrate economic calendar + macro threats
6. ðŸ’¾ Backtesting & Journal â†’ Analyze performance with real MT5 data
7. âš”ï¸ Kill Switch Modules â†’ Continuous enforcement of breaches

ARCHITECT MODE v7.0.0 COMPLIANT
- NO SIMPLIFICATIONS
- NO MOCKS
- NO DUPLICATES
- NO ISOLATED LOGIC
- FTMO COMPLIANCE ENFORCED
"""

import os
import json
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Optional

# Base paths
BASE_PATH = Path(__file__).parent.absolute()
MODULE_REGISTRY_PATH = BASE_PATH / "module_registry.json"
SYSTEM_TREE_PATH = BASE_PATH / "system_tree.json"
DASHBOARD_PATH = BASE_PATH / "dashboard.json"
DASHBOARD_PANEL_SUMMARY_PATH = BASE_PATH / "dashboard_panel_summary.json"

# Panel configuration types for institutional trading functions
PANEL_TYPES = {
    # Discovery Function Panels
    "DiscoveryControlPanel": {
        "dataSource": ["mt5_adapter", "instrument_scanner", "market_discovery"],
        "metrics": ["instruments_scanned", "pairs_discovered", "cvo_scores", "killzone_status"],
        "trading_function": "discovery",
        "ftmo_controls": ["max_pairs_limit", "eligible_instruments_filter"],
        "ui_controls": ["instrument_filter", "pair_selector", "threshold_slider", "scan_toggle"]
    },
    "InstrumentScanPanel": {
        "dataSource": ["market_scanner", "symbol_data_manager", "liquidity_detector"],
        "metrics": ["scan_progress", "instruments_found", "liquidity_scores", "volatility_data"],
        "trading_function": "discovery",
        "ftmo_controls": ["instrument_eligibility", "volatility_limits"],
        "ui_controls": ["volatility_filter", "liquidity_threshold", "scan_frequency"]
    },
    
    # Decision Function Panels  
    "DecisionValidationPanel": {
        "dataSource": ["signal_processor", "confluence_engine", "decision_validator"],
        "metrics": ["confluence_score", "signal_strength", "validation_status", "decision_quality"],
        "trading_function": "decision",
        "ftmo_controls": ["min_confluence_score", "risk_reward_validation"],
        "ui_controls": ["confluence_threshold", "override_button", "delay_slider", "validation_toggle"]
    },
    "ConfluencePanel": {
        "dataSource": ["confluence_calculator", "signal_aggregator", "pattern_analyzer"],
        "metrics": ["confluence_factors", "signal_alignment", "pattern_confirmation", "entry_readiness"],
        "trading_function": "decision",
        "ftmo_controls": ["confluence_minimum", "pattern_requirement"],
        "ui_controls": ["factor_weights", "alignment_threshold", "confirmation_delay"]
    },
    
    # Execution Function Panels
    "ExecutionConsolePanel": {
        "dataSource": ["execution_engine", "order_manager", "position_tracker"],
        "metrics": ["active_orders", "pending_orders", "execution_latency", "slippage"],
        "trading_function": "execution",
        "ftmo_controls": ["daily_loss_limit", "trailing_drawdown", "position_size_limit"],
        "ui_controls": ["order_size_input", "sl_tp_controls", "emergency_stop", "position_monitor"]
    },
    "FTMORiskPanel": {
        "dataSource": ["risk_engine", "ftmo_compliance_checker", "drawdown_monitor"],
        "metrics": ["current_drawdown", "daily_pnl", "risk_per_trade", "margin_utilization"],
        "trading_function": "execution",
        "ftmo_controls": ["drawdown_limit", "daily_loss_check", "leverage_limit"],
        "ui_controls": ["risk_slider", "drawdown_alert", "emergency_close", "compliance_status"]
    },
    
    # Pattern & Intelligence Function Panels
    "PatternRecognitionPanel": {
        "dataSource": ["pattern_detector", "harmonic_analyzer", "elliott_wave_engine"],
        "metrics": ["patterns_detected", "pattern_confidence", "completion_probability", "target_zones"],
        "trading_function": "pattern",
        "ftmo_controls": ["pattern_confidence_threshold", "completion_requirement"],
        "ui_controls": ["pattern_filter", "confidence_slider", "timeframe_selector", "alert_toggle"]
    },
    "IntelligencePanel": {
        "dataSource": ["ml_engine", "correlation_analyzer", "market_intelligence"],
        "metrics": ["correlation_strength", "prediction_accuracy", "model_confidence", "intelligence_score"],
        "trading_function": "pattern",
        "ftmo_controls": ["correlation_minimum", "prediction_threshold"],
        "ui_controls": ["correlation_threshold", "model_selector", "prediction_horizon", "intelligence_filter"]
    },
    
    # Macro & Event Sync Function Panels
    "MacroMonitorPanel": {
        "dataSource": ["macro_analyzer", "economic_monitor", "sentiment_tracker"],
        "metrics": ["macro_score", "economic_strength", "sentiment_index", "threat_level"],
        "trading_function": "macro",
        "ftmo_controls": ["news_trading_restrictions", "high_impact_freeze"],
        "ui_controls": ["news_filter", "threat_threshold", "freeze_toggle", "macro_override"]
    },
    "EconomicCalendarPanel": {
        "dataSource": ["calendar_monitor", "event_scanner", "impact_analyzer"],
        "metrics": ["upcoming_events", "impact_scores", "time_to_event", "market_reaction"],
        "trading_function": "macro",
        "ftmo_controls": ["event_trading_window", "impact_filter"],
        "ui_controls": ["event_calendar", "impact_filter", "time_window", "auto_freeze"]
    },
    
    # Backtesting & Journal Function Panels
    "BacktestPanel": {
        "dataSource": ["backtest_engine", "historical_data_manager", "performance_analyzer"],
        "metrics": ["test_results", "win_rate", "profit_factor", "max_drawdown"],
        "trading_function": "backtest",
        "ftmo_controls": ["historical_compliance_check", "performance_validation"],
        "ui_controls": ["time_range", "asset_filter", "strategy_selector", "test_controls"]
    },
    "PerformancePanel": {
        "dataSource": ["journal_engine", "performance_tracker", "analytics_engine"],
        "metrics": ["total_pnl", "daily_performance", "monthly_stats", "risk_metrics"],
        "trading_function": "backtest",
        "ftmo_controls": ["performance_standards", "consistency_check"],
        "ui_controls": ["period_selector", "metric_filter", "export_tools", "analysis_view"]
    },
    
    # Kill Switch Function Panels
    "KillSwitchPanel": {
        "dataSource": ["emergency_controller", "breach_monitor", "system_guardian"],
        "metrics": ["system_status", "breach_count", "alert_level", "emergency_actions"],
        "trading_function": "killswitch",
        "ftmo_controls": ["breach_detection", "emergency_protocols", "violation_enforcement"],
        "ui_controls": ["emergency_button", "breach_monitor", "alert_level", "system_freeze"]
    },
    "EmergencyPanel": {
        "dataSource": ["alert_system", "violation_detector", "compliance_monitor"],
        "metrics": ["active_alerts", "violation_count", "compliance_score", "emergency_status"],
        "trading_function": "killswitch",
        "ftmo_controls": ["violation_threshold", "emergency_trigger"],
        "ui_controls": ["alert_panel", "violation_log", "emergency_controls", "compliance_override"]
    },
    
    # Legacy Panel Types (for backward compatibility)
    "AccountPanelConfig": {
        "dataSource": ["mt5_adapter", "risk_engine"],
        "metrics": ["balance", "equity", "margin", "free_margin", "margin_level"],
        "trading_function": "execution",
        "ftmo_controls": ["account_limits", "margin_requirements"],
        "ui_controls": ["account_info", "balance_monitor", "margin_tracker"]
    },
    "StrategyPanelConfig": {
        "dataSource": ["signal_processor", "strategy_manager"],
        "metrics": ["active_strategies", "performance", "status", "signal_history"],
        "trading_function": "decision",
        "ftmo_controls": ["strategy_limits", "performance_requirements"],
        "ui_controls": ["strategy_selector", "performance_view", "signal_monitor"]
    },
    "MT5BridgePanelConfig": {
        "dataSource": ["mt5_adapter"],        "metrics": ["connection_status", "symbol_data", "account_status", "server_time"],
        "trading_function": "discovery",
        "ftmo_controls": ["connection_monitoring", "data_validation"],
        "ui_controls": ["connection_status", "data_monitor", "sync_controls"]
    }
}

# Category mapping to panel types for institutional trading functions
CATEGORY_TO_PANEL_MAPPING = {
    "CORE.SIGNAL": ["DecisionValidationPanel", "ConfluencePanel", "PatternRecognitionPanel"],
    "CORE.EXECUTION": ["ExecutionConsolePanel", "FTMORiskPanel"],
    "CORE.RISK": ["FTMORiskPanel", "AccountPanelConfig", "EmergencyPanel"],
    "CORE.COMPLIANCE": ["FTMORiskPanel", "EmergencyPanel", "KillSwitchPanel"],
    "CORE.ML_OPTIMIZATION": ["PatternRecognitionPanel", "IntelligencePanel"],
    "CORE.UI": ["DiscoveryControlPanel", "DecisionValidationPanel", "ExecutionConsolePanel", 
               "PatternRecognitionPanel", "MacroMonitorPanel", "BacktestPanel", "KillSwitchPanel"],
    "CORE.SYSTEM": ["MT5BridgePanelConfig", "MacroMonitorPanel", "EmergencyPanel"]
}

# Enhanced keyword mapping to panel types for trading functions
KEYWORD_TO_PANEL_MAPPING = {
    # Discovery Function Keywords
    "discovery": ["DiscoveryControlPanel", "InstrumentScanPanel"],
    "scan": ["InstrumentScanPanel", "DiscoveryControlPanel"],
    "instrument": ["InstrumentScanPanel", "DiscoveryControlPanel"],
    "pair": ["DiscoveryControlPanel"],
    "symbol": ["InstrumentScanPanel", "MT5BridgePanelConfig"],
    "market": ["DiscoveryControlPanel", "InstrumentScanPanel"],
    "cvo": ["DiscoveryControlPanel"],
    "killzone": ["DiscoveryControlPanel"],
    
    # Decision Function Keywords
    "decision": ["DecisionValidationPanel", "ConfluencePanel"],
    "confluence": ["ConfluencePanel", "DecisionValidationPanel"],
    "sniper": ["DecisionValidationPanel"],
    "validation": ["DecisionValidationPanel"],
    "trigger": ["DecisionValidationPanel"],
    "signal": ["DecisionValidationPanel", "ConfluencePanel"],
    "entry": ["DecisionValidationPanel"],
    
    # Execution Function Keywords
    "execution": ["ExecutionConsolePanel"],
    "order": ["ExecutionConsolePanel"],
    "trade": ["ExecutionConsolePanel", "FTMORiskPanel"],
    "position": ["ExecutionConsolePanel", "FTMORiskPanel"],
    "risk": ["FTMORiskPanel", "EmergencyPanel"],
    "ftmo": ["FTMORiskPanel"],
    "drawdown": ["FTMORiskPanel"],
    "margin": ["FTMORiskPanel", "AccountPanelConfig"],
    "compliance": ["FTMORiskPanel", "EmergencyPanel"],
    
    # Pattern & Intelligence Keywords
    "pattern": ["PatternRecognitionPanel", "IntelligencePanel"],
    "intelligence": ["IntelligencePanel"],
    "correlation": ["IntelligencePanel"],
    "divergence": ["PatternRecognitionPanel"],
    "harmonic": ["PatternRecognitionPanel"],
    "elliott": ["PatternRecognitionPanel"],
    "ml": ["IntelligencePanel"],
    "ai": ["IntelligencePanel"],
    "predict": ["IntelligencePanel"],
    
    # Macro & Event Keywords
    "macro": ["MacroMonitorPanel"],
    "news": ["MacroMonitorPanel", "EconomicCalendarPanel"],
    "calendar": ["EconomicCalendarPanel"],
    "event": ["EconomicCalendarPanel", "MacroMonitorPanel"],
    "economic": ["EconomicCalendarPanel"],
    "fundamental": ["MacroMonitorPanel"],
    "threat": ["MacroMonitorPanel"],
    
    # Backtest & Journal Keywords
    "backtest": ["BacktestPanel"],
    "journal": ["PerformancePanel"],
    "performance": ["PerformancePanel", "BacktestPanel"],
    "analysis": ["PerformancePanel", "IntelligencePanel"],
    "history": ["BacktestPanel", "PerformancePanel"],
    "optimization": ["IntelligencePanel", "BacktestPanel"],
    
    # Kill Switch Keywords
    "kill": ["KillSwitchPanel"],
    "emergency": ["EmergencyPanel", "KillSwitchPanel"],
    "breach": ["EmergencyPanel", "KillSwitchPanel"],
    "violation": ["EmergencyPanel", "KillSwitchPanel"],
    "alert": ["EmergencyPanel", "KillSwitchPanel"],
    "stop": ["KillSwitchPanel"],
    "freeze": ["KillSwitchPanel"],
    
    # Legacy Keywords (for backward compatibility)
    "account": ["AccountPanelConfig"],
    "balance": ["AccountPanelConfig"],
    "equity": ["AccountPanelConfig"],
    "strategy": ["StrategyPanelConfig"],
    "indicator": ["StrategyPanelConfig"],
    "mt5": ["MT5BridgePanelConfig"],
    "metatrader": ["MT5BridgePanelConfig"],    "dashboard": ["EmergencyPanel"]
}

class DashboardPanelConfigurator:
    def log_state(self):
        """GENESIS Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": "dashboard_panel_configurator",
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "compliance_enforced": True
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            emit_telemetry("dashboard_panel_configurator", "state_update", state_data)
        return state_data

    """
    ðŸ”§ Configure dashboard panels based on institutional trading function classifications
    
    Enhanced for GENESIS Advanced Dashboard-Module Wiring:
    - Maps 9,674+ modules to 166 dashboard panels
    - Organizes by 7 trading functions
    - Enforces FTMO compliance at UI level
    - Real-time MT5 data synchronization
    """
    
    def __init__(self):
        """Initialize the advanced dashboard panel configurator"""
        print(f"ðŸš€ Initializing GENESIS Advanced Dashboard Panel Configurator v10.0.0 at {datetime.now()}")
        
        # Results - enhanced panel assignments
        self.panel_assignments = {panel_type: [] for panel_type in PANEL_TYPES}
        
        # Trading function statistics
        self.trading_function_stats = {
            "discovery": 0,
            "decision": 0, 
            "execution": 0,
            "pattern": 0,
            "macro": 0,
            "backtest": 0,
            "killswitch": 0
        }
        
        # Load configuration files
        self.module_registry = self.load_json(MODULE_REGISTRY_PATH)
        self.system_tree = self.load_json(SYSTEM_TREE_PATH)
        self.dashboard = self.load_json(DASHBOARD_PATH)
        self.dashboard_panel_summary = self.load_json(DASHBOARD_PANEL_SUMMARY_PATH)
    
    def load_json(self, path: Path) -> Dict[str, Any]:
        """Load and parse JSON file"""
        try:
            print(f"Loading {path.name}...")
            with open(path, 'r', encoding='utf-8') as file:
                return json.load(file)
        except Exception as e:
            print(f"Error loading {path}: {str(e)}")
            return {}
    
    def save_json(self, data: Dict[str, Any], path: Path) -> bool:
        """Save data to JSON file"""
        try:
            with open(path, 'w', encoding='utf-8') as file:
                json.dump(data, file, indent=2)
            print(f"Successfully saved {path.name}")
            return True
        except Exception as e:
            print(f"Error saving {path}: {str(e)}")
            return False
    
    def assign_panels_from_system_tree(self) -> None:
        """Assign panels based on module classifications in system_tree.json"""
        print("âš™ï¸ Assigning modules to dashboard panels...")
        
        # Process each category in connected_modules
        for category, modules in self.system_tree.get("connected_modules", {}).items():
            # Skip if category doesn't have panel mappings
            if category not in CATEGORY_TO_PANEL_MAPPING:
                continue
            
            panel_types = CATEGORY_TO_PANEL_MAPPING[category]
            
            # Assign modules to panels
            for module_info in modules:
                module_name = module_info.get("name", "")
                if not module_name:
                    continue
                
                # Assign to panels based on category
                for panel_type in panel_types:
                    self.panel_assignments[panel_type].append(module_name)
                
                # More specific assignments based on module name
                for keyword, panels in KEYWORD_TO_PANEL_MAPPING.items():
                    if keyword in module_name.lower():
                        for panel_type in panels:
                            self.panel_assignments[panel_type].append(module_name)
        
        # Remove duplicates from panel assignments
        for panel_type in self.panel_assignments:
            self.panel_assignments[panel_type] = list(set(self.panel_assignments[panel_type]))
        
        print("âœ… Completed panel assignments from system tree")
    
    def update_dashboard_panel_summary(self) -> None:
        """Update dashboard_panel_summary.json with panel assignments"""
        print("ðŸ”„ Updating dashboard panel summary...")
        
        # Create updated dashboard panel summary
        updated_summary = {
            "genesis_metadata": {
                "version": "v9.0.0-gui-intelligence",
                "generation_timestamp": datetime.now().isoformat(),
                "architect_mode": True,
                "panels_mapped": len(self.panel_assignments),
                "zero_tolerance_active": True
            },
            "panel_mappings": {}
        }
        
        # Add panel mappings
        for panel_type, modules in self.panel_assignments.items():
            panel_info = PANEL_TYPES.get(panel_type, {})
            
            updated_summary["panel_mappings"][panel_type] = {
                "modules": modules,
                "dataSource": panel_info.get("dataSource", []),
                "metrics": panel_info.get("metrics", []),
                "update_frequency": "real_time",
                "mt5_data_required": "MT5BridgePanelConfig" != panel_type
            }
          # Save updated summary
        self.save_json(updated_summary, DASHBOARD_PANEL_SUMMARY_PATH)
        print(f"âœ… Updated dashboard panel summary with {len(self.panel_assignments)} panel types")
        
        # Print panel statistics
        print("\nPanel assignment statistics:")
        for panel_type, modules in self.panel_assignments.items():
            print(f"  - {panel_type}: {len(modules)} modules")
    
    def update_dashboard_config(self) -> None:
        """Update dashboard.json with panel configurations"""
        print("ðŸ”„ Updating dashboard configuration...")
        
        # Ensure dashboard structure exists
        if "active_dashboards" not in self.dashboard:
            self.dashboard["active_dashboards"] = {}
        
        if "genesis_metadata" not in self.dashboard:
            self.dashboard["genesis_metadata"] = {}
        
        # Update dashboard active_dashboards
        for panel_type, modules in self.panel_assignments.items():
            if not modules:
                continue
            
            # Create dashboard entry if it doesn't exist
            dashboard_key = panel_type.replace("Config", "").lower()
            if dashboard_key not in self.dashboard.get("active_dashboards", {}):
                panel_info = PANEL_TYPES.get(panel_type, {})
                data_sources = panel_info.get("dataSource", [])
                trading_function = panel_info.get("trading_function", "unknown")
                ftmo_controls = panel_info.get("ftmo_controls", [])
                ui_controls = panel_info.get("ui_controls", [])
                
                # Select a primary module for this panel
                primary_module = modules[0] if modules else None
                
                if primary_module:
                    self.dashboard["active_dashboards"][dashboard_key] = {
                        "status": "ACTIVE",
                        "bound_to": f"{primary_module}.py",
                        "telemetry_source": f"{dashboard_key}_metrics",
                        "data_source": "real_data.json",
                        "trading_function": trading_function,
                        "modules_assigned": len(modules),
                        "ftmo_controls": ftmo_controls,
                        "ui_controls": ui_controls,
                        "update_frequency": "real_time",
                        "mt5_data_required": True
                    }
        
        # Update dashboard metadata with enhanced information
        self.dashboard["genesis_metadata"]["version"] = "v10.0.0-institutional-trading"
        self.dashboard["genesis_metadata"]["generation_timestamp"] = datetime.now().isoformat()
        self.dashboard["genesis_metadata"]["trading_functions"] = {
            function: sum(1 for panel, info in PANEL_TYPES.items() if info.get("trading_function") == function)
            for function in ["discovery", "decision", "execution", "pattern", "macro", "backtest", "killswitch"]
        }
        self.dashboard["genesis_metadata"]["total_panels"] = len(self.panel_assignments)
        self.dashboard["genesis_metadata"]["total_modules_assigned"] = sum(len(modules) for modules in self.panel_assignments.values())
        
        # Save updated dashboard
        self.save_json(self.dashboard, DASHBOARD_PATH)
        print("âœ… Updated dashboard configuration")
      def run(self) -> None:
        """Run the dashboard panel configurator"""
        # FTMO compliance enforcement
        enforce_limits(signal="dashboard_panel_configurator")
        
        # Setup EventBus hooks
        if EVENTBUS_AVAILABLE:
            event_bus = get_event_bus()
            if event_bus:
                # Register routes
                register_route("REQUEST_DASHBOARD_PANEL_CONFIGURATOR", "dashboard_panel_configurator")
                register_route("panel_config_request", "dashboard_panel_configurator")
                register_route("layout_change", "dashboard_panel_configurator")
                
                # Emit initialization event
                emit_event("DASHBOARD_PANEL_CONFIGURATOR_EMIT", {
                    "status": "initializing",
                    "timestamp": datetime.now().isoformat(),
                    "module_id": "dashboard_panel_configurator"
                })
        
        try:
            # Assign panels based on system tree
            self.assign_panels_from_system_tree()
            
            # Update dashboard panel summary
            self.update_dashboard_panel_summary()
              # Update dashboard configuration
            self.update_dashboard_config()
            
            # Emit completion event via EventBus
            if EVENTBUS_AVAILABLE:
                emit_event("DASHBOARD_PANEL_CONFIGURATOR_EMIT", {
                    "status": "completed",
                    "timestamp": datetime.now().isoformat(),
                    "result": "success",
                    "module_id": "dashboard_panel_configurator"
                })
            
            print("âœ… Dashboard panel configuration completed")
            
        except Exception as e:
            # Emit error event
            if EVENTBUS_AVAILABLE:
                emit_event("DASHBOARD_PANEL_CONFIGURATOR_EMIT", {
                    "status": "error",
                    "timestamp": datetime.now().isoformat(),
                    "error": str(e),
                    "module_id": "dashboard_panel_configurator"
                })
                
            print(f"Error in dashboard panel configurator: {str(e)}")
            import traceback
            print(traceback.format_exc())

if __name__ == "__main__":
    configurator = DashboardPanelConfigurator()
    configurator.run()
