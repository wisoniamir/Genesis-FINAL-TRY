
# ðŸ“Š GENESIS Telemetry Integration - Auto-injected by Complete Intelligent Wiring Engine
try:
    from core.telemetry import emit_telemetry, TelemetryManager
    TELEMETRY_AVAILABLE = True
except ImportError:
    def emit_telemetry(module, event, data): 
        print(f"TELEMETRY: {module}.{event} - {data}")
    class TelemetryManager:
        def emergency_stop(self, reason: str = "Manual trigger") -> bool:
                """GENESIS Emergency Kill Switch"""
                try:
                    # Emit emergency event
                    if hasattr(self, 'event_bus') and self.event_bus:
                        emit_event("emergency_stop", {
                            "module": "dynamic_event_bus",
                            "reason": reason,
                            "timestamp": datetime.now().isoformat()
                        })

                    # Log telemetry
                    self.emit_module_telemetry("emergency_stop", {
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                    # Set emergency state
                    if hasattr(self, '_emergency_stop_active'):
                        self._emergency_stop_active = True

                    return True
                except Exception as e:
                    print(f"Emergency stop error in dynamic_event_bus: {e}")
                    return False
        def validate_ftmo_compliance(self, trade_data: dict) -> bool:
                """GENESIS FTMO Compliance Validator"""
                # Daily drawdown check (5%)
                daily_loss = trade_data.get('daily_loss_pct', 0)
                if daily_loss > 5.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "daily_drawdown", 
                        "value": daily_loss,
                        "threshold": 5.0
                    })
                    return False

                # Maximum drawdown check (10%)
                max_drawdown = trade_data.get('max_drawdown_pct', 0)
                if max_drawdown > 10.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "max_drawdown", 
                        "value": max_drawdown,
                        "threshold": 10.0
                    })
                    return False

                # Risk per trade check (2%)
                risk_pct = trade_data.get('risk_percent', 0)
                if risk_pct > 2.0:
                    self.emit_module_telemetry("ftmo_violation", {
                        "type": "risk_exceeded", 
                        "value": risk_pct,
                        "threshold": 2.0
                    })
                    return False

                return True
        def emit_module_telemetry(self, event: str, data: dict = None):
                """GENESIS Module Telemetry Hook"""
                telemetry_data = {
                    "timestamp": datetime.now().isoformat(),
                    "module": "dynamic_event_bus",
                    "event": event,
                    "data": data or {}
                }
                try:
                    emit_telemetry("dynamic_event_bus", event, telemetry_data)
                except Exception as e:
                    print(f"Telemetry error in dynamic_event_bus: {e}")
        def emit(self, event, data): pass
    TELEMETRY_AVAILABLE = False



# ðŸ”— GENESIS EventBus Integration - Auto-injected by Complete Intelligent Wiring Engine
try:
    from core.hardened_event_bus import get_event_bus, emit_event, register_route
    EVENTBUS_AVAILABLE = True
except ImportError:
    # Fallback implementation
    def get_event_bus(): return None
    def emit_event(event, data): print(f"EVENT: {event} - {data}")
    def register_route(route, producer, consumer): pass
    EVENTBUS_AVAILABLE = False


# -*- coding: utf-8 -*-
# <!-- @GENESIS_MODULE_START: core_dynamic_event_bus -->

"""
ðŸ”— GENESIS DYNAMIC EVENT BUS v7.0.0
DISCOVERY-BASED EVENT ROUTING & MODULE SYNC

ðŸš¨ ARCHITECT MODE v7.0.0 - DISCOVERY PATTERNS:
- NO HARDENED ROUTING: Dynamic event discovery
- REAL-TIME MODULE SYNC: Auto-discovery of event handlers
- DYNAMIC WIRE-UP: Self-organizing event network
- LIVE TOPOLOGY: Real-time event flow mapping
"""

import asyncio
import threading
import time
import logging
from typing import Dict, Any, List, Callable, Optional, Set
from datetime import datetime
from dataclasses import dataclass, field
import json
from collections import defaultdict, deque
import weakref
import inspect

# Configure logging
logger = logging.getLogger(__name__)

@dataclass
class EventRoute:
    def emergency_stop(self, reason: str = "Manual trigger") -> bool:
            """GENESIS Emergency Kill Switch"""
            try:
                # Emit emergency event
                if hasattr(self, 'event_bus') and self.event_bus:
                    emit_event("emergency_stop", {
                        "module": "dynamic_event_bus",
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                # Log telemetry
                self.emit_module_telemetry("emergency_stop", {
                    "reason": reason,
                    "timestamp": datetime.now().isoformat()
                })

                # Set emergency state
                if hasattr(self, '_emergency_stop_active'):
                    self._emergency_stop_active = True

                return True
            except Exception as e:
                print(f"Emergency stop error in dynamic_event_bus: {e}")
                return False
    def validate_ftmo_compliance(self, trade_data: dict) -> bool:
            """GENESIS FTMO Compliance Validator"""
            # Daily drawdown check (5%)
            daily_loss = trade_data.get('daily_loss_pct', 0)
            if daily_loss > 5.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "daily_drawdown", 
                    "value": daily_loss,
                    "threshold": 5.0
                })
                return False

            # Maximum drawdown check (10%)
            max_drawdown = trade_data.get('max_drawdown_pct', 0)
            if max_drawdown > 10.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "max_drawdown", 
                    "value": max_drawdown,
                    "threshold": 10.0
                })
                return False

            # Risk per trade check (2%)
            risk_pct = trade_data.get('risk_percent', 0)
            if risk_pct > 2.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "risk_exceeded", 
                    "value": risk_pct,
                    "threshold": 2.0
                })
                return False

            return True
    def emit_module_telemetry(self, event: str, data: dict = None):
            """GENESIS Module Telemetry Hook"""
            telemetry_data = {
                "timestamp": datetime.now().isoformat(),
                "module": "dynamic_event_bus",
                "event": event,
                "data": data or {}
            }
            try:
                emit_telemetry("dynamic_event_bus", event, telemetry_data)
            except Exception as e:
                print(f"Telemetry error in dynamic_event_bus: {e}")
    def initialize_eventbus(self):
            """GENESIS EventBus Initialization"""
            try:
                self.event_bus = get_event_bus()
                if self.event_bus:
                    emit_event("module_initialized", {
                        "module": "dynamic_event_bus",
                        "timestamp": datetime.now().isoformat(),
                        "status": "active"
                    })
            except Exception as e:
                print(f"EventBus initialization error in dynamic_event_bus: {e}")
    """Event routing information"""
    event_type: str
    source_module: str
    target_modules: List[str] = field(default_factory=list)
    handlers: List[Callable] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)
    last_triggered: Optional[datetime] = None
    trigger_count: int = 0
    active: bool = True

@dataclass
class EventMetrics:
    def emergency_stop(self, reason: str = "Manual trigger") -> bool:
            """GENESIS Emergency Kill Switch"""
            try:
                # Emit emergency event
                if hasattr(self, 'event_bus') and self.event_bus:
                    emit_event("emergency_stop", {
                        "module": "dynamic_event_bus",
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                # Log telemetry
                self.emit_module_telemetry("emergency_stop", {
                    "reason": reason,
                    "timestamp": datetime.now().isoformat()
                })

                # Set emergency state
                if hasattr(self, '_emergency_stop_active'):
                    self._emergency_stop_active = True

                return True
            except Exception as e:
                print(f"Emergency stop error in dynamic_event_bus: {e}")
                return False
    def validate_ftmo_compliance(self, trade_data: dict) -> bool:
            """GENESIS FTMO Compliance Validator"""
            # Daily drawdown check (5%)
            daily_loss = trade_data.get('daily_loss_pct', 0)
            if daily_loss > 5.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "daily_drawdown", 
                    "value": daily_loss,
                    "threshold": 5.0
                })
                return False

            # Maximum drawdown check (10%)
            max_drawdown = trade_data.get('max_drawdown_pct', 0)
            if max_drawdown > 10.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "max_drawdown", 
                    "value": max_drawdown,
                    "threshold": 10.0
                })
                return False

            # Risk per trade check (2%)
            risk_pct = trade_data.get('risk_percent', 0)
            if risk_pct > 2.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "risk_exceeded", 
                    "value": risk_pct,
                    "threshold": 2.0
                })
                return False

            return True
    def emit_module_telemetry(self, event: str, data: dict = None):
            """GENESIS Module Telemetry Hook"""
            telemetry_data = {
                "timestamp": datetime.now().isoformat(),
                "module": "dynamic_event_bus",
                "event": event,
                "data": data or {}
            }
            try:
                emit_telemetry("dynamic_event_bus", event, telemetry_data)
            except Exception as e:
                print(f"Telemetry error in dynamic_event_bus: {e}")
    def initialize_eventbus(self):
            """GENESIS EventBus Initialization"""
            try:
                self.event_bus = get_event_bus()
                if self.event_bus:
                    emit_event("module_initialized", {
                        "module": "dynamic_event_bus",
                        "timestamp": datetime.now().isoformat(),
                        "status": "active"
                    })
            except Exception as e:
                print(f"EventBus initialization error in dynamic_event_bus: {e}")
    """Event processing metrics"""
    total_events: int = 0
    events_per_minute: float = 0.0
    active_routes: int = 0
    unique_event_types: int = 0
    processing_errors: int = 0
    last_update: datetime = field(default_factory=datetime.now)

class DynamicEventBus:
    def emergency_stop(self, reason: str = "Manual trigger") -> bool:
            """GENESIS Emergency Kill Switch"""
            try:
                # Emit emergency event
                if hasattr(self, 'event_bus') and self.event_bus:
                    emit_event("emergency_stop", {
                        "module": "dynamic_event_bus",
                        "reason": reason,
                        "timestamp": datetime.now().isoformat()
                    })

                # Log telemetry
                self.emit_module_telemetry("emergency_stop", {
                    "reason": reason,
                    "timestamp": datetime.now().isoformat()
                })

                # Set emergency state
                if hasattr(self, '_emergency_stop_active'):
                    self._emergency_stop_active = True

                return True
            except Exception as e:
                print(f"Emergency stop error in dynamic_event_bus: {e}")
                return False
    def validate_ftmo_compliance(self, trade_data: dict) -> bool:
            """GENESIS FTMO Compliance Validator"""
            # Daily drawdown check (5%)
            daily_loss = trade_data.get('daily_loss_pct', 0)
            if daily_loss > 5.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "daily_drawdown", 
                    "value": daily_loss,
                    "threshold": 5.0
                })
                return False

            # Maximum drawdown check (10%)
            max_drawdown = trade_data.get('max_drawdown_pct', 0)
            if max_drawdown > 10.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "max_drawdown", 
                    "value": max_drawdown,
                    "threshold": 10.0
                })
                return False

            # Risk per trade check (2%)
            risk_pct = trade_data.get('risk_percent', 0)
            if risk_pct > 2.0:
                self.emit_module_telemetry("ftmo_violation", {
                    "type": "risk_exceeded", 
                    "value": risk_pct,
                    "threshold": 2.0
                })
                return False

            return True
    def emit_module_telemetry(self, event: str, data: dict = None):
            """GENESIS Module Telemetry Hook"""
            telemetry_data = {
                "timestamp": datetime.now().isoformat(),
                "module": "dynamic_event_bus",
                "event": event,
                "data": data or {}
            }
            try:
                emit_telemetry("dynamic_event_bus", event, telemetry_data)
            except Exception as e:
                print(f"Telemetry error in dynamic_event_bus: {e}")
    def initialize_eventbus(self):
            """GENESIS EventBus Initialization"""
            try:
                self.event_bus = get_event_bus()
                if self.event_bus:
                    emit_event("module_initialized", {
                        "module": "dynamic_event_bus",
                        "timestamp": datetime.now().isoformat(),
                        "status": "active"
                    })
            except Exception as e:
                print(f"EventBus initialization error in dynamic_event_bus: {e}")
    """
    ðŸ”— DYNAMIC EVENT BUS
    
    Self-discovering event routing system that automatically finds
    and wires event handlers across modules without hardcoded routing.
    
    Features:
    - Auto-discovery of event emitters and listeners
    - Dynamic routing table construction
    - Real-time event flow monitoring
    - Module synchronization patterns
    - Event replay and debugging
    """
    
    def __init__(self):
        self.routes: Dict[str, EventRoute] = {}
        self.handlers: Dict[str, List[Callable]] = defaultdict(list)
        self.event_history: deque = deque(maxlen=1000)
        self.metrics = EventMetrics()
        self.discovery_active = True
        self.sync_threads: List[threading.Thread] = []
        
        # Discovery patterns
        self.handler_registry: Dict[str, Set[str]] = defaultdict(set)
        self.module_capabilities: Dict[str, Dict[str, Any]] = {}
        
        # Event processing
        self.event_queue = asyncio.Queue()
        self.processing_tasks: List[asyncio.Task] = []
        
        logger.info("ðŸ”— Dynamic Event Bus initialized")
    
    async def start_event_bus(self):
        """Start the dynamic event bus"""
        logger.info("ðŸ”— Starting Dynamic Event Bus...")
        
        # Start event processor
        processor_task = asyncio.create_task(self._event_processor())
        self.processing_tasks.append(processor_task)
        
        # Start discovery thread
        discovery_thread = threading.Thread(
            target=self._discovery_loop,
            daemon=True
        )
        discovery_thread.start()
        self.sync_threads.append(discovery_thread)
        
        # Start metrics updater
        metrics_thread = threading.Thread(
            target=self._metrics_loop,
            daemon=True
        )
        metrics_thread.start()
        self.sync_threads.append(metrics_thread)
        
        logger.info("ðŸ”— Dynamic Event Bus started successfully")
    
    def emit_event(self, event_type: str, data: Any, source_module: str = "unknown") -> bool:
        """
        Emit an event through the dynamic routing system
        
        Args:
            event_type: Type of event to emit
            data: Event payload
            source_module: Module emitting the event
            
        Returns:
            bool: True if event was successfully queued
        """
        try:
            event_data = {
                'type': event_type,
                'data': data,
                'source': source_module,
                'timestamp': datetime.now().isoformat(),
                'id': f"{event_type}_{int(time.time() * 1000)}"
            }
            
            # Queue event for async processing
            asyncio.create_task(self.event_queue.put(event_data))
            
            # Update metrics
            self.metrics.total_events += 1
            
            # Add to history
            self.event_history.append(event_data)
            
            logger.debug(f"ðŸ”— Event emitted: {event_type} from {source_module}")
            return True
            
        except Exception as e:
            logger.error(f"Event emission failed: {e}")
            self.metrics.processing_errors += 1
            return False
    
    async def _event_processor(self):
        """Process events from the queue"""
        while self.discovery_active:
            try:
                # Get event from queue
                event_data = await asyncio.wait_for(
                    self.event_queue.get(), timeout=1.0
                )
                
                # Process the event
                await self._process_event(event_data)
                
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logger.error(f"Event processing error: {e}")
                self.metrics.processing_errors += 1
    
    async def _process_event(self, event_data: Dict[str, Any]):
        """Process a single event"""
        event_type = event_data['type']
        
        # Update route metrics
        if event_type in self.routes:
            route = self.routes[event_type]
            route.last_triggered = datetime.now()
            route.trigger_count += 1
        
        # Find and execute handlers
        handlers = self.handlers.get(event_type, [])
        
        if handlers:
            logger.debug(f"ðŸ”— Processing {event_type} with {len(handlers)} handlers")
            
            # Execute handlers concurrently
            handler_tasks = []
            for handler in handlers:
                if callable(handler):
                    task = asyncio.create_task(self._execute_handler(handler, event_data))
                    handler_tasks.append(task)
            
            # Wait for all handlers to complete
            if handler_tasks:
                await asyncio.gather(*handler_tasks, return_exceptions=True)
        else:
            logger.debug(f"ðŸ”— No handlers found for event: {event_type}")
    
    async def _execute_handler(self, handler: Callable, event_data: Dict[str, Any]):
        """Execute an event handler"""
        try:
            # Check if handler is async
            if inspect.iscoroutinefunction(handler):
                await handler(event_data)
            else:
                # Run sync handler in thread pool
                loop = asyncio.get_event_loop()
                await loop.run_in_executor(None, handler, event_data)
                
        except Exception as e:
            logger.error(f"Handler execution failed: {e}")
            self.metrics.processing_errors += 1
    
    def subscribe_to_event(self, event_type: str, handler: Callable, module_name: str = "unknown") -> str:
        """
        Subscribe to an event type with dynamic discovery
        
        Args:
            event_type: Type of event to listen for
            handler: Function to call when event occurs
            module_name: Name of the subscribing module
            
        Returns:
            str: Subscription ID
        """
        try:
            # Add handler to registry
            self.handlers[event_type].append(handler)
            
            # Create or update route
            if event_type not in self.routes:
                self.routes[event_type] = EventRoute(
                    event_type=event_type,
                    source_module="dynamic"
                )
            
            route = self.routes[event_type]
            if module_name not in route.target_modules:
                route.target_modules.append(module_name)
            route.handlers.append(handler)
            
            # Update handler registry
            self.handler_registry[event_type].add(module_name)
            
            subscription_id = f"{event_type}_{module_name}_{len(self.handlers[event_type])}"
            
            logger.info(f"ðŸ”— Subscription added: {module_name} -> {event_type}")
            return subscription_id
            
        except Exception as e:
            logger.error(f"Subscription failed: {e}")
            return ""
    
    def discover_module_events(self, module_name: str, module_obj: Any):
        """
        Discover events that a module can emit or handle
        
        Args:
            module_name: Name of the module
            module_obj: Module object to inspect
        """
        try:
            capabilities = {
                'emitters': [],
                'listeners': [],
                'methods': []
            }
            
            # Inspect module for event-related methods
            for attr_name in dir(module_obj):
                if not attr_name.startswith('_'):
                    attr = getattr(module_obj, attr_name)
                    
                    if callable(attr):
                        capabilities['methods'].append(attr_name)
                        
                        # Check for event emission patterns
                        if any(pattern in attr_name.lower() for pattern in ['emit', 'send', 'trigger', 'publish']):
                            capabilities['emitters'].append(attr_name)
                        
                        # Check for event handling patterns
                        if any(pattern in attr_name.lower() for pattern in ['handle', 'on_', 'process', 'receive']):
                            capabilities['listeners'].append(attr_name)
                            
                            # Auto-register as event handler
                            event_type = self._extract_event_type_from_method_name(attr_name)
                            if event_type:
                                self.subscribe_to_event(event_type, attr, module_name)
            
            self.module_capabilities[module_name] = capabilities
            
            logger.info(f"ðŸ”— Module discovery: {module_name} - {len(capabilities['emitters'])} emitters, {len(capabilities['listeners'])} listeners")
            
        except Exception as e:
            logger.error(f"Module discovery failed for {module_name}: {e}")
    
    def _extract_event_type_from_method_name(self, method_name: str) -> Optional[str]:
        """Extract event type from method name"""
        # Common patterns for event handler method names
        patterns = [
            ('handle_', ''),
            ('on_', ''),
            ('process_', ''),
            ('receive_', '')
        ]
        
        method_lower = method_name.lower()
        
        for prefix, replacement in patterns:
            if method_lower.startswith(prefix):
                event_type = method_lower.replace(prefix, replacement, 1)
                # Convert snake_case to dot notation
                return event_type.replace('_', '.')
        
        return None
    
    def auto_wire_modules(self, modules: Dict[str, Any]):
        """
        Automatically wire multiple modules together
        
        Args:
            modules: Dictionary of module_name -> module_object
        """
        logger.info(f"ðŸ”— Auto-wiring {len(modules)} modules...")
        
        # Discover all modules
        for module_name, module_obj in modules.items():
            self.discover_module_events(module_name, module_obj)
        
        # Create cross-module event routes
        self._create_cross_module_routes()
        
        logger.info("ðŸ”— Auto-wiring complete")
    
    def _create_cross_module_routes(self):
        """Create routes between modules based on discovered capabilities"""
        for module_name, capabilities in self.module_capabilities.items():
            
            # Connect emitters to listeners across modules
            for emitter in capabilities['emitters']:
                event_type = self._method_name_to_event_type(emitter)
                
                # Find modules that can handle this event
                for other_module, other_caps in self.module_capabilities.items():
                    if other_module != module_name:
                        matching_listeners = [
                            listener for listener in other_caps['listeners']
                            if self._events_match(event_type, listener)
                        ]
                        
                        if matching_listeners:
                            logger.debug(f"ðŸ”— Route created: {module_name}.{emitter} -> {other_module}.{matching_listeners[0]}")
    
    def _method_name_to_event_type(self, method_name: str) -> str:
        """Convert method name to event type"""
        # Remove common prefixes and convert to event type
        cleaned = method_name.lower()
        for prefix in ['emit_', 'send_', 'trigger_', 'publish_']:
            if cleaned.startswith(prefix):
                cleaned = cleaned[len(prefix):]
                break
        
        return cleaned.replace('_', '.')
    
    def _events_match(self, event_type: str, listener_method: str) -> bool:
        """Check if an event type matches a listener method"""
        listener_event = self._extract_event_type_from_method_name(listener_method)
        return listener_event and event_type == listener_event
    
    def _discovery_loop(self):
        """Continuous discovery loop"""
        while self.discovery_active:
            try:
                time.sleep(30)  # Discovery interval
                
                # Update route status
                self._update_route_health()
                
                # Clean up dead handlers
                self._cleanup_dead_handlers()
                
            except Exception as e:
                logger.error(f"Discovery loop error: {e}")
    
    def _update_route_health(self):
        """Update health status of routes"""
        current_time = datetime.now()
        
        for route in self.routes.values():
            # Check if route has been used recently
            if route.last_triggered:
                time_since_last = (current_time - route.last_triggered).total_seconds()
                route.active = time_since_last < 300  # 5 minutes
            else:
                route.active = False
    
    def _cleanup_dead_handlers(self):
        """Clean up dead weak references and inactive handlers"""
        for event_type, handlers in list(self.handlers.items()):
            # Remove None handlers (dead weak references)
            active_handlers = [h for h in handlers if h is not None]
            
            if len(active_handlers) != len(handlers):
                self.handlers[event_type] = active_handlers
                logger.debug(f"ðŸ”— Cleaned up dead handlers for {event_type}")
            
            # Remove empty event types
            if not active_handlers:
                del self.handlers[event_type]
                if event_type in self.routes:
                    del self.routes[event_type]
    
    def _metrics_loop(self):
        """Update metrics periodically"""
        last_event_count = 0
        
        while self.discovery_active:
            try:
                time.sleep(60)  # Update every minute
                
                # Calculate events per minute
                events_this_period = self.metrics.total_events - last_event_count
                self.metrics.events_per_minute = events_this_period
                last_event_count = self.metrics.total_events
                
                # Update other metrics
                self.metrics.active_routes = len([r for r in self.routes.values() if r.active])
                self.metrics.unique_event_types = len(self.handlers)
                self.metrics.last_update = datetime.now()
                
                logger.debug(f"ðŸ”— Metrics: {self.metrics.events_per_minute} events/min, {self.metrics.active_routes} active routes")
                
            except Exception as e:
                logger.error(f"Metrics update error: {e}")
    
    def get_event_topology(self) -> Dict[str, Any]:
        """Get current event topology"""
        return {
            'routes': {
                event_type: {
                    'source': route.source_module,
                    'targets': route.target_modules,
                    'handler_count': len(route.handlers),
                    'trigger_count': route.trigger_count,
                    'active': route.active,
                    'last_triggered': route.last_triggered.isoformat() if route.last_triggered else None
                }
                for event_type, route in self.routes.items()
            },
            'metrics': {
                'total_events': self.metrics.total_events,
                'events_per_minute': self.metrics.events_per_minute,
                'active_routes': self.metrics.active_routes,
                'unique_event_types': self.metrics.unique_event_types,
                'processing_errors': self.metrics.processing_errors
            },
            'modules': {
                module_name: {
                    'emitters': caps['emitters'],
                    'listeners': caps['listeners'],
                    'method_count': len(caps['methods'])
                }
                for module_name, caps in self.module_capabilities.items()
            }
        }
    
    def get_recent_events(self, limit: int = 50) -> List[Dict[str, Any]]:
        """Get recent events from history"""
        return list(self.event_history)[-limit:]
    
    def stop_event_bus(self):
        """Stop the event bus"""
        self.discovery_active = False
        
        # Cancel async tasks
        for task in self.processing_tasks:
            if not task.done():
                task.cancel()
        
        logger.info("ðŸ”— Dynamic Event Bus stopped")

# Global event bus instance
event_bus = DynamicEventBus()

# Convenience functions for backward compatibility
def emit_event(event_type: str, data: Any, source_module: str = "unknown") -> bool:
    """Emit an event"""
    return event_bus.emit_event(event_type, data, source_module)

def subscribe_to_event(event_type: str, handler: Callable, module_name: str = "unknown") -> str:
    """Subscribe to an event"""
    return event_bus.subscribe_to_event(event_type, handler, module_name)

def discover_module_events(module_name: str, module_obj: Any):
    """Discover module events"""
    return event_bus.discover_module_events(module_name, module_obj)

def auto_wire_modules(modules: Dict[str, Any]):
    """Auto-wire modules"""
    return event_bus.auto_wire_modules(modules)

def get_event_topology():
    """Get event topology"""
    return event_bus.get_event_topology()

async def start_event_bus():
    """Start the event bus"""
    await event_bus.start_event_bus()

# <!-- @GENESIS_MODULE_END: core_dynamic_event_bus -->
