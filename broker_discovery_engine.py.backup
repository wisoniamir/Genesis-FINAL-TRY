"""
GENESIS Broker Discovery Engine v1.0 - PHASE 35 Enhancement
Real-time broker account type detection and rule configuration
ARCHITECT MODE v2.8 - STRICT COMPLIANCE

PHASE 35 OBJECTIVE:
Dynamically detect connected MT5 account type and load appropriate trading rules
- FTMO Challenge: Strict daily/total drawdown, no weekend trading, no news trading
- FTMO Swing: Can hold overnight/weekend, can trade news, 1:30 leverage
- FTMO Funded: Production rules with higher limits
- Regular Broker: Minimal restrictions

INPUTS CONSUMED:
- ConnectionStatus: MT5 connection established events
- AccountInfoUpdate: MT5 account information updates

OUTPUTS EMITTED:
- BrokerRulesDiscovered: Trading rules for connected account type
- TradingRulesUpdate: Rule changes for existing connections
- AccountTypeDetected: Account classification results

VALIDATION REQUIREMENTS:
‚úÖ Real MT5 account info only (no mock/simulation)
‚úÖ EventBus communication only
‚úÖ Dynamic rule loading based on account type
‚úÖ Rule broadcasting to all relevant modules
‚úÖ Telemetry integration
"""

import os
import json
import logging
from datetime import datetime, time
from typing import Dict, Any, List, Optional
from threading import Lock

try:
    import MetaTrader5 as mt5
    MT5_AVAILABLE = True
except ImportError:
    mt5 = None
    MT5_AVAILABLE = False

from event_bus import emit_event, subscribe_to_event, register_route

class BrokerDiscoveryEngine:
    """
    GENESIS BrokerDiscoveryEngine v1.0 - Account Type Detection & Rule Loading
    
    Architecture Compliance:
    - ‚úÖ EventBus only communication
    - ‚úÖ Real MT5 account detection (no mock/dummy data)
    - ‚úÖ Telemetry hooks enabled
    - ‚úÖ No isolated functions
    - ‚úÖ Registered in all system files
    """
    
    def __init__(self):
        """Initialize BrokerDiscoveryEngine with account detection logic"""
        
        # Module identification
        self.module_name = "BrokerDiscoveryEngine"
        self.version = "1.0"
        
        # Account detection state
        self.detected_account_type = None
        self.current_rules = None
        self.broker_info = {}
        self.account_verified = False
        
        # Thread safety
        self.lock = Lock()
        
        # Telemetry tracking
        self.telemetry = {
            "detections_performed": 0,
            "rule_updates_sent": 0,
            "account_verifications": 0,
            "module_errors": 0,
            "module_start_time": datetime.utcnow().isoformat(),
            "last_detection_time": None,
            "account_type_history": []
        }
        
        # Configure logging
        self.logger = logging.getLogger(self.module_name)
        log_dir = "logs/broker_discovery"
        os.makedirs(log_dir, exist_ok=True)
        
        file_handler = logging.FileHandler(
            f"{log_dir}/broker_discovery_{datetime.now().strftime('%Y%m%d_%H%M%S')}.jsonl"
        )
        file_handler.setFormatter(logging.Formatter('%(message)s'))
        self.logger.addHandler(file_handler)
        self.logger.setLevel(logging.INFO)
        
        # Account type detection rules
        self.account_type_patterns = {
            "FTMO Challenge": {
                "broker_patterns": ["FTMO", "ftmo"],
                "server_patterns": ["Challenge", "Demo"],
                "balance_ranges": [(100000, 200000)],  # $100k-$200k challenge accounts
                "leverage_limits": [100, 200],  # 1:100, 1:200 leverage
                "trading_rules": {
                    "max_daily_drawdown": 5.0,
                    "max_total_drawdown": 10.0,
                    "weekend_trading_allowed": False,
                    "news_trading_allowed": False,
                    "max_leverage": 100,
                    "max_lot_size": 5.0,
                    "trading_hours": {"start": 8, "end": 22},  # UTC hours
                    "spread_threshold_pips": 2.0
                }
            },
            "FTMO Swing": {
                "broker_patterns": ["FTMO", "ftmo"],
                "server_patterns": ["Swing", "Live", "Real"],
                "balance_ranges": [(200000, 400000)],  # $200k-$400k swing accounts
                "leverage_limits": [30],  # 1:30 leverage
                "trading_rules": {
                    "max_daily_drawdown": 5.0,
                    "max_total_drawdown": 10.0,
                    "weekend_trading_allowed": True,
                    "news_trading_allowed": True,
                    "max_leverage": 30,
                    "max_lot_size": 10.0,
                    "trading_hours": None,  # No time restrictions
                    "spread_threshold_pips": 1.5
                }
            },
            "FTMO Funded": {
                "broker_patterns": ["FTMO", "ftmo"],
                "server_patterns": ["Live", "Real", "Funded"],
                "balance_ranges": [(200000, 2000000)],  # $200k-$2M funded accounts
                "leverage_limits": [30, 100],
                "trading_rules": {
                    "max_daily_drawdown": 5.0,
                    "max_total_drawdown": 10.0,
                    "weekend_trading_allowed": True,
                    "news_trading_allowed": True,
                    "max_leverage": 100,
                    "max_lot_size": 20.0,
                    "trading_hours": None,
                    "spread_threshold_pips": 1.5
                }
            },
            "Regular Broker": {
                "broker_patterns": ["IC Markets", "Pepperstone", "XM", "IG", "Admiral"],
                "server_patterns": ["Live", "Real", "Demo"],
                "balance_ranges": [(1000, 10000000)],  # Wide range for regular brokers
                "leverage_limits": [30, 50, 100, 200, 400, 500],
                "trading_rules": {
                    "max_daily_drawdown": 20.0,  # More relaxed
                    "max_total_drawdown": 50.0,
                    "weekend_trading_allowed": True,
                    "news_trading_allowed": True,
                    "max_leverage": 500,
                    "max_lot_size": 100.0,
                    "trading_hours": None,
                    "spread_threshold_pips": 3.0
                }
            }
        }
          # Load rule override configuration
        self.override_config = self._load_override_config()
        
        # Subscribe to MT5 connection events
        subscribe_to_event("ConnectionStatus", self.on_connection_status, self.module_name)
        subscribe_to_event("AccountInfoUpdate", self.on_account_info_update, self.module_name)
        
        # Register EventBus routes
        self._register_event_routes()
        
        # Emit module initialization
        self._emit_telemetry("MODULE_INITIALIZED", {
            "account_type_patterns": len(self.account_type_patterns),
            "mt5_available": MT5_AVAILABLE,
            "override_mode_enabled": self.override_config.get("rule_override_mode", {}).get("enabled", False)
        })
        
        self.logger.info(f"‚úÖ {self.module_name} v{self.version} initialized - Broker detection ready")
        
        # Log override mode status
        if self.override_config.get("rule_override_mode", {}).get("enabled", False):
            override_type = self.override_config["rule_override_mode"]["override_account_type"]
            self.logger.info(f"üîí Rule Override Mode ENABLED - Forcing {override_type} rules for all accounts")
    
    def on_connection_status(self, event):
        """
        Handle MT5 connection status events and trigger account detection
        
        Args:
            event (dict): ConnectionStatus event from MarketDataFeedManager
        """
        try:
            connection_data = event.get("data", event)
            status = connection_data.get("status")
            
            if status == "connected":
                self.logger.info("üîç MT5 connection detected - Starting account type discovery")
                self._detect_account_type()
            elif status == "disconnected":
                self.logger.info("üîå MT5 disconnected - Clearing account detection state")
                self._clear_detection_state()
                
        except Exception as e:
            self.logger.error(f"‚ùå Error handling connection status: {e}")
            self._emit_error("CONNECTION_STATUS_ERROR", str(e))
    
    def on_account_info_update(self, event):
        """
        Handle account info updates and re-verify account type if needed
        
        Args:
            event (dict): AccountInfoUpdate event
        """
        try:
            account_data = event.get("data", event)
            
            # Store updated account info
            with self.lock:
                self.broker_info.update(account_data)
            
            # Re-detect if significant changes            if self._should_redetect_account_type(account_data):
                self.logger.info("üìä Account info changed significantly - Re-detecting account type")
                self._detect_account_type()
                
        except Exception as e:
            self.logger.error(f"‚ùå Error handling account info update: {e}")
            self._emit_error("ACCOUNT_UPDATE_ERROR", str(e))
    
    def _load_override_config(self) -> Dict[str, Any]:
        """
        Load broker rule override configuration from config file
        
        Returns:
            dict: Override configuration settings
        """
        config_file = "broker_rule_override_config.json"
        default_config = {
            "rule_override_mode": {"enabled": False},
            "detection_mode": {"enabled": True, "strict_real_data_only": True},
            "forced_trading_rules": {"account_type": "FTMO Swing", "trading_rules": {}},
            "rule_customization": {"enabled": False, "modifications": {}}
        }
          try:
            if os.path.exists(config_file):
                with open(config_file, 'r') as f:
                    config = json.load(f)
                self.logger.info(f"BROKER_CONFIG: Loaded override config from {config_file}")
                return config
            else:
                self.logger.info(f"BROKER_CONFIG: No override config found, using dynamic detection mode")
                return default_config
                
        except Exception as e:
            self.logger.error(f"ERROR: Error loading override config: {e}")
            return default_config

    def _detect_account_type(self):
        """
        Detect account type based on MT5 connection and emit appropriate rules
        Now supports rule override mode for forcing specific rules
        """
        if not MT5_AVAILABLE:
            self.logger.warning("‚ö†Ô∏è MT5 not available - Cannot detect account type")
            return
        
        try:
            # Check if rule override mode is enabled
            override_enabled = self.override_config.get("rule_override_mode", {}).get("enabled", False)
            
            if override_enabled:
                # Force specific account type and rules
                forced_type = self.override_config["rule_override_mode"]["override_account_type"]
                forced_rules = self.override_config.get("forced_trading_rules", {}).get("trading_rules", {})
                
                # If no forced rules in config, use the pattern rules
                if not forced_rules:
                    forced_rules = self.account_type_patterns.get(forced_type, {}).get("trading_rules", {})
                
                self.logger.info(f"üîí Rule Override Mode: Forcing {forced_type} rules")
                
                # Apply rule customizations if enabled
                final_rules = self._apply_rule_customizations(forced_rules.copy())
                
                with self.lock:
                    self.detected_account_type = forced_type
                    self.current_rules = final_rules
                    self.account_verified = True
                    self.telemetry["detections_performed"] += 1
                    self.telemetry["last_detection_time"] = datetime.utcnow().isoformat()
                    self.telemetry["account_type_history"].append({
                        "type": f"{forced_type} (FORCED)",
                        "timestamp": datetime.utcnow().isoformat(),
                        "broker": "Override Mode",
                        "server": "Override Mode",
                        "balance": 0,
                        "override_enabled": True
                    })
                
                # Get actual account info for telemetry
                account_info = self._get_mt5_account_info() or {"broker": "Unknown", "server": "Unknown", "balance": 0}
                
                # Emit forced rules
                self._emit_trading_rules(forced_type, final_rules, override_mode=True)
                
                # Emit telemetry
                self._emit_telemetry("ACCOUNT_TYPE_FORCED", {
                    "forced_type": forced_type,
                    "actual_broker": account_info.get("broker"),
                    "actual_server": account_info.get("server"),
                    "override_reason": self.override_config["rule_override_mode"].get("reason", "Manual override")
                })
                
                return
            
            # Normal dynamic detection mode
            account_info = self._get_mt5_account_info()
            if not account_info:
                self.logger.error("‚ùå Failed to get MT5 account info")
                return
            
            with self.lock:
                self.broker_info = account_info
                self.telemetry["detections_performed"] += 1
                self.telemetry["last_detection_time"] = datetime.utcnow().isoformat()
            
            # Detect account type
            detected_type = self._classify_account_type(account_info)
            
            if detected_type != self.detected_account_type:
                self.logger.info(f"üéØ Account type detected: {detected_type}")
                
                # Get base rules for detected type
                base_rules = self.account_type_patterns[detected_type]["trading_rules"].copy()
                
                # Apply rule customizations if enabled
                final_rules = self._apply_rule_customizations(base_rules)
                
                with self.lock:
                    self.detected_account_type = detected_type
                    self.current_rules = final_rules
                    self.account_verified = True
                    self.telemetry["account_type_history"].append({
                        "type": detected_type,
                        "timestamp": datetime.utcnow().isoformat(),
                        "broker": account_info.get("broker", "Unknown"),
                        "server": account_info.get("server", "Unknown"),
                        "balance": account_info.get("balance", 0),
                        "override_enabled": False
                    })
                
                # Emit account type detection
                emit_event("AccountTypeDetected", {
                    "account_type": detected_type,
                    "broker_info": account_info,
                    "detection_timestamp": datetime.utcnow().isoformat(),
                    "confidence": self._calculate_detection_confidence(account_info, detected_type)
                }, self.module_name)
                
                # Emit trading rules for the detected account type
                self._emit_trading_rules(detected_type, final_rules, override_mode=False)
                
                # Emit telemetry
                self._emit_telemetry("ACCOUNT_TYPE_DETECTED", {
                    "account_type": detected_type,
                    "broker": account_info.get("broker"),
                    "server": account_info.get("server"),
                    "balance": account_info.get("balance")
                })
            
        except Exception as e:
            self.logger.error(f"‚ùå Error in account type detection: {e}")
            self._emit_error("DETECTION_ERROR", str(e))

    def _apply_rule_customizations(self, base_rules: Dict[str, Any]) -> Dict[str, Any]:
        """
        Apply rule customizations from configuration
        
        Args:
            base_rules (dict): Base trading rules
            
        Returns:
            dict: Customized trading rules
        """
        if not self.override_config.get("rule_customization", {}).get("enabled", False):
            return base_rules
        
        customizations = self.override_config["rule_customization"]["modifications"]
        final_rules = base_rules.copy()
        
        for rule_name, custom_value in customizations.items():
            if custom_value is not None and rule_name in final_rules:
                original_value = final_rules[rule_name]
                final_rules[rule_name] = custom_value
                self.logger.info(f"üîß Rule customization: {rule_name} {original_value} ‚Üí {custom_value}")
        
        return final_rules
    
    def _get_mt5_account_info(self) -> Optional[Dict[str, Any]]:
        """
        Get account information from MT5
        
        Returns:
            dict: Account information or None if failed
        """
        if not MT5_AVAILABLE or not mt5:
            return None
        
        try:
            # Handle different MT5 library versions
            account_info_func = getattr(mt5, 'account_info', None)
            if account_info_func is None:
                self.logger.error("‚ùå MT5 account_info function not available")
                return None
                
            account_info = account_info_func()
            if account_info is None:
                return None
            
            return {
                "broker": account_info.company,
                "server": account_info.server,
                "balance": account_info.balance,
                "equity": account_info.equity,
                "margin": account_info.margin,
                "leverage": account_info.leverage,
                "currency": account_info.currency,
                "login": account_info.login,
                "trade_mode": account_info.trade_mode,
                "name": account_info.name if hasattr(account_info, 'name') else "N/A"
            }
            
        except Exception as e:
            self.logger.error(f"‚ùå Error getting MT5 account info: {e}")
            return None
    
    def _classify_account_type(self, account_info: Dict[str, Any]) -> str:
        """
        Classify account type based on broker info, server, balance, and leverage
        
        Args:
            account_info (dict): MT5 account information
            
        Returns:
            str: Detected account type
        """
        broker = account_info.get("broker", "").lower()
        server = account_info.get("server", "").lower()
        balance = account_info.get("balance", 0)
        leverage = account_info.get("leverage", 0)
        
        # Check each account type pattern
        for account_type, patterns in self.account_type_patterns.items():
            score = 0
            
            # Check broker patterns
            for broker_pattern in patterns["broker_patterns"]:
                if broker_pattern.lower() in broker:
                    score += 3  # High weight for broker match
                    break
            
            # Check server patterns
            for server_pattern in patterns["server_patterns"]:
                if server_pattern.lower() in server:
                    score += 2  # Medium weight for server match
                    break
            
            # Check balance ranges
            for balance_min, balance_max in patterns["balance_ranges"]:
                if balance_min <= balance <= balance_max:
                    score += 2  # Medium weight for balance match
                    break
            
            # Check leverage limits
            if leverage in patterns["leverage_limits"]:
                score += 1  # Low weight for leverage match
            
            # Store classification score for confidence calculation
            patterns["_classification_score"] = score
        
        # Find the account type with highest score
        best_match = max(
            self.account_type_patterns.items(),
            key=lambda x: x[1].get("_classification_score", 0)
        )
        
        # If no strong match, default to Regular Broker
        if best_match[1].get("_classification_score", 0) < 3:
            return "Regular Broker"
        
        return best_match[0]
    
    def _calculate_detection_confidence(self, account_info: Dict[str, Any], detected_type: str) -> float:
        """
        Calculate confidence level of account type detection
        
        Args:
            account_info (dict): MT5 account information
            detected_type (str): Detected account type
            
        Returns:
            float: Confidence score between 0.0 and 1.0
        """
        patterns = self.account_type_patterns[detected_type]
        max_score = 8  # 3 (broker) + 2 (server) + 2 (balance) + 1 (leverage)
        actual_score = patterns.get("_classification_score", 0)
        
        return min(actual_score / max_score, 1.0)
    
    def _emit_trading_rules(self, account_type: str, rules: Dict[str, Any], override_mode: bool = False):
        """
        Emit trading rules for the detected account type
        
        Args:
            account_type (str): Detected account type
            rules (dict): Trading rules for the account type
            override_mode (bool): If True, indicates this is from rule override mode
        """
        try:
            rules_event = {
                "account_type": account_type,
                "trading_rules": rules,
                "detection_timestamp": datetime.utcnow().isoformat(),
                "broker_info": self.broker_info.copy(),
                "rule_version": "1.0",
                "override_mode": override_mode
            }
            
            # Emit to ExecutionPrioritizationEngine and other rule consumers
            emit_event("BrokerRulesDiscovered", rules_event, self.module_name)
            emit_event("TradingRulesUpdate", rules_event, self.module_name)
            
            with self.lock:
                self.telemetry["rule_updates_sent"] += 1
            
            self.logger.info(f"üìã Trading rules emitted for {account_type}")
            
        except Exception as e:
            self.logger.error(f"‚ùå Error emitting trading rules: {e}")
            self._emit_error("RULE_EMISSION_ERROR", str(e))
    
    def _should_redetect_account_type(self, new_account_data: Dict[str, Any]) -> bool:
        """
        Determine if account type should be re-detected based on significant changes
        
        Args:
            new_account_data (dict): New account information
            
        Returns:
            bool: True if re-detection is needed
        """
        if not self.account_verified:
            return True
        
        # Check for significant changes
        significant_changes = [
            # Balance changed by more than 50%
            abs(new_account_data.get("balance", 0) - self.broker_info.get("balance", 0)) > self.broker_info.get("balance", 1) * 0.5,
            # Leverage changed
            new_account_data.get("leverage", 0) != self.broker_info.get("leverage", 0),
            # Server changed
            new_account_data.get("server", "") != self.broker_info.get("server", ""),
            # Broker changed
            new_account_data.get("broker", "") != self.broker_info.get("broker", "")
        ]
        
        return any(significant_changes)
    
    def _clear_detection_state(self):
        """Clear account detection state when MT5 disconnects"""
        with self.lock:
            self.detected_account_type = None
            self.current_rules = None
            self.broker_info = {}
            self.account_verified = False
        
        # Emit rules clearing event
        emit_event("TradingRulesUpdate", {
            "account_type": None,
            "trading_rules": None,
            "detection_timestamp": datetime.utcnow().isoformat(),
            "status": "disconnected"
        }, self.module_name)
    
    def _register_event_routes(self):
        """Register all event routes with the EventBus"""
        register_route("BrokerRulesDiscovered", self.module_name, "ExecutionPrioritizationEngine")
        register_route("BrokerRulesDiscovered", self.module_name, "RiskEngine")
        register_route("BrokerRulesDiscovered", self.module_name, "ExecutionEngine")
        register_route("TradingRulesUpdate", self.module_name, "ExecutionPrioritizationEngine")
        register_route("TradingRulesUpdate", self.module_name, "RiskEngine")
        register_route("AccountTypeDetected", self.module_name, "TelemetryCollector")
        register_route("AccountTypeDetected", self.module_name, "DashboardEngine")
    
    def _emit_telemetry(self, event_type: str, data: Optional[Dict[str, Any]] = None):
        """Emit telemetry data to TelemetryCollector"""
        try:
            telemetry_data = {
                "timestamp": datetime.utcnow().isoformat(),
                "module": self.module_name,
                "event_type": event_type,
                "data": data or {},
                "telemetry_metrics": self.telemetry.copy()
            }
            
            emit_event("ModuleTelemetry", telemetry_data, self.module_name)
            
            # Log to file
            self.logger.info(json.dumps({
                "event": "telemetry",
                "type": event_type,
                "data": telemetry_data
            }))
            
        except Exception as e:
            self.logger.error(f"‚ùå Error emitting telemetry: {e}")
    
    def _emit_error(self, error_type: str, error_message: str):
        """Emit error event and update telemetry"""
        try:
            with self.lock:
                self.telemetry["module_errors"] += 1
            
            error_data = {
                "timestamp": datetime.utcnow().isoformat(),
                "module": self.module_name,
                "error_type": error_type,
                "error_message": error_message,
                "detected_account_type": self.detected_account_type
            }
            
            emit_event("ModuleError", error_data, self.module_name)
            
            # Log to file
            self.logger.error(json.dumps({
                "event": "error",
                "type": error_type,
                "message": error_message
            }))
            
        except Exception as e:
            self.logger.error(f"‚ùå Error emitting error event: {e}")
    
    def get_status(self) -> Dict[str, Any]:
        """
        Get current module status and detected account information
        
        Returns:
            dict: Current module status
        """
        with self.lock:
            return {
                "module": self.module_name,
                "version": self.version,
                "detected_account_type": self.detected_account_type,
                "account_verified": self.account_verified,
                "broker_info": self.broker_info.copy(),
                "current_rules": self.current_rules.copy() if self.current_rules else None,
                "telemetry": self.telemetry.copy(),
                "mt5_available": MT5_AVAILABLE,
                "supported_account_types": list(self.account_type_patterns.keys())
            }

# Module initialization (EventBus integration)
if __name__ == "__main__":
    # Initialize BrokerDiscoveryEngine
    broker_discovery = BrokerDiscoveryEngine()
    
    # Status print (COMPLIANCE: No mock data references)
    print("‚úÖ BrokerDiscoveryEngine v1.0 initialized ‚Äî Dynamic broker rule detection active.")
    print("üìã Supported account types:")
    for account_type in broker_discovery.account_type_patterns.keys():
        print(f"   - {account_type}")
    print("üîç Waiting for MT5 connection to detect account type...")
