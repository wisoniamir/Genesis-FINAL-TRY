"""
GENESIS Multi-Account Splitter Test Suite v1.0 - PHASE 34
Comprehensive validation of dynamic trade routing and position sizing
ARCHITECT MODE v2.8 - STRICT COMPLIANCE

Test Coverage:
‚úÖ Trade splitting algorithms (dynamic_balanced, equity_weighted, risk_distributed)
‚úÖ Account capacity monitoring and warnings
‚úÖ Position sizing calculations and adjustments
‚úÖ EventBus integration and route validation
‚úÖ Telemetry tracking and error handling
‚úÖ Load balancing efficiency
‚úÖ Account rule compliance
‚úÖ Edge cases and error scenarios
"""

import unittest
import json
import os
import tempfile
import time
from datetime import datetime, timedelta
from unittest.mock import Mock, patch
from threading import Thread

# Import the module to test
from multi_account_splitter import MultiAccountSplitter

class TestMultiAccountSplitter(unittest.TestCase):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.event_bus = self._get_event_bus()
        
    def _get_event_bus(self):
        # Auto-injected EventBus connection
        try:
            from event_bus_manager import EventBusManager
            return EventBusManager.get_instance()
        except ImportError:
            logging.warning("EventBus not available - integration required")
            return None
            
    def emit_telemetry(self, data):
        if self.event_bus:
            self.event_bus.emit('telemetry', data)
    """
    GENESIS MultiAccountSplitter Test Suite - PHASE 34 Validation
    Architecture Compliance Testing
    """
    
    def setUp(self):
        """Set up test environment with mock accounts and data"""
        self.splitter = MultiAccountSplitter()
        
        # Mock account data for testing
        self.mock_accounts = {
            "FTMO_Challenge_001": {
                "account_id": "FTMO_Challenge_001",
                "account_type": "FTMO Challenge",
                "current_equity": 100000.0,
                "available_margin": 95000.0,
                "max_utilization": 0.80,
                "position_count": 2,
                "last_update": datetime.utcnow().isoformat()
            },
            "FTMO_Swing_002": {
                "account_id": "FTMO_Swing_002", 
                "account_type": "FTMO Swing",
                "current_equity": 200000.0,
                "available_margin": 180000.0,
                "max_utilization": 0.85,
                "position_count": 3,
                "last_update": datetime.utcnow().isoformat()
            },
            "Regular_Broker_003": {
                "account_id": "Regular_Broker_003",
                "account_type": "Regular Broker",
                "current_equity": 50000.0,
                "available_margin": 45000.0,
                "max_utilization": 0.90,
                "position_count": 1,
                "last_update": datetime.utcnow().isoformat()
            }
        }
        
        # Initialize splitter with mock account data
        self.splitter.connected_accounts = self.mock_accounts.copy()
        for account_id, account_data in self.mock_accounts.items():
            self.splitter.account_capacities[account_id] = {
                "max_equity": account_data["current_equity"],
                "current_utilization": account_data["position_count"] * 0.15,  # Mock utilization
                "available_capacity": account_data["available_margin"] / account_data["current_equity"]
            }
          # Mock EventBus functions
        self.emitted_events = []        
        def mock_emit_event(topic, data, source):
            self.emitted_events.append({"topic": topic, "data": data, "source": source})
        
        # Patch emit_event function
        import multi_account_splitter
        self.original_emit = multi_account_splitter.emit_event
        multi_account_splitter.emit_event = mock_emit_event
        
    def tearDown(self):
        """Clean up test environment"""
        import multi_account_splitter
        multi_account_splitter.emit_event = self.original_emit
    
    def test_01_module_initialization(self):
        """Test MultiAccountSplitter module initialization and compliance"""
        # Test basic initialization
        self.assertEqual(self.splitter.module_name, "MultiAccountSplitter")
        self.assertEqual(self.splitter.version, "1.0")
        self.assertIsInstance(self.splitter.telemetry, dict)
        self.assertIsInstance(self.splitter.routing_metrics, dict)
        
        # Test compliance requirements
        self.assertIn("trades_split", self.splitter.telemetry)
        self.assertIn("accounts_routed_to", self.splitter.telemetry)
        self.assertIn("successful_splits", self.splitter.routing_metrics)
        
        # Test routing algorithms
        valid_algorithms = ["dynamic_balanced", "equity_weighted", "risk_distributed"]
        self.assertIn(self.splitter.routing_algorithm, valid_algorithms)
        
        print("‚úÖ Module initialization test passed")
    
    def test_02_dynamic_balanced_splitting(self):
        """Test dynamic balanced trade splitting algorithm"""
        self.splitter.routing_algorithm = "dynamic_balanced"
        
        # Mock trade signal
        trade_signal = {
            "signal_id": "TEST_SIGNAL_001",
            "symbol": "EURUSD",
            "direction": "BUY",
            "position_size": 1.0,  # 1 lot
            "confidence": 0.85,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        # Test split calculation
        result = self.splitter._calculate_split_allocation(trade_signal)
        
        # Validate results
        self.assertIsInstance(result, dict)
        self.assertIn("allocations", result)
        self.assertIn("total_allocated", result)
        self.assertIn("routing_metrics", result)
        
        # Check that total allocation equals original position size
        total_allocated = sum(alloc["position_size"] for alloc in result["allocations"])
        self.assertAlmostEqual(total_allocated, trade_signal["position_size"], places=2)
        
        # Check that all accounts are considered
        allocated_accounts = [alloc["account_id"] for alloc in result["allocations"]]
        self.assertTrue(len(allocated_accounts) > 0)
        
        print("‚úÖ Dynamic balanced splitting test passed")
    
    def test_03_equity_weighted_splitting(self):
        """Test equity weighted trade splitting algorithm"""
        self.splitter.routing_algorithm = "equity_weighted"
        
        # Mock trade signal with larger position size
        trade_signal = {
            "signal_id": "TEST_SIGNAL_002",
            "symbol": "GBPUSD",
            "direction": "SELL",
            "position_size": 2.5,  # 2.5 lots
            "confidence": 0.75,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        # Test split calculation
        result = self.splitter._calculate_split_allocation(trade_signal)
        
        # Validate equity weighting logic
        self.assertIsInstance(result, dict)
        allocations = result["allocations"]
        
        # Verify higher equity accounts get larger allocations
        if len(allocations) >= 2:
            # Sort by position size to check weighting
            sorted_allocs = sorted(allocations, key=lambda x: x["position_size"], reverse=True)
            
            # Get corresponding account equity
            for i in range(len(sorted_allocs) - 1):
                current_account = sorted_allocs[i]["account_id"]
                next_account = sorted_allocs[i + 1]["account_id"]
                
                current_equity = self.mock_accounts[current_account]["current_equity"]
                next_equity = self.mock_accounts[next_account]["current_equity"]
                
                # Higher equity should generally get larger allocation
                if current_equity > next_equity:
                    self.assertGreaterEqual(sorted_allocs[i]["position_size"], 
                                          sorted_allocs[i + 1]["position_size"])
        
        print("‚úÖ Equity weighted splitting test passed")
    
    def test_04_risk_distributed_splitting(self):
        """Test risk distributed trade splitting algorithm"""
        self.splitter.routing_algorithm = "risk_distributed"
        
        # Mock high-risk trade signal
        trade_signal = {
            "signal_id": "TEST_SIGNAL_003",
            "symbol": "XAUUSD",
            "direction": "BUY",
            "position_size": 0.5,  # 0.5 lots (smaller, higher risk)
            "confidence": 0.65,  # Lower confidence
            "timestamp": datetime.utcnow().isoformat()
        }
        
        # Test split calculation
        result = self.splitter._calculate_split_allocation(trade_signal)
        
        # Validate risk distribution
        self.assertIsInstance(result, dict)
        allocations = result["allocations"]
        
        # Check that risk is distributed across multiple accounts
        if len(allocations) > 1:
            # Ensure no single account takes all the risk
            max_allocation = max(alloc["position_size"] for alloc in allocations)
            total_position = sum(alloc["position_size"] for alloc in allocations)
            
            # Max single allocation should be less than 70% of total for risk distribution
            max_percentage = max_allocation / total_position
            self.assertLess(max_percentage, 0.70)
        
        print("‚úÖ Risk distributed splitting test passed")
    
    def test_05_account_capacity_monitoring(self):
        """Test account capacity monitoring and warning system"""
        # Simulate near-capacity account
        self.mock_accounts["FTMO_Challenge_001"]["current_equity"] = 100000.0
        self.splitter.account_capacities["FTMO_Challenge_001"]["current_utilization"] = 0.88
        
        # Test capacity check
        account_id = "FTMO_Challenge_001"
        position_size = 0.5
        
        capacity_ok = self.splitter._check_account_capacity(account_id, position_size)
        
        # Should trigger capacity warning
        self.assertFalse(capacity_ok)
        
        # Test with normal capacity account
        normal_capacity_ok = self.splitter._check_account_capacity("Regular_Broker_003", 0.1)
        self.assertTrue(normal_capacity_ok)
        
        print("‚úÖ Account capacity monitoring test passed")
    
    def test_06_position_size_adjustments(self):
        """Test position size adjustments and granularity compliance"""
        # Test position size rounding to granularity
        original_sizes = [0.127, 0.0456, 1.8342, 0.003]
        expected_sizes = [0.13, 0.05, 1.83, 0.01]  # Rounded to 0.01 granularity
        
        for original, expected in zip(original_sizes, expected_sizes):
            adjusted = self.splitter._adjust_position_size(original)
            self.assertAlmostEqual(adjusted, expected, places=2)
        
        # Test minimum position size enforcement
        too_small = 0.005
        adjusted_small = self.splitter._adjust_position_size(too_small)
        self.assertGreaterEqual(adjusted_small, self.splitter.min_position_size)
        
        print("‚úÖ Position size adjustments test passed")
    
    def test_07_eventbus_integration(self):
        """Test EventBus integration and route validation"""
        # Mock a complete trade signal processing
        trade_signal = {
            "signal_id": "TEST_SIGNAL_004",
            "symbol": "USDJPY",
            "direction": "BUY",
            "position_size": 1.5,
            "confidence": 0.80,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        # Process the signal
        self.splitter._handle_trade_signal_confirmed(trade_signal)
        
        # Check that events were emitted
        self.assertGreater(len(self.emitted_events), 0)
        
        # Validate event topics
        event_topics = [event["topic"] for event in self.emitted_events]
        expected_topics = ["TradeRouteToAccount", "ModuleTelemetry"]
        
        for topic in expected_topics:
            self.assertIn(topic, event_topics)
        
        print("‚úÖ EventBus integration test passed")
    
    def test_08_telemetry_tracking(self):
        """Test telemetry tracking and metrics collection"""
        initial_trades_split = self.splitter.telemetry["trades_split"]
        initial_accounts_routed = self.splitter.telemetry["accounts_routed_to"]
        
        # Process a trade to update telemetry
        trade_signal = {
            "signal_id": "TEST_SIGNAL_005",
            "symbol": "EURGBP",
            "direction": "SELL",
            "position_size": 0.8,
            "confidence": 0.70,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        self.splitter._handle_trade_signal_confirmed(trade_signal)
        
        # Check telemetry updates
        self.assertGreater(self.splitter.telemetry["trades_split"], initial_trades_split)
        self.assertGreaterEqual(self.splitter.telemetry["accounts_routed_to"], initial_accounts_routed)
        
        # Check that last_split_time was updated
        self.assertIsNotNone(self.splitter.telemetry["last_split_time"])
        
        print("‚úÖ Telemetry tracking test passed")
    
    def test_09_load_balancing_efficiency(self):
        """Test load balancing efficiency and optimization"""
        # Test multiple consecutive trades to check load balancing
        trade_signals = [
            {"signal_id": f"TEST_SIGNAL_{i:03d}", "symbol": "EURUSD", "direction": "BUY", 
             "position_size": 0.5, "confidence": 0.75} for i in range(6, 11)
        ]
        
        account_usage = {account_id: 0 for account_id in self.mock_accounts.keys()}
        
        for signal in trade_signals:
            signal["timestamp"] = datetime.utcnow().isoformat()
            result = self.splitter._calculate_split_allocation(signal)
            
            # Track account usage
            for allocation in result["allocations"]:
                account_usage[allocation["account_id"]] += allocation["position_size"]
        
        # Check that load is distributed reasonably
        usage_values = list(account_usage.values())
        if len(usage_values) > 1:
            min_usage = min(usage_values)
            max_usage = max(usage_values)
            
            # Load should be reasonably balanced (max/min ratio < 3.0)
            if min_usage > 0:
                balance_ratio = max_usage / min_usage
                self.assertLess(balance_ratio, 3.0)
        
        print("‚úÖ Load balancing efficiency test passed")
    
    def test_10_error_handling_and_edge_cases(self):
        """Test error handling and edge case scenarios"""
        # Test with empty accounts
        original_accounts = self.splitter.connected_accounts.copy()
        self.splitter.connected_accounts = {}
        
        trade_signal = {
            "signal_id": "TEST_SIGNAL_ERROR_001",
            "symbol": "GBPJPY",
            "direction": "BUY",
            "position_size": 1.0,
            "confidence": 0.80,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        # Should handle gracefully without crashing
        try:
            result = self.splitter._calculate_split_allocation(trade_signal)
            # Should return empty allocation or default handling
            self.assertIsInstance(result, dict)
        except Exception as e:
            self.fail(f"Error handling failed: {e}")
        
        # Restore accounts
        self.splitter.connected_accounts = original_accounts
        
        # Test with invalid position size
        invalid_signal = trade_signal.copy()
        invalid_signal["position_size"] = -1.0  # Invalid negative size
        
        try:
            result = self.splitter._calculate_split_allocation(invalid_signal)
            # Should handle gracefully
            self.assertIsInstance(result, dict)
        except Exception as e:
            self.fail(f"Invalid position size handling failed: {e}")
        
        # Test with missing required fields
        incomplete_signal = {"signal_id": "INCOMPLETE", "symbol": "EURUSD"}
        
        try:
            result = self.splitter._calculate_split_allocation(incomplete_signal)
            self.assertIsInstance(result, dict)
        except Exception as e:
            self.fail(f"Incomplete signal handling failed: {e}")
        
        print("‚úÖ Error handling and edge cases test passed")
    
    def test_11_performance_benchmarks(self):
        """Test performance benchmarks and latency requirements"""
        # Test processing latency for single trade
        trade_signal = {
            "signal_id": "PERF_TEST_001",
            "symbol": "EURUSD",
            "direction": "BUY",
            "position_size": 1.0,
            "confidence": 0.85,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        start_time = time.perf_counter()
        result = self.splitter._calculate_split_allocation(trade_signal)
        end_time = time.perf_counter()
        
        latency_ms = (end_time - start_time) * 1000
        
        # Should process within 100ms for single trade
        self.assertLess(latency_ms, 100.0)
        
        # Test batch processing performance
        batch_signals = [
            {
                "signal_id": f"BATCH_PERF_{i:03d}",
                "symbol": "EURUSD",
                "direction": "BUY" if i % 2 == 0 else "SELL",
                "position_size": 0.5 + (i * 0.1),
                "confidence": 0.70 + (i * 0.01),
                "timestamp": datetime.utcnow().isoformat()
            } for i in range(10)
        ]
        
        batch_start = time.perf_counter()
        batch_results = []
        for signal in batch_signals:
            batch_results.append(self.splitter._calculate_split_allocation(signal))
        batch_end = time.perf_counter()
        
        batch_latency_ms = (batch_end - batch_start) * 1000
        avg_per_signal_ms = batch_latency_ms / len(batch_signals)
        
        # Average per signal should be under 50ms in batch processing
        self.assertLess(avg_per_signal_ms, 50.0)
        
        print(f"‚úÖ Performance benchmarks test passed - Single: {latency_ms:.2f}ms, Batch avg: {avg_per_signal_ms:.2f}ms")
    
    def test_12_architect_mode_compliance(self):
        """Test strict architect mode compliance requirements"""
        # Test real data only (no mock/dummy data in production paths)
        self.assertNotIn("mock", self.splitter.module_name.lower())
        self.assertNotIn("dummy", self.splitter.module_name.lower())
        self.assertNotIn("test", self.splitter.module_name.lower())
        
        # Test EventBus integration (no local function calls)
        # This is validated by checking that all major operations emit events
        
        # Test telemetry hooks
        required_telemetry_fields = [
            "trades_split", "accounts_routed_to", "capacity_warnings_issued",
            "position_adjustments_made", "module_start_time"
        ]
        
        for field in required_telemetry_fields:
            self.assertIn(field, self.splitter.telemetry)
        
        # Test error logging capability
        self.assertTrue(hasattr(self.splitter, 'logger'))
        
        # Test no isolated functions (all major operations should be event-driven)
        # This is enforced by the module design
        
        print("‚úÖ Architect mode compliance test passed")

def run_multi_account_splitter_tests():
    """
    Run the complete MultiAccountSplitter test suite
    ARCHITECT MODE v2.8 - Production Validation
    """
    print("üöÄ GENESIS MultiAccountSplitter Test Suite v1.0 - PHASE 34")
    print("=" * 80)
    
    # Create test suite
    suite = unittest.TestLoader().loadTestsFromTestCase(TestMultiAccountSplitter)
    
    # Run tests with detailed output
    runner = unittest.TextTestRunner(verbosity=2, stream=None)
    result = runner.run(suite)
    
    # Generate test report
    total_tests = result.testsRun
    failures = len(result.failures)
    errors = len(result.errors)
    passed = total_tests - failures - errors
    
    print("\n" + "=" * 80)
    print("üìä PHASE 34 MultiAccountSplitter Test Results:")
    print(f"‚úÖ Tests Passed: {passed}/{total_tests}")
    print(f"‚ùå Tests Failed: {failures}")
    print(f"‚ö†Ô∏è  Test Errors: {errors}")
    print(f"üéØ Success Rate: {(passed/total_tests)*100:.1f}%")
    
    if failures > 0:
        print("\n‚ùå FAILED TESTS:")
        for test, traceback in result.failures:
            print(f"  - {test}: {traceback.split('AssertionError: ')[-1].split('\\n')[0]}")
    
    if errors > 0:
        print("\n‚ö†Ô∏è ERROR TESTS:")
        for test, traceback in result.errors:
            print(f"  - {test}: {traceback.split('Error: ')[-1].split('\\n')[0]}")
    
    # Compliance validation
    compliance_status = "FULLY_COMPLIANT" if (failures == 0 and errors == 0) else "VIOLATIONS_DETECTED"
    print(f"\nüîê ARCHITECT MODE COMPLIANCE: {compliance_status}")
    
    return {
        "total_tests": total_tests,
        "passed": passed,
        "failed": failures,
        "errors": errors,
        "success_rate": (passed/total_tests)*100,
        "compliance_status": compliance_status
    }

if __name__ == "__main__":
    # Run the test suite
    test_results = run_multi_account_splitter_tests()
    
    # Exit with appropriate code
    exit_code = 0 if test_results["failed"] == 0 and test_results["errors"] == 0 else 1
    exit(exit_code)

    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        