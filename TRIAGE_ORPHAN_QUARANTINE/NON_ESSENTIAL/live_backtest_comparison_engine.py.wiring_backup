# <!-- @GENESIS_MODULE_START: live_backtest_comparison_engine -->

#!/usr/bin/env python3
"""
ðŸ” GENESIS LIVE VS BACKTEST COMPARISON ENGINE v1.0
Phase 93: Live vs Backtest Comparison Engine - Architect v5.0.0

ðŸŽ¯ PURPOSE:
Real-time comparison between live trading performance and backtest results
Quantifies performance gaps and alerts on underperformance

ðŸ›¡ï¸ ARCHITECT MODE COMPLIANCE:
- No simplified logic or fallback mechanisms
- Real data only from execution_log.json and backtest_runs.json
- Event-driven architecture with EventBus integration
- Comprehensive telemetry and performance tracking
- Institutional-grade performance analysis
"""

import json
import os
import logging
import threading
import time
from datetime import datetime, timedelta
from typing import Dict, List, Any
from collections import defaultdict
from modules.hardened_event_bus import get_event_bus, emit_event, subscribe_to_event
from dataclasses import dataclass
import statistics

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class TradeComparison:
    """Data class for trade comparison results"""
    trade_id: str
    symbol: str
    timestamp: str
    live_profit: float
    backtest_profit: float
    deviation_pct: float
    deviation_absolute: float
    signal_drift: float
    execution_quality: str

@dataclass
class PerformanceGap:
    """Data class for performance gap analysis"""
    symbol: str
    timeframe: str
    live_win_rate: float
    backtest_win_rate: float
    live_avg_profit: float
    backtest_avg_profit: float
    performance_gap_pct: float
    alert_level: str

    def log_state(self):
        """Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        return state_data

class LiveBacktestComparisonEngine:
    """
    GENESIS Live vs Backtest Comparison Engine
    
    ðŸ” EventBus Integration: 
        - Listens: backtest:completed, execution:filled, trade:closed
        - Emits: feedback:strategy_performance_gap, comparison:alert
    
    ðŸ“¡ Telemetry: 
        - Exports to /telemetry/live_vs_backtest_report.json
        - Real-time performance delta calculations
        - Signal drift and execution quality scoring
    
    ðŸ§ª Validation:
        - Matches trades by symbol, timestamp, direction
        - 5% tolerance for acceptable signal mismatch
        - >10% underperformance triggers alerts
    """
    
    def __init__(self, event_bus):
        self.event_bus = event_bus
        self.comparison_data = []
        self.performance_gaps = {}
        self.live_trades = []
        self.backtest_results = []
        self.monitoring = False
        
        # Performance thresholds
        self.deviation_tolerance = 0.05  # 5% tolerance
        self.alert_threshold = 0.10  # 10% underperformance alert
        
        # Create telemetry directory
        os.makedirs("telemetry", exist_ok=True)
        
        # Initialize data
        self._load_historical_data()
        
        # Setup event subscriptions
        self._setup_event_subscriptions()
        
        # Start monitoring
        self._start_monitoring()
        
        logger.info("Live vs Backtest Comparison Engine initialized")
        
    
        # GENESIS Phase 91 Telemetry Injection
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", {
                "module": __name__,
                "status": "running",
                "timestamp": datetime.now().isoformat(),
                "phase": "91_telemetry_enforcement"
            })
    def _setup_event_subscriptions(self):
        """Setup EventBus event subscriptions"""
        self.event_bus.subscribe("backtest:completed", self._on_backtest_completed)
        self.event_bus.subscribe("execution:filled", self._on_execution_filled)
        self.event_bus.subscribe("trade:closed", self._on_trade_closed)
        self.event_bus.subscribe("data:update:execution_log", self._on_execution_log_update)
        
    def _load_historical_data(self):
        """Load historical live trades and backtest results"""
        try:
            # Load live trades
            if os.path.exists("execution_log.json"):
                with open("execution_log.json", 'r') as f:
                    self.live_trades = json.load(f)
                logger.info(f"Loaded {len(self.live_trades)} live trades")
            
            # Load backtest results
            if os.path.exists("telemetry/backtest_runs.json"):
                with open("telemetry/backtest_runs.json", 'r') as f:
                    self.backtest_results = json.load(f)
                logger.info(f"Loaded {len(self.backtest_results)} backtest runs")
                
            # Perform initial comparison
            self._perform_comprehensive_comparison()
            
        except Exception as e:
            logger.error(f"Error loading historical data: {e}")
            
    def _start_monitoring(self):
        """Start real-time monitoring thread"""
        self.monitoring = True
        self.monitor_thread = threading.Thread(target=self._monitoring_loop, daemon=True)
        self.monitor_thread.start()
        logger.info("Live vs Backtest monitoring started")
        
    def _monitoring_loop(self):
        """Main monitoring loop for real-time comparison"""
        while self.monitoring:
            try:
                # Periodic comparison update
                self._update_performance_analysis()
                
                # Check for performance alerts
                self._check_performance_alerts()
                
                # Update telemetry report
                self._update_telemetry_report()
                
                time.sleep(30)  # Update every 30 seconds
                
            except Exception as e:
                logger.error(f"Error in monitoring loop: {e}")
                time.sleep(60)  # Wait longer on error
                
    def _on_backtest_completed(self, event):
        """Handle backtest completion events"""
        try:
            backtest_data = event.get("data", {})
            self.backtest_results.append(backtest_data)

            # Trigger comparison update
            self._perform_comprehensive_comparison()

            logger.info(f"Processed backtest completion: {backtest_data.get('backtest_id', 'unknown')}")

        except Exception as e:
            logger.error(f"Error processing backtest completion: {e}")
            
    def _on_execution_filled(self, event):
        """Handle live trade execution events"""
        try:
            execution_data = event.get("data", {})
            self.live_trades.append(execution_data)

            # Trigger comparison update
            self._perform_comprehensive_comparison()

            logger.info(f"Processed live trade execution: {execution_data.get('trade_id', 'unknown')}")

        except Exception as e:
            logger.error(f"Error processing live trade execution: {e}")
            
    def _on_trade_closed(self, event):
        """Handle trade close events"""
        try:
            trade_data = event.get("data", {})
            
            # Update live trades list
            self.live_trades.append(trade_data)
            
            # Trigger comparison update
            self._update_symbol_performance_gap(trade_data.get("symbol"))
            
            logger.info(f"Processed trade close: {trade_data.get('symbol', 'unknown')}")
            
        except Exception as e:
            logger.error(f"Error processing trade close: {e}")
            
    def _on_execution_log_update(self, event):
        """Handle execution log file updates"""
        try:
            # Reload live trades
            self._load_historical_data()
            
        except Exception as e:
            logger.error(f"Error handling execution log update: {e}")
            
    def _find_matching_backtest_trades(self, live_trade: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Find backtest trades that match live trade criteria"""
        matches = []
        
        try:
            live_symbol = live_trade.get("symbol")
            live_timestamp = live_trade.get("timestamp")
            live_action = live_trade.get("action")
            
            assert all([live_symbol, live_timestamp, live_action]) is not None, "Real data required - no fallbacks allowed"

            # Match backtest trades by symbol and timestamp
            for backtest_trade in self.backtest_results:
                backtest_symbol = backtest_trade.get("symbol")
                backtest_timestamp = backtest_trade.get("timestamp")
                backtest_action = backtest_trade.get("action")
                
                # Check if within tolerance window
                if (live_symbol == backtest_symbol and
                    abs(datetime.fromisoformat(live_timestamp) - datetime.fromisoformat(backtest_timestamp)) <= timedelta(minutes=5) and
                    live_action == backtest_action):
                    matches.append(backtest_trade)
                    
            logger.info(f"Found {len(matches)} matching backtest trades for live trade {live_trade.get('trade_id')}")
            
        except Exception as e:
            logger.error(f"Error finding matching backtest trades: {e}")
            
        return matches
    
    def _emit_performance_gap(self, performance_gap: PerformanceGap):
        """Emit performance gap event"""
        self.event_bus.emit("PerformanceGap", vars(performance_gap))

    def _subscribe_to_performance_gap(self):
        """Subscribe to performance gap event"""
        self.event_bus.subscribe(
            "PerformanceGap",
            lambda x: logger.info(f"Performance gap emitted: {x}")
        )

    def _create_trade_comparison(self, live_trade: Dict[str, Any],
                                 backtest_trade: Dict[str, Any]) -> TradeComparison:
        """Create a trade comparison object"""
        deviation_absolute = (
            live_trade.get("pnl", 0) - backtest_trade.get("pnl", 0)
        )
        deviation_pct = (
            deviation_absolute / backtest_trade.get("pnl", 1)
        ) * 100  # Avoid division by zero
        signal_drift = (
            live_trade.get("signal_strength", 0) - backtest_trade.get("signal_strength", 0)
        )

        return TradeComparison(
            trade_id=live_trade.get("trade_id", ""),
            symbol=live_trade.get("symbol", ""),
            timestamp=live_trade.get("timestamp", ""),
            live_profit=live_trade.get("pnl", 0),
            backtest_profit=backtest_trade.get("pnl", 0),
            deviation_pct=deviation_pct,
            deviation_absolute=deviation_absolute,
            signal_drift=signal_drift,
            execution_quality=self._evaluate_execution_quality(deviation_pct)
        )
        
    def _evaluate_execution_quality(self, deviation_pct: float) -> str:
        """Evaluate execution quality based on deviation percentage"""
        if abs(deviation_pct) <= 5:
            return "high"
        elif abs(deviation_pct) <= 10:
            return "medium"
        else:
            return "low"
        
    def compare_performance(self, live_data: List[Dict[str, Any]], backtest_data: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Compare live and backtest performance metrics"""
        try:
            grouped_comparisons = defaultdict(list)

            for live_trade in live_data:
                for backtest_trade in backtest_data:
                    # Perform comparison logic
                    grouped_comparisons[live_trade['symbol']].append(backtest_trade)

            return grouped_comparisons

        except Exception as e:
            logger.error(f"Error in performance comparison: {e}")
            return {}
    
    def _perform_comprehensive_comparison(self):
        """Perform comprehensive comparison between live and backtest data"""
        try:
            logger.info("Starting comprehensive comparison")
            
            # Clear previous comparison data
            self.comparison_data.clear()
            
            # Compare each live trade with all backtest results
            for live_trade in self.live_trades:
                matches = self._find_matching_backtest_trades(live_trade)
                
                if matches:
                    for match in matches:
                        comparison = self._create_trade_comparison(live_trade, match)
                        self.comparison_data.append(comparison)
            
            logger.info(f"Comprehensive comparison completed: {len(self.comparison_data)} comparisons")
            
        except Exception as e:
            logger.error(f"Error performing comprehensive comparison: {e}")
            
    def _update_symbol_performance_gap(self, symbol):
        """Update performance gap for a specific symbol"""
        pass

    def _check_performance_alerts(self):
        """Check for performance alerts"""
        pass

    def _update_telemetry_report(self):
        """Update telemetry report"""
        pass
    
    def _update_performance_analysis(self):
        """Update performance analysis metrics"""
        try:
            logger.info("Updating performance analysis")
            
            # Group comparisons by symbol
            grouped_comparisons = defaultdict(list)
            for comparison in self.comparison_data:
                grouped_comparisons[comparison.symbol].append(comparison)
            
            # Calculate performance gaps for each symbol
            for symbol, comparisons in grouped_comparisons.items():
                live_wins = sum(1 for c in comparisons if c.live_profit > 0)
                backtest_wins = sum(1 for c in comparisons if c.backtest_profit > 0)
                live_total = len(comparisons)
                backtest_total = len(comparisons)
                
                live_avg_profit = statistics.mean([c.live_profit for c in comparisons])
                backtest_avg_profit = statistics.mean([c.backtest_profit for c in comparisons])
                
                performance_gap_pct = ((live_avg_profit - backtest_avg_profit) / backtest_avg_profit) * 100 if backtest_avg_profit != 0 else 0
                
                alert_level = "none"
                if performance_gap_pct > 10:
                    alert_level = "high"
                elif performance_gap_pct > 5:
                    alert_level = "medium"
                
                gap = PerformanceGap(
                    symbol=symbol,
                    timeframe="",
                    live_win_rate=live_wins / live_total if live_total > 0 else 0,
                    backtest_win_rate=backtest_wins / backtest_total if backtest_total > 0 else 0,
                    live_avg_profit=live_avg_profit,
                    backtest_avg_profit=backtest_avg_profit,
                    performance_gap_pct=performance_gap_pct,
                    alert_level=alert_level
                )
                
                self.performance_gaps[symbol] = gap
                
                logger.info(f"Updated performance analysis for {symbol}: {gap}")
            
        except Exception as e:
            logger.error(f"Error updating performance analysis: {e}")
            
    def emit_performance_gap(self, performance_gap: Dict[str, Any]):
        """Emit performance gap to EventBus"""
        emit_event(self.event_bus, "PerformanceGap", performance_gap)

# Ensure EventBus integration
subscribe_to_event(
    get_event_bus(),
    "PerformanceGap",
    lambda x: logger.info(f"Performance gap emitted: {x}")
)

# Updated import path to reflect the new location of hardened_event_bus.
# <!-- @GENESIS_MODULE_END: live_backtest_comparison_engine -->