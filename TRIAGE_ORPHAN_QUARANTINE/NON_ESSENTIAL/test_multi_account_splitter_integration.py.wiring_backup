# <!-- @GENESIS_MODULE_START: test_multi_account_splitter_integration -->

"""
GENESIS Multi-Account Splitter Integration Test v1.0 - PHASE 34
Integration testing for dynamic trade routing and position sizing
ARCHITECT MODE v2.8 - STRICT COMPLIANCE

Integration Test Coverage:
✅ Module initialization and EventBus integration
✅ Trade signal processing through event handlers
✅ Account status updates and capacity monitoring
✅ Rule updates from broker discovery engine
✅ Telemetry emission and tracking
✅ Error handling and compliance validation
"""

import unittest
import json
import os
import time
from datetime import datetime
from unittest.mock import Mock, patch

# Import the module to test
from multi_account_splitter import MultiAccountSplitter

class TestMultiAccountSplitterIntegration(unittest.TestCase):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.event_bus = self._get_event_bus()
        
    def _get_event_bus(self):
        # Auto-injected EventBus connection
        try:
            from event_bus_manager import EventBusManager
            return EventBusManager.get_instance()
        except ImportError:
            logging.warning("EventBus not available - integration required")
            return None
            
    def emit_telemetry(self, data):
        if self.event_bus:
            self.event_bus.emit('telemetry', data)
    """
    GENESIS MultiAccountSplitter Integration Test Suite - PHASE 34
    Real-world event-driven testing through EventBus interface
    """
    
    def setUp(self):
        """Set up test environment with real event-driven interface"""
        self.splitter = MultiAccountSplitter()
        
        # Track emitted events
        self.emitted_events = []
        
        # Mock emit_event at module level
        def mock_emit_event(topic, data, source):
            self.emitted_events.append({
                "topic": topic,
                "data": data,
                "source": source,
                "timestamp": datetime.utcnow().isoformat()
            })
        
        # Patch the global emit_event function
        import multi_account_splitter
        self.original_emit = multi_account_splitter.emit_event
        multi_account_splitter.emit_event = mock_emit_event
        
        # Initialize with mock account data
        self._setup_mock_accounts()
    
    def tearDown(self):
        """Clean up test environment"""
        import multi_account_splitter
        multi_account_splitter.emit_event = self.original_emit
    
    def _setup_mock_accounts(self):
        """Setup mock account data for testing"""
        # Mock connected accounts
        self.splitter.connected_accounts = {
            "FTMO_001": {
                "account_id": "FTMO_001",
                "account_type": "FTMO Challenge",
                "broker": "FTMO",
                "enabled": True
            },
            "SWING_002": {
                "account_id": "SWING_002", 
                "account_type": "FTMO Swing",
                "broker": "FTMO",
                "enabled": True
            },
            "REGULAR_003": {
                "account_id": "REGULAR_003",
                "account_type": "Regular",
                "broker": "IC Markets",
                "enabled": True
            }
        }
        
        # Mock account capacities
        self.splitter.account_capacities = {
            "FTMO_001": {
                "equity": 100000.0,
                "margin_used": 5000.0,
                "margin_available": 95000.0,
                "utilization": 0.15
            },
            "SWING_002": {
                "equity": 200000.0,
                "margin_used": 10000.0,
                "margin_available": 190000.0,
                "utilization": 0.20
            },
            "REGULAR_003": {
                "equity": 50000.0,
                "margin_used": 2000.0,
                "margin_available": 48000.0,
                "utilization": 0.10
            }
        }
        
        # Mock account rules
        self.splitter.account_rules = {
            "FTMO_001": {
                "max_daily_loss": 5000.0,
                "max_total_loss": 10000.0,
                "max_position_size": 2.0,
                "allowed_symbols": ["EURUSD", "GBPUSD", "USDJPY"]
            },
            "SWING_002": {
                "max_daily_loss": 10000.0,
                "max_total_loss": 20000.0,
                "max_position_size": 5.0,
                "allowed_symbols": ["EURUSD", "GBPUSD", "USDJPY", "XAUUSD"]
            },
            "REGULAR_003": {
                "max_daily_loss": 2500.0,
                "max_total_loss": 5000.0,
                "max_position_size": 1.0,
                "allowed_symbols": ["EURUSD", "GBPUSD"]
            }
        }
    
    def test_01_module_initialization_compliance(self):
        """Test module initialization and architect mode compliance"""
        # Test basic properties
        self.assertEqual(self.splitter.module_name, "MultiAccountSplitter")
        self.assertEqual(self.splitter.version, "1.0")
        
        # Test telemetry structure
        required_telemetry_fields = [
            "trades_split", "accounts_routed_to", "capacity_warnings_issued",
            "position_adjustments_made", "module_start_time"
        ]
        
        for field in required_telemetry_fields:
            self.assertIn(field, self.splitter.telemetry)
        
        # Test routing algorithms
        valid_algorithms = ["dynamic_balanced", "equity_weighted", "risk_distributed"]
        self.assertIn(self.splitter.routing_algorithm, valid_algorithms)
        
        # Test logger initialization
        self.assertTrue(hasattr(self.splitter, 'logger'))
        
        print("✅ Module initialization compliance test passed")
    
    def test_02_trade_signal_confirmed_event_handling(self):
        """Test TradeSignalConfirmed event handling"""
        # Clear previous events
        self.emitted_events.clear()
        
        # Create trade signal event
        trade_signal_event = {
            "event_type": "TradeSignalConfirmed",
            "data": {
                "signal_id": "TEST_SIGNAL_001",
                "symbol": "EURUSD",
                "direction": "BUY",
                "position_size": 1.0,
                "confidence": 0.85,
                "timestamp": datetime.utcnow().isoformat(),
                "stop_loss": 1.0800,
                "take_profit": 1.0900
            }
        }
        
        # Process event
        self.splitter.on_trade_signal_confirmed(trade_signal_event)
        
        # Check that events were emitted
        self.assertGreater(len(self.emitted_events), 0)
        
        # Check for expected event topics
        event_topics = [event["topic"] for event in self.emitted_events]
        
        # Should emit TradeRouteToAccount events
        route_events = [e for e in self.emitted_events if e["topic"] == "TradeRouteToAccount"]
        self.assertGreater(len(route_events), 0)
        
        # Validate route event structure
        for route_event in route_events:
            route_data = route_event["data"]
            self.assertIn("account_id", route_data)
            self.assertIn("symbol", route_data)
            self.assertIn("direction", route_data)
            self.assertIn("position_size", route_data)
            self.assertGreater(route_data["position_size"], 0)
        
        print("✅ Trade signal confirmed event handling test passed")
    
    def test_03_account_status_update_event_handling(self):
        """Test AccountStatusUpdate event handling"""
        # Create account status update event
        account_update_event = {
            "event_type": "AccountStatusUpdate",
            "data": {
                "account_id": "FTMO_001",
                "equity": 98000.0,
                "margin_used": 7000.0,
                "margin_available": 91000.0,
                "balance": 100000.0,
                "timestamp": datetime.utcnow().isoformat()
            }
        }
        
        # Process event
        self.splitter.on_account_status_update(account_update_event)
        
        # Check that account capacities were updated
        self.assertEqual(self.splitter.account_capacities["FTMO_001"]["equity"], 98000.0)
        self.assertEqual(self.splitter.account_capacities["FTMO_001"]["margin_used"], 7000.0)
        
        print("✅ Account status update event handling test passed")
    
    def test_04_account_rules_update_event_handling(self):
        """Test AccountRulesUpdate event handling"""
        # Create account rules update event
        rules_update_event = {
            "event_type": "AccountRulesUpdate",
            "data": {
                "account_id": "FTMO_001",
                "rules": {
                    "max_daily_loss": 4000.0,  # Updated rule
                    "max_total_loss": 8000.0,  # Updated rule
                    "max_position_size": 1.5,
                    "allowed_symbols": ["EURUSD", "GBPUSD", "USDJPY", "AUDUSD"]
                },
                "timestamp": datetime.utcnow().isoformat()
            }
        }
        
        # Process event
        self.splitter.on_account_rules_update(rules_update_event)
        
        # Check that account rules were updated
        self.assertEqual(self.splitter.account_rules["FTMO_001"]["max_daily_loss"], 4000.0)
        self.assertEqual(self.splitter.account_rules["FTMO_001"]["max_total_loss"], 8000.0)
        self.assertIn("AUDUSD", self.splitter.account_rules["FTMO_001"]["allowed_symbols"])
        
        print("✅ Account rules update event handling test passed")
    
    def test_05_broker_rules_discovered_event_handling(self):
        """Test BrokerRulesDiscovered event handling"""
        # Create broker rules discovered event
        broker_rules_event = {
            "event_type": "BrokerRulesDiscovered",
            "data": {
                "broker_name": "FTMO",
                "account_type": "FTMO Challenge",
                "rules": {
                    "max_daily_loss_pct": 5.0,
                    "max_total_loss_pct": 10.0,
                    "max_leverage": 100,
                    "news_trading_allowed": False,
                    "weekend_trading_allowed": False
                },
                "timestamp": datetime.utcnow().isoformat()
            }
        }
        
        # Process event
        self.splitter.on_broker_rules_discovered(broker_rules_event)
        
        # Check that rules were processed (implementation may vary)
        # This test validates the event handler doesn't crash
        self.assertTrue(True)  # Placeholder assertion
        
        print("✅ Broker rules discovered event handling test passed")
    
    def test_06_multiple_account_routing(self):
        """Test routing across multiple accounts"""
        self.emitted_events.clear()
        
        # Create large position signal that should be split
        large_signal_event = {
            "event_type": "TradeSignalConfirmed",
            "data": {
                "signal_id": "LARGE_SIGNAL_001",
                "symbol": "EURUSD",
                "direction": "BUY",
                "position_size": 5.0,  # Large position
                "confidence": 0.90,
                "timestamp": datetime.utcnow().isoformat()
            }
        }
        
        # Process event
        self.splitter.on_trade_signal_confirmed(large_signal_event)
        
        # Check that multiple route events were emitted
        route_events = [e for e in self.emitted_events if e["topic"] == "TradeRouteToAccount"]
        
        # Should route to multiple accounts for large position
        self.assertGreaterEqual(len(route_events), 2)
        
        # Check total position allocation
        total_allocated = sum(route["data"]["position_size"] for route in route_events)
        self.assertGreater(total_allocated, 0)
        self.assertLessEqual(total_allocated, 5.0)  # Should not exceed original
        
        # Check different accounts were used
        accounts_used = set(route["data"]["account_id"] for route in route_events)
        self.assertGreater(len(accounts_used), 1)
        
        print("✅ Multiple account routing test passed")
    
    def test_07_capacity_warning_detection(self):
        """Test capacity warning detection and emission"""
        # Set up near-capacity account
        self.splitter.account_capacities["REGULAR_003"]["utilization"] = 0.92  # Near max
        
        self.emitted_events.clear()
        
        # Create signal for near-capacity account
        capacity_test_event = {
            "event_type": "TradeSignalConfirmed",
            "data": {
                "signal_id": "CAPACITY_TEST_001",
                "symbol": "EURUSD",
                "direction": "BUY",
                "position_size": 0.8,  # Large for small account
                "confidence": 0.75,
                "timestamp": datetime.utcnow().isoformat()
            }
        }
        
        # Process event
        self.splitter.on_trade_signal_confirmed(capacity_test_event)
        
        # Check for capacity warning events
        warning_events = [e for e in self.emitted_events if e["topic"] == "AccountCapacityWarning"]
        
        # May emit capacity warnings
        if len(warning_events) > 0:
            warning_data = warning_events[0]["data"]
            self.assertIn("account_id", warning_data)
            self.assertIn("utilization_percentage", warning_data)
        
        print("✅ Capacity warning detection test passed")
    
    def test_08_telemetry_emission_validation(self):
        """Test telemetry emission and data structure"""
        self.emitted_events.clear()
        
        # Process several signals to generate telemetry
        for i in range(3):
            signal_event = {
                "event_type": "TradeSignalConfirmed",
                "data": {
                    "signal_id": f"TELEMETRY_TEST_{i:03d}",
                    "symbol": "GBPUSD",
                    "direction": "SELL" if i % 2 == 0 else "BUY",
                    "position_size": 0.5 + (i * 0.2),
                    "confidence": 0.70 + (i * 0.05),
                    "timestamp": datetime.utcnow().isoformat()
                }
            }
            
            self.splitter.on_trade_signal_confirmed(signal_event)
            time.sleep(0.01)  # Small delay for telemetry
        
        # Check for telemetry events
        telemetry_events = [e for e in self.emitted_events if e["topic"] == "ModuleTelemetry"]
        self.assertGreater(len(telemetry_events), 0)
        
        # Validate telemetry structure
        for telemetry_event in telemetry_events:
            telemetry_data = telemetry_event["data"]
            self.assertIn("module_name", telemetry_data)
            self.assertIn("event_type", telemetry_data)
            self.assertIn("timestamp", telemetry_data)
            self.assertEqual(telemetry_data["module_name"], "MultiAccountSplitter")
        
        print("✅ Telemetry emission validation test passed")
    
    def test_09_error_handling_validation(self):
        """Test error handling for invalid inputs"""
        self.emitted_events.clear()
        
        # Test with invalid signal data
        invalid_signal_event = {
            "event_type": "TradeSignalConfirmed",
            "data": {
                "signal_id": "INVALID_001",
                # Missing required fields
                "timestamp": datetime.utcnow().isoformat()
            }
        }
        
        # Should handle gracefully without crashing
        try:
            self.splitter.on_trade_signal_confirmed(invalid_signal_event)
            # Check that error events were emitted
            error_events = [e for e in self.emitted_events if e["topic"] == "ModuleError"]
            # Should emit error but not crash
            self.assertTrue(True)  # Test that we reach this point
        except Exception as e:
            self.fail(f"Error handling failed: {e}")
        
        print("✅ Error handling validation test passed")
    
    def test_10_routing_algorithm_switching(self):
        """Test switching between routing algorithms"""
        algorithms = ["dynamic_balanced", "equity_weighted", "risk_distributed"]
        
        for algorithm in algorithms:
            self.splitter.routing_algorithm = algorithm
            self.emitted_events.clear()
            
            # Process signal with current algorithm
            signal_event = {
                "event_type": "TradeSignalConfirmed",
                "data": {
                    "signal_id": f"ALGO_TEST_{algorithm}",
                    "symbol": "USDJPY",
                    "direction": "BUY",
                    "position_size": 1.5,
                    "confidence": 0.80,
                    "timestamp": datetime.utcnow().isoformat()
                }
            }
            
            self.splitter.on_trade_signal_confirmed(signal_event)
            
            # Check that routing occurred
            route_events = [e for e in self.emitted_events if e["topic"] == "TradeRouteToAccount"]
            self.assertGreater(len(route_events), 0)
            
            # Check that routing algorithm is reflected in route data
            for route_event in route_events:
                if "routing_algorithm" in route_event["data"]:
                    # Implementation may include algorithm info
    raise NotImplementedError("Real implementation required - no stubs allowed in production")
        print("✅ Routing algorithm switching test passed")

def run_integration_tests():
    """
    Run the complete MultiAccountSplitter integration test suite
    ARCHITECT MODE v2.8 - Event-Driven Validation
    """
    print("🚀 GENESIS MultiAccountSplitter Integration Test Suite v1.0 - PHASE 34")
    print("=" * 80)
    
    # Create test suite
    suite = unittest.TestLoader().loadTestsFromTestCase(TestMultiAccountSplitterIntegration)
    
    # Run tests with detailed output
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # Generate test report
    total_tests = result.testsRun
    failures = len(result.failures)
    errors = len(result.errors)
    passed = total_tests - failures - errors
    
    print("\n" + "=" * 80)
    print("📊 PHASE 34 MultiAccountSplitter Integration Test Results:")
    print(f"✅ Tests Passed: {passed}/{total_tests}")
    print(f"❌ Tests Failed: {failures}")
    print(f"⚠️  Test Errors: {errors}")
    print(f"🎯 Success Rate: {(passed/total_tests)*100:.1f}%")
    
    if failures > 0:
        print("\n❌ FAILED TESTS:")
        for test, traceback in result.failures:
            print(f"  - {test}: {traceback.split('AssertionError: ')[-1].split('\\n')[0]}")
    
    if errors > 0:
        print("\n⚠️ ERROR TESTS:")
        for test, traceback in result.errors:
            print(f"  - {test}: {traceback.split('Error: ')[-1].split('\\n')[0]}")
    
    # Compliance validation
    compliance_status = "FULLY_COMPLIANT" if (failures == 0 and errors == 0) else "VIOLATIONS_DETECTED"
    print(f"\n🔐 ARCHITECT MODE COMPLIANCE: {compliance_status}")
    
    return {
        "total_tests": total_tests,
        "passed": passed,
        "failed": failures,
        "errors": errors,
        "success_rate": (passed/total_tests)*100,
        "compliance_status": compliance_status
    }

if __name__ == "__main__":
    # Run the integration test suite
    test_results = run_integration_tests()
    
    # Exit with appropriate code
    exit_code = 0 if test_results["failed"] == 0 and test_results["errors"] == 0 else 1
    exit(exit_code)

    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        

# <!-- @GENESIS_MODULE_END: test_multi_account_splitter_integration -->