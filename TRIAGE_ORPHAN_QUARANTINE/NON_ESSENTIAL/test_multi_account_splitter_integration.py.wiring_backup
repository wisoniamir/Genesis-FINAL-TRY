# <!-- @GENESIS_MODULE_START: test_multi_account_splitter_integration -->

"""
GENESIS Multi-Account Splitter Integration Test v1.0 - PHASE 34
Integration testing for dynamic trade routing and position sizing
ARCHITECT MODE v2.8 - STRICT COMPLIANCE

Integration Test Coverage:
‚úÖ Module initialization and EventBus integration
‚úÖ Trade signal processing through event handlers
‚úÖ Account status updates and capacity monitoring
‚úÖ Rule updates from broker discovery engine
‚úÖ Telemetry emission and tracking
‚úÖ Error handling and compliance validation
"""

import unittest
import json
import os
import time
from datetime import datetime
from unittest.mock import Mock, patch

# Import the module to test
from multi_account_splitter import MultiAccountSplitter

class TestMultiAccountSplitterIntegration(unittest.TestCase):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.event_bus = self._get_event_bus()
        
    def _get_event_bus(self):
        # Auto-injected EventBus connection
        try:
            from event_bus_manager import EventBusManager
            return EventBusManager.get_instance()
        except ImportError:
            logging.warning("EventBus not available - integration required")
            return None
            
    def emit_telemetry(self, data):
        if self.event_bus:
            self.event_bus.emit('telemetry', data)
    """
    GENESIS MultiAccountSplitter Integration Test Suite - PHASE 34
    Real-world event-driven testing through EventBus interface
    """
    
    def setUp(self):
        """Set up test environment with real event-driven interface"""
        self.splitter = MultiAccountSplitter()
        
        # Track emitted events
        self.emitted_events = []
        
        # Mock emit_event at module level
        def mock_emit_event(topic, data, source):
            self.emitted_events.append({
                "topic": topic,
                "data": data,
                "source": source,
                "timestamp": datetime.utcnow().isoformat()
            })
        
        # Patch the global emit_event function
        import multi_account_splitter
        self.original_emit = multi_account_splitter.emit_event
        multi_account_splitter.emit_event = mock_emit_event
        
        # Initialize with mock account data
        self._setup_mock_accounts()
    
    def tearDown(self):
        """Clean up test environment"""
        import multi_account_splitter
        multi_account_splitter.emit_event = self.original_emit
    
    def _setup_mock_accounts(self):
        """Setup mock account data for testing"""
        # Mock connected accounts
        self.splitter.connected_accounts = {
            "FTMO_001": {
                "account_id": "FTMO_001",
                "account_type": "FTMO Challenge",
                "broker": "FTMO",
                "enabled": True
            },
            "SWING_002": {
                "account_id": "SWING_002", 
                "account_type": "FTMO Swing",
                "broker": "FTMO",
                "enabled": True
            },
            "REGULAR_003": {
                "account_id": "REGULAR_003",
                "account_type": "Regular",
                "broker": "IC Markets",
                "enabled": True
            }
        }
        
        # Mock account capacities
        self.splitter.account_capacities = {
            "FTMO_001": {
                "equity": 100000.0,
                "margin_used": 5000.0,
                "margin_available": 95000.0,
                "utilization": 0.15
            },
            "SWING_002": {
                "equity": 200000.0,
                "margin_used": 10000.0,
                "margin_available": 190000.0,
                "utilization": 0.20
            },
            "REGULAR_003": {
                "equity": 50000.0,
                "margin_used": 2000.0,
                "margin_available": 48000.0,
                "utilization": 0.10
            }
        }
        
        # Mock account rules
        self.splitter.account_rules = {
            "FTMO_001": {
                "max_daily_loss": 5000.0,
                "max_total_loss": 10000.0,
                "max_position_size": 2.0,
                "allowed_symbols": ["EURUSD", "GBPUSD", "USDJPY"]
            },
            "SWING_002": {
                "max_daily_loss": 10000.0,
                "max_total_loss": 20000.0,
                "max_position_size": 5.0,
                "allowed_symbols": ["EURUSD", "GBPUSD", "USDJPY", "XAUUSD"]
            },
            "REGULAR_003": {
                "max_daily_loss": 2500.0,
                "max_total_loss": 5000.0,
                "max_position_size": 1.0,
                "allowed_symbols": ["EURUSD", "GBPUSD"]
            }
        }
    
    def test_01_module_initialization_compliance(self):
        """Test module initialization and architect mode compliance"""
        # Test basic properties
        self.assertEqual(self.splitter.module_name, "MultiAccountSplitter")
        self.assertEqual(self.splitter.version, "1.0")
        
        # Test telemetry structure
        required_telemetry_fields = [
            "trades_split", "accounts_routed_to", "capacity_warnings_issued",
            "position_adjustments_made", "module_start_time"
        ]
        
        for field in required_telemetry_fields:
            self.assertIn(field, self.splitter.telemetry)
        
        # Test routing algorithms
        valid_algorithms = ["dynamic_balanced", "equity_weighted", "risk_distributed"]
        self.assertIn(self.splitter.routing_algorithm, valid_algorithms)
        
        # Test logger initialization
        self.assertTrue(hasattr(self.splitter, 'logger'))
        
        print("‚úÖ Module initialization compliance test passed")
    
    def test_02_trade_signal_confirmed_event_handling(self):
        """Test TradeSignalConfirmed event handling"""
        # Clear previous events
        self.emitted_events.clear()
        
        # Create trade signal event
        trade_signal_event = {
            "event_type": "TradeSignalConfirmed",
            "data": {
                "signal_id": "TEST_SIGNAL_001",
                "symbol": "EURUSD",
                "direction": "BUY",
                "position_size": 1.0,
                "confidence": 0.85,
                "timestamp": datetime.utcnow().isoformat(),
                "stop_loss": 1.0800,
                "take_profit": 1.0900
            }
        }
        
        # Process event
        self.splitter.on_trade_signal_confirmed(trade_signal_event)
        
        # Check that events were emitted
        self.assertGreater(len(self.emitted_events), 0)
        
        # Check for expected event topics
        event_topics = [event["topic"] for event in self.emitted_events]
        
        # Should emit TradeRouteToAccount events
        route_events = [e for e in self.emitted_events if e["topic"] == "TradeRouteToAccount"]
        self.assertGreater(len(route_events), 0)
        
        # Validate route event structure
        for route_event in route_events:
            route_data = route_event["data"]
            self.assertIn("account_id", route_data)
            self.assertIn("symbol", route_data)
            self.assertIn("direction", route_data)
            self.assertIn("position_size", route_data)
            self.assertGreater(route_data["position_size"], 0)
        
        print("‚úÖ Trade signal confirmed event handling test passed")
    
    def test_03_account_status_update_event_handling(self):
        """Test AccountStatusUpdate event handling"""
        # Create account status update event
        account_update_event = {
            "event_type": "AccountStatusUpdate",
            "data": {
                "account_id": "FTMO_001",
                "equity": 98000.0,
                "margin_used": 7000.0,
                "margin_available": 91000.0,
                "balance": 100000.0,
                "timestamp": datetime.utcnow().isoformat()
            }
        }
        
        # Process event
        self.splitter.on_account_status_update(account_update_event)
        
        # Check that account capacities were updated
        self.assertEqual(self.splitter.account_capacities["FTMO_001"]["equity"], 98000.0)
        self.assertEqual(self.splitter.account_capacities["FTMO_001"]["margin_used"], 7000.0)
        
        print("‚úÖ Account status update event handling test passed")
    
    def test_04_account_rules_update_event_handling(self):
        """Test AccountRulesUpdate event handling"""
        # Create account rules update event
        rules_update_event = {
            "event_type": "AccountRulesUpdate",
            "data": {
                "account_id": "FTMO_001",
                "rules": {
                    "max_daily_loss": 4000.0,  # Updated rule
                    "max_total_loss": 8000.0,  # Updated rule
                    "max_position_size": 1.5,
                    "allowed_symbols": ["EURUSD", "GBPUSD", "USDJPY", "AUDUSD"]
                },
                "timestamp": datetime.utcnow().isoformat()
            }
        }
        
        # Process event
        self.splitter.on_account_rules_update(rules_update_event)
        
        # Check that account rules were updated
        self.assertEqual(self.splitter.account_rules["FTMO_001"]["max_daily_loss"], 4000.0)
        self.assertEqual(self.splitter.account_rules["FTMO_001"]["max_total_loss"], 8000.0)
        self.assertIn("AUDUSD", self.splitter.account_rules["FTMO_001"]["allowed_symbols"])
        
        print("‚úÖ Account rules update event handling test passed")
    
    def test_05_broker_rules_discovered_event_handling(self):
        """Test BrokerRulesDiscovered event handling"""
        # Create broker rules discovered event
        broker_rules_event = {
            "event_type": "BrokerRulesDiscovered",
            "data": {
                "broker_name": "FTMO",
                "account_type": "FTMO Challenge",
                "rules": {
                    "max_daily_loss_pct": 5.0,
                    "max_total_loss_pct": 10.0,
                    "max_leverage": 100,
                    "news_trading_allowed": False,
                    "weekend_trading_allowed": False
                },
                "timestamp": datetime.utcnow().isoformat()
            }
        }
        
        # Process event
        self.splitter.on_broker_rules_discovered(broker_rules_event)
        
        # Check that rules were processed (implementation may vary)
        # This test validates the event handler doesn't crash
        self.assertTrue(True)  # Placeholder assertion
        
        print("‚úÖ Broker rules discovered event handling test passed")
    
    def test_06_multiple_account_routing(self):
        """Test routing across multiple accounts"""
        self.emitted_events.clear()
        
        # Create large position signal that should be split
        large_signal_event = {
            "event_type": "TradeSignalConfirmed",
            "data": {
                "signal_id": "LARGE_SIGNAL_001",
                "symbol": "EURUSD",
                "direction": "BUY",
                "position_size": 5.0,  # Large position
                "confidence": 0.90,
                "timestamp": datetime.utcnow().isoformat()
            }
        }
        
        # Process event
        self.splitter.on_trade_signal_confirmed(large_signal_event)
        
        # Check that multiple route events were emitted
        route_events = [e for e in self.emitted_events if e["topic"] == "TradeRouteToAccount"]
        
        # Should route to multiple accounts for large position
        self.assertGreaterEqual(len(route_events), 2)
        
        # Check total position allocation
        total_allocated = sum(route["data"]["position_size"] for route in route_events)
        self.assertGreater(total_allocated, 0)
        self.assertLessEqual(total_allocated, 5.0)  # Should not exceed original
        
        # Check different accounts were used
        accounts_used = set(route["data"]["account_id"] for route in route_events)
        self.assertGreater(len(accounts_used), 1)
        
        print("‚úÖ Multiple account routing test passed")
    
    def test_07_capacity_warning_detection(self):
        """Test capacity warning detection and emission"""
        # Set up near-capacity account
        self.splitter.account_capacities["REGULAR_003"]["utilization"] = 0.92  # Near max
        
        self.emitted_events.clear()
        
        # Create signal for near-capacity account
        capacity_test_event = {
            "event_type": "TradeSignalConfirmed",
            "data": {
                "signal_id": "CAPACITY_TEST_001",
                "symbol": "EURUSD",
                "direction": "BUY",
                "position_size": 0.8,  # Large for small account
                "confidence": 0.75,
                "timestamp": datetime.utcnow().isoformat()
            }
        }
        
        # Process event
        self.splitter.on_trade_signal_confirmed(capacity_test_event)
        
        # Check for capacity warning events
        warning_events = [e for e in self.emitted_events if e["topic"] == "AccountCapacityWarning"]
        
        # May emit capacity warnings
        if len(warning_events) > 0:
            warning_data = warning_events[0]["data"]
            self.assertIn("account_id", warning_data)
            self.assertIn("utilization_percentage", warning_data)
        
        print("‚úÖ Capacity warning detection test passed")
    
    def test_08_telemetry_emission_validation(self):
        """Test telemetry emission and data structure"""
        self.emitted_events.clear()
        
        # Process several signals to generate telemetry
        for i in range(3):
            signal_event = {
                "event_type": "TradeSignalConfirmed",
                "data": {
                    "signal_id": f"TELEMETRY_TEST_{i:03d}",
                    "symbol": "GBPUSD",
                    "direction": "SELL" if i % 2 == 0 else "BUY",
                    "position_size": 0.5 + (i * 0.2),
                    "confidence": 0.70 + (i * 0.05),
                    "timestamp": datetime.utcnow().isoformat()
                }
            }
            
            self.splitter.on_trade_signal_confirmed(signal_event)
            time.sleep(0.01)  # Small delay for telemetry
        
        # Check for telemetry events
        telemetry_events = [e for e in self.emitted_events if e["topic"] == "ModuleTelemetry"]
        self.assertGreater(len(telemetry_events), 0)
        
        # Validate telemetry structure
        for telemetry_event in telemetry_events:
            telemetry_data = telemetry_event["data"]
            self.assertIn("module_name", telemetry_data)
            self.assertIn("event_type", telemetry_data)
            self.assertIn("timestamp", telemetry_data)
            self.assertEqual(telemetry_data["module_name"], "MultiAccountSplitter")
        
        print("‚úÖ Telemetry emission validation test passed")
    
    def test_09_error_handling_validation(self):
        """Test error handling for invalid inputs"""
        self.emitted_events.clear()
        
        # Test with invalid signal data
        invalid_signal_event = {
            "event_type": "TradeSignalConfirmed",
            "data": {
                "signal_id": "INVALID_001",
                # Missing required fields
                "timestamp": datetime.utcnow().isoformat()
            }
        }
        
        # Should handle gracefully without crashing
        try:
            self.splitter.on_trade_signal_confirmed(invalid_signal_event)
            # Check that error events were emitted
            error_events = [e for e in self.emitted_events if e["topic"] == "ModuleError"]
            # Should emit error but not crash
            self.assertTrue(True)  # Test that we reach this point
        except Exception as e:
            self.fail(f"Error handling failed: {e}")
        
        print("‚úÖ Error handling validation test passed")
    
    def test_10_routing_algorithm_switching(self):
        """Test switching between routing algorithms"""
        algorithms = ["dynamic_balanced", "equity_weighted", "risk_distributed"]
        
        for algorithm in algorithms:
            self.splitter.routing_algorithm = algorithm
            self.emitted_events.clear()
            
            # Process signal with current algorithm
            signal_event = {
                "event_type": "TradeSignalConfirmed",
                "data": {
                    "signal_id": f"ALGO_TEST_{algorithm}",
                    "symbol": "USDJPY",
                    "direction": "BUY",
                    "position_size": 1.5,
                    "confidence": 0.80,
                    "timestamp": datetime.utcnow().isoformat()
                }
            }
            
            self.splitter.on_trade_signal_confirmed(signal_event)
            
            # Check that routing occurred
            route_events = [e for e in self.emitted_events if e["topic"] == "TradeRouteToAccount"]
            self.assertGreater(len(route_events), 0)
            
            # Check that routing algorithm is reflected in route data
            for route_event in route_events:
                if "routing_algorithm" in route_event["data"]:
                    # Implementation may include algorithm info
    raise NotImplementedError("Real implementation required - no stubs allowed in production")
        print("‚úÖ Routing algorithm switching test passed")

def run_integration_tests():
    """
    Run the complete MultiAccountSplitter integration test suite
    ARCHITECT MODE v2.8 - Event-Driven Validation
    """
    print("üöÄ GENESIS MultiAccountSplitter Integration Test Suite v1.0 - PHASE 34")
    print("=" * 80)
    
    # Create test suite
    suite = unittest.TestLoader().loadTestsFromTestCase(TestMultiAccountSplitterIntegration)
    
    # Run tests with detailed output
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # Generate test report
    total_tests = result.testsRun
    failures = len(result.failures)
    errors = len(result.errors)
    passed = total_tests - failures - errors
    
    print("\n" + "=" * 80)
    print("üìä PHASE 34 MultiAccountSplitter Integration Test Results:")
    print(f"‚úÖ Tests Passed: {passed}/{total_tests}")
    print(f"‚ùå Tests Failed: {failures}")
    print(f"‚ö†Ô∏è  Test Errors: {errors}")
    print(f"üéØ Success Rate: {(passed/total_tests)*100:.1f}%")
    
    if failures > 0:
        print("\n‚ùå FAILED TESTS:")
        for test, traceback in result.failures:
            print(f"  - {test}: {traceback.split('AssertionError: ')[-1].split('\\n')[0]}")
    
    if errors > 0:
        print("\n‚ö†Ô∏è ERROR TESTS:")
        for test, traceback in result.errors:
            print(f"  - {test}: {traceback.split('Error: ')[-1].split('\\n')[0]}")
    
    # Compliance validation
    compliance_status = "FULLY_COMPLIANT" if (failures == 0 and errors == 0) else "VIOLATIONS_DETECTED"
    print(f"\nüîê ARCHITECT MODE COMPLIANCE: {compliance_status}")
    
    return {
        "total_tests": total_tests,
        "passed": passed,
        "failed": failures,
        "errors": errors,
        "success_rate": (passed/total_tests)*100,
        "compliance_status": compliance_status
    }

if __name__ == "__main__":
    # Run the integration test suite
    test_results = run_integration_tests()
    
    # Exit with appropriate code
    exit_code = 0 if test_results["failed"] == 0 and test_results["errors"] == 0 else 1
    exit(exit_code)

    def log_state(self):
        """Phase 91 Telemetry Enforcer - Log current module state"""
        state_data = {
            "module": __name__,
            "timestamp": datetime.now().isoformat(),
            "status": "active",
            "phase": "91_telemetry_enforcement"
        }
        if hasattr(self, 'event_bus') and self.event_bus:
            self.event_bus.emit("telemetry", state_data)
        return state_data
        

# <!-- @GENESIS_MODULE_END: test_multi_account_splitter_integration -->