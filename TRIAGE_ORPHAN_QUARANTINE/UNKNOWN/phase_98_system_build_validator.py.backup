#!/usr/bin/env python3
"""
üîß PHASE 98 ‚Äî SYSTEM BUILD VALIDATOR v3.0 - ARCHITECT MODE COMPLIANT
Final pass integrity validator before system prep for install
Ensures every GENESIS component from previous phases is validated and patched if necessary
Uses EventBus-connected architecture surveillance to enforce system integrity rules

üéØ PURPOSE: EventBus-driven validation with real-time telemetry
üì° EVENTBUS: Mandatory connection for all validation operations
üö´ ZERO TOLERANCE: No isolated functions, no mock data, no local calls
"""

import os
import json
import logging
from datetime import datetime, timezone
from typing import Dict, List, Any, Optional
from pathlib import Path

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger('Phase98Validator')

class Phase98SystemBuildValidator:
    """
    ARCHITECT MODE COMPLIANT System Build Validator
    EventBus-connected validation with mandatory telemetry emission
    """
    
    def __init__(self):
        """Initialize validator with mandatory EventBus connection"""
        # MANDATORY EventBus Connection - ARCHITECT MODE COMPLIANCE
        try:
            from event_bus import EventBus
            self.event_bus = EventBus()
            self.event_bus_connected = True
            logger.info("‚úÖ EventBus connection established")
        except ImportError:
            logger.error("‚ùå CRITICAL: EventBus import failed")
            raise ImportError("EventBus connection is mandatory for ARCHITECT MODE")
        
        # ARCHITECT MODE COMPLIANCE FLAGS
        self.real_data_only = True
        self.telemetry_enabled = True
        self.version = "98.0-architect_compliant"
        
        # Validation configuration
        self.required_files = [
            "system_tree.json",
            "module_registry.json", 
            "telemetry.json",
            "event_bus.json",
            "build_status.json",
            "genesis_config.json",
            "genesis_docs.json", 
            "genesis_telemetry.json",
            "genesis_event_bus.json",
            "compliance.json",
            "real_data.json",
            "mock_data.json"
        ]
        
        self.validation_results = {
            "files_validated": 0,
            "files_missing": [],
            "files_corrupted": [],
            "violations_detected": [],
            "repairs_applied": []
        }
        
        # Emit startup telemetry
        self._emit_startup_telemetry()
        
        logger.info("üîß Phase 98 System Build Validator v3.0 initialized - ARCHITECT MODE ACTIVE")
    
    def _emit_startup_telemetry(self):
        """Emit startup telemetry to EventBus"""
        if hasattr(self, 'event_bus') and self.event_bus:
            telemetry_data = {
                "module": "phase_98_system_build_validator",
                "status": "initialized",
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "architect_mode": True,
                "eventbus_connected": self.event_bus_connected,
                "real_data_only": self.real_data_only,
                "version": self.version
            }
            self.event_bus.emit("telemetry", telemetry_data)
            logger.info("üìä Startup telemetry emitted to EventBus")
    
    def validate_core_files(self) -> Dict[str, Any]:
        """
        ARCHITECT_MODE_COMPLIANCE: Validate all core files with EventBus reporting
        NO LOCAL VALIDATION - All results emitted via EventBus
        """
        logger.info("üîç Beginning Full System File Validation via EventBus...")
        
        for file_path in self.required_files:
            try:
                self._validate_single_file(file_path)
            except Exception as e:
                logger.error(f"‚ùå Validation error for {file_path}: {str(e)}")
                self.validation_results["violations_detected"].append({
                    "file": file_path,
                    "error": str(e),
                    "timestamp": datetime.now(timezone.utc).isoformat()
                })
        
        # Emit validation completion telemetry
        self.event_bus.emit("validation_complete", {
            "module": "phase_98_system_build_validator",
            "results": self.validation_results,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
        
        return self.validation_results
    
    def _validate_single_file(self, file_path: str) -> bool:
        """Validate individual file and emit results via EventBus"""
        if not os.path.exists(file_path):
            logger.error(f"‚ùå Missing: {file_path}")
            self.validation_results["files_missing"].append(file_path)
            
            # Emit missing file alert
            self.event_bus.emit("file_missing", {
                "file": file_path,
                "severity": "CRITICAL",
                "timestamp": datetime.now(timezone.utc).isoformat()
            })
            return False
        
        try:
            # Validate JSON structure
            with open(file_path, "r", encoding="utf-8") as handle:
                data = json.load(handle)
            
            # Special validation for critical files
            if file_path == "mock_data.json":
                self._validate_mock_data_empty(data, file_path)
            elif file_path == "build_status.json":
                self._validate_build_status(data, file_path)
            elif file_path == "system_tree.json":
                self._validate_system_tree(data, file_path)
            
            logger.info(f"‚úÖ Validated: {file_path}")
            self.validation_results["files_validated"] += 1
            
            # Emit successful validation
            self.event_bus.emit("file_validated", {
                "file": file_path,
                "status": "VALID",
                "timestamp": datetime.now(timezone.utc).isoformat()
            })
            return True
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Corrupted JSON in {file_path} ‚Üí FLAGGING FOR REPAIR")
            self.validation_results["files_corrupted"].append({
                "file": file_path,
                "error": str(e)
            })
            
            # Emit corruption alert
            self.event_bus.emit("file_corrupted", {
                "file": file_path,
                "error": str(e),
                "action_required": "REPAIR",
                "timestamp": datetime.now(timezone.utc).isoformat()
            })
            return False
    
    def _validate_mock_data_empty(self, data: Dict, file_path: str):
        """Ensure mock_data.json remains empty per ARCHITECT MODE requirements"""
        mock_sources = data.get("mock_data_sources", {})
        if mock_sources:
            violation = f"ARCHITECT_VIOLATION: mock_data.json contains data: {mock_sources}"
            logger.error(f"‚ùå {violation}")
            self.validation_results["violations_detected"].append({
                "file": file_path,
                "violation": violation,
                "severity": "CRITICAL"
            })
            
            # Emit critical violation
            self.event_bus.emit("architect_violation", {
                "type": "MOCK_DATA_DETECTED",
                "file": file_path,
                "data": mock_sources,
                "severity": "CRITICAL",
                "timestamp": datetime.now(timezone.utc).isoformat()
            })
    
    def _validate_build_status(self, data: Dict, file_path: str):
        """Validate build status compliance"""
        required_status = ["ARCHITECT_COMPLIANT", "CONSOLIDATED", "FULLY_COMPLIANT"]
        system_status = data.get("system_status")
        
        if system_status not in required_status:
            violation = f"Build status not compliant: {system_status}"
            self.validation_results["violations_detected"].append({
                "file": file_path,
                "violation": violation,
                "severity": "WARNING"
            })
    
    def _validate_system_tree(self, data: Dict, file_path: str):
        """Validate system tree connectivity"""
        total_modules = data.get("genesis_final_system", {}).get("total_modules", 0)
        
        if total_modules < 30:
            violation = f"System tree has insufficient modules: {total_modules}"
            self.validation_results["violations_detected"].append({
                "file": file_path,
                "violation": violation,
                "severity": "WARNING"
            })
    
    def run_architect_surveillance(self) -> Dict[str, Any]:
        """
        EventBus-connected architect surveillance hook
        Replaces direct function calls with EventBus routing
        """
        logger.info("üß† Running Architect Surveillance Hook via EventBus...")
        
        # Request surveillance via EventBus instead of direct import
        surveillance_request = {
            "module": "phase_98_system_build_validator",
            "action": "architect_surveillance",
            "timestamp": datetime.now(timezone.utc).isoformat()
        }
        
        # Emit surveillance request
        self.event_bus.emit("surveillance_request", surveillance_request)
        
        # Check for EventBus connectivity violations
        connectivity_violations = self._check_eventbus_connectivity()
        
        # Emit surveillance completion
        self.event_bus.emit("surveillance_complete", {
            "module": "phase_98_system_build_validator",
            "violations_found": len(connectivity_violations),
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
        
        return {"surveillance_complete": True, "violations": connectivity_violations}
    
    def _check_eventbus_connectivity(self) -> List[Dict]:
        """Check for EventBus connectivity violations"""
        violations = []
        
        try:
            # Check if system_tree.json has disconnected modules
            with open("system_tree.json", "r") as f:
                system_tree = json.load(f)
            
            # Scan for eventbus_connected: false
            for section in system_tree.values():
                if isinstance(section, dict):
                    for module_name, module_data in section.items():
                        if isinstance(module_data, dict):
                            if module_data.get("eventbus_connected") is False:
                                violation = {
                                    "module": module_name,
                                    "violation": "EventBus not connected",
                                    "severity": "CRITICAL"
                                }
                                violations.append(violation)
                                
                                # Emit violation alert
                                self.event_bus.emit("eventbus_violation", {
                                    "module": module_name,
                                    "violation": "disconnected",
                                    "timestamp": datetime.now(timezone.utc).isoformat()
                                })
        
        except Exception as e:
            logger.error(f"Error checking EventBus connectivity: {str(e)}")
        
        return violations
    
    def generate_validation_report(self) -> Dict[str, Any]:
        """Generate comprehensive validation report via EventBus"""
        report = {
            "phase": "98",
            "validator_version": self.version,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "architect_mode": True,
            "validation_results": self.validation_results,
            "system_status": "VALIDATED" if not self.validation_results["violations_detected"] else "VIOLATIONS_DETECTED"
        }
        
        # Emit final report
        self.event_bus.emit("validation_report", report)
        
        return report
    
    def execute_phase_98_validation(self) -> Dict[str, Any]:
        """
        Main execution method - ARCHITECT MODE COMPLIANT
        All operations via EventBus, no isolated functions
        """
        logger.info("üîß PHASE 98: Beginning Full System File Validation...")
        
        # Step 1: Validate core files
        file_validation = self.validate_core_files()
        
        # Step 2: Run architect surveillance
        surveillance_results = self.run_architect_surveillance()
        
        # Step 3: Generate report
        final_report = self.generate_validation_report()
        
        # Emit completion telemetry
        self.event_bus.emit("phase_98_complete", {
            "module": "phase_98_system_build_validator",
            "status": "COMPLETE",
            "files_validated": self.validation_results["files_validated"],
            "violations_detected": len(self.validation_results["violations_detected"]),
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
        
        if self.validation_results["violations_detected"]:
            logger.warning("üö® Violations detected ‚Üí Manual review recommended")
            return {"status": "VIOLATIONS_DETECTED", "report": final_report}
        else:
            logger.info("‚úÖ PHASE 98 COMPLETE ‚Äî SYSTEM IS VALIDATED")
            return {"status": "VALIDATED", "report": final_report}

# ARCHITECT MODE COMPLIANCE EXECUTION
def main():
    """ARCHITECT MODE COMPLIANT execution entry point"""
    try:
        validator = Phase98SystemBuildValidator()
        results = validator.execute_phase_98_validation()
        
        if results["status"] == "VALIDATED":
            print("‚úÖ PHASE 98 COMPLETE ‚Äî SYSTEM IS VALIDATED")
        else:
            print("üö® PHASE 98 COMPLETE ‚Äî VIOLATIONS DETECTED")
            
        return results
        
    except Exception as e:
        logger.error(f"‚ùå Phase 98 validation failed: {str(e)}")
        raise

if __name__ == "__main__":
    main()
